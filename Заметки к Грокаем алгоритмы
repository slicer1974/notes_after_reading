о В массиве все элементы хранятся в памяти рядом друг с другом. 
Поэтому если при увеличении массива ячейка за его последней занята  - массив целиком нужно переносить на новое место.
о В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента. 
о Массивы обеспечивают быстрое чтение. 
о Списки обеспечивают быструю вставку и выполнение. 
о Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).

о Бинарный поиск работает намного быстрее простого.
о Время выполнения алгоритмов выражается как «О-большое.

о Когда функция вызывает саму себя, это называется рекурсией. 
о В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный . 
о Стек поддерживает две операции: зане ­ сение и извлечение элементов. 
о Все вызовы функций сохраняются в сте­ ке вызовов. 
о Если стек вызовов станет очень большим, он займет слишком много памяти.

о Стратегия «разделяй и властвуй» основана на разбиении задачи на уменьшающиеся фрагменты. Если использовать стратегию «разделяй и вла­ствуй» со списком, то базовым случаем, скорее всего, является пустой массив или массив из одного элемента . 
 Алгоритм бытрой сортировки:
	1. Выбрать опорный элемент. 
	2. Разделить массив на два подмассива: элементы, меньшие опорного, и элементы, большие опорного. 
	3. Рекурсивно применить быструю сортировку к двум подмассивам.
о Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сор­тировки составляет О(п log п)! 
о Константы в «О-большом» иногда могут иметь значение . Именно по этой причине быстрая сортировка быстрее сортировки слиянием. 
о При сравнении простой сортировки с бинарной константа почти никогда роли не играет, потому что O(log п) слишком сильно превосходит О(п) по скорости при большом размере 		списка.

о Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую скорость операций и позволяют по-разному моделировать данные.  
о Хеш-таблица создается объединением хеш-функции с массивом. 
о Коллизии нежелательны. Хеш -функция должна свести количество кол­ лизий к минимуму. 
о Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления. 
о Хеш-таблицы хорошо подходят для моделирования отношений между объектами. 
о Как только коэффициент заполнения превышает 0,7, пора изменять раз­ мер хеш-таблицы . 
о Хеш-таблицы используются для кэширования данных (например, на веб-серверах ). 
о Хеш-таблицы хорошо подходят для обнаружения дубликатов.

о Очереди относятся к категории FIFO («первым вошел, первым вышел»). 
о Стек относится к категории LIFO («последним пришел, первым вышел»).
о Поиск в ширину вычисляет кратчайший путь в невзвешенном графе. 
о Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном ациклическом графе. 
о Алгоритм Дейкстры работает только в том случае, если все веса поло­жительны.
о При наличии отрицательных весов используйте алгоритм Беллмана­ Форда.

о Жадные алгоритмы стремятся к локальной оптимизации  на каждом шаге в расчете на то, что в итоге будет достигнут глобальный оптимум. 
о У NР-полных задач не существует известных быстрых решений. 
Несколько характерных признаков того, что задача, с которой вы работаете, является NР-полной: 
- ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа; i
- формулировка ~все комбинации х~ часто указывает на NР-полноту за­дачи; 
- вам приходится вычислять все возможные варианты Х, потому что за­ дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной; 
- если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной; 
- если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения, она может оказаться NР-полной; 
- можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае ваша задача определенно является NР-полной.
о Если у вас имеется NР-полная задача, лучше всего воспользоваться при­ ближенным алгоритмом. 
о Жадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы.

о Динамическое программирование применяется при оптимизации некоторой характеристики. 
о Динамическое программирование работает только в ситуациях, в которых задача может быть разбита на автономные подзадачи. 
о В каждом решении из области динамического программирования строится таблица. 
о Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике. 
о Каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи. 
о Не существует единой формулы для вычисления решений методом динамического программирования .

о Алгоритм k ближайших соседей применяется для классификации и ре­грессии. В нем используется проверка k ближайших соседей. Близость определяется минимумом количественных показателей
о Классификация = распределение по категориям. 
о Регрессия= прогнозирование результата (например, в виде числа). 
о «Извлечением признаков» называется преобразование элемента (на ­ пример, фрукта или пользователя) в список чисел, которые могут ис­пользоваться для сравнения. 
о Качественный выбор признаков - важная часть успешного алгоритма k ближайших соседей .