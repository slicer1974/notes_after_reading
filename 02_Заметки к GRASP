Pure Fabrication
Проблема: какой класс должен обеспечить реализацию шаблонов High Cohesion и Low Coupling или других принципов проектирования, если шаблон Expert (например) не обеспечивает подходящего решения?
Объектно-ориентированные системы отличаются тем, что программные классы реализуют понятия предметной области, как, например, классы Sale и Customer. Однако существует множество ситуаций, когда распределение обязанностей только между такими классами приводит к проблемам с зацеплением и связыванием, т.е. с невозможностью повторного использования кода.
Решение: присвоить группу обязанностей с высокой степенью зацепления искусственному классу, не представляющему конкретного понятия предметной области, т.е. синтезировать искусственную сущность для поддержки высокого зацепления, слабого связывания и повторного использования.
Такой класс является продуктом нашего воображения и представляет собой синтетику (fabrication). В идеале присвоенные этому классу обязанности поддерживают высокую степень зацепления и низкое связывание, так что структура этого синтетического класса является очень прозрачной, или чистой (pure). Отсюда и название: Pure Fabrication (“чистая синтетика”).

Indirection
Проблема: как распределить обязанности, чтобы обеспечить отсутствие прямого связывания; снизить уровень связывания объектов, согласно шаблону Low Coupling, и сохранить высокий потенциал повторного использования?
Решение: присвоить обязанности промежуточному объекту для обеспечения связи между другими компонентами или службами, которые не связаны между собой напрямую.

Protected Variations
Проблема: как спроектировать объекты, подсистемы и систему, чтобы изменение этих элементов не оказывало нежелательного влияния на другие элементы?
Решение: идентифицировать точки возможных вариаций или неустойчивости; распределить обязанности таким образом, чтобы обеспечить устойчивый интерфейс.

Creator
Проблема: кто должен отвечать за создание нового экземпляра некоторого класса?
Создание объектов в объектно-ориентированной системе является одним из наиболее стандартных видов деятельности. Следовательно, при назначении обязанностей, связанных с созданием объектов, полезно руководствоваться некоторым основным принципом. Правильно распределив обязанности при проектировании, можно создать слабо связанные независимые компоненты с возможностью их дальнейшего использования, упростить их, а также обеспечить инкапсуляцию данных и их повторное использование.
Решение: назначить классу В обязанность создавать экземпляры класса А, если выполняется одно из следующих условий.
■	Класс В содержит (contains) или агрегирует (aggregate) объекты А.
■	Класс В записывает (records) экземпляры объектов А.
■	Класс В активно использует (closely uses) объекты А.
■	Класс В обладает данными инициализации (has the initializing data), которые будут передаваться объектам А при их создании (т.е. при 		создании объектов А классВ является экспертом).
Класс В — создатель (creator) объектов А.
Если выполняется несколько из этих условий, то лучше использовать класс В, агрегирующий или содержащий класс А.

Information Expert (или Expert)
Проблема: каков наиболее общий принцип распределения обязанностей между объектами при объектно-ориентированном проектировании?
В модели системы могут быть определены десятки или сотни программных классов, а в приложении может потребоваться выполнение сотен или тысяч обязанностей. Во время объектно-ориентированного проектирования при формулировке принципов взаимодействия объектов необходимо распределить обязанности между классами. При правильном выполнении этой задачи система становится гораздо проще для понимания, поддержки и расширения. Кроме того, появляется возможность повторного использования уже разработанных компонентов в последующих приложениях.
Решение: назначить обязанность информационному эксперту — классу, у которого имеется информация, требуемая для выполнения обязанности.

Controller
Проблема: кто должен отвечать за получение и координацию выполнения системных операций, поступающих на уровне интерфейса пользователя?
Контроллер (controller) — это объект, не относящийся к интерфейсу пользователя и отвечающий за получение или обработку системных сообщений.
Решение: делегирование обязанностей по обработке системных сообщений классу, удовлетворяющему одному из следующих условий.
■	Класс представляет всю систему в целом, корневой объект, устройство или подсистему (внешний контроллер).
■	Класс представляет сценарий некоторого прецедента, в рамках которого выполняется обработка всех системных событий, и обычно называется <Прецедент>Handler, <Прецедент>Coordinator или <Прецедент>Session (контроллер прецедента, или контроллер сеанса).
•	Для всех системных событий в рамках одного сценария прецедента используется один и тот же класс-контроллер.
•	Неформально сеанс — это экземпляр взаимодействия с исполнителем. Сеансы могут иметь произвольную длину, но зачастую они организованы в рамках прецедента (сеансы прецедента).

