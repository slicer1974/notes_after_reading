Γ обычно используется для ссылки на среду или контекст; в этом случае его можно рассматривать как множество аннотаций типов, связывающих различные идентификаторы с их типами. 
Поэтому x : σ ∈ Γ означает, что среда Γ включает в себя тот факт, что x имеет тип σ.
⊢ можно прочитать как доказывает или определяет или выводится. Γ ⊢ x : σ означает, что среда Γ определяет, что x имеет тип σ  (выражение x : σ выводится из контекста Г) .
Символ ⊢ по сути означает, что вы можете что-то доказать. Итак, Γ ⊢ ... - это утверждение, говорящее "Я могу доказать ... в контексте Γ". Эти утверждения также называются суждениями типа. Контексты можно расширять, добавляя определение новой переменной.
Контекст можно рассматривать как частичную функцию из множества переменных V во множество типов Т. Контекст можно расширять, добавляя к нему записи через запятую: 
Γ, x : σ

2.2.1 Бинарное отношение R на множестве S рефлексивно, если каждый элемент S связан отношением R с самим собой т. е. для всех s ∈ S , s R s (или (s, s) ∈ R). Отношение R симметрично, если для всех s, t ∈ S из s R t следует t R s. Отношение R транзитивно, если из s R t и t R u следует s R u. Отношение R антисимметрично, если из s R t и t R s следует s = t .
2.2.2 Рефлексивное и транзитивное отношение R на множестве S называется предпорядком (preorder) на S . (Всякий раз, когда мы говорим о «предупорядоченном множестве S », мы имеем в виду какой- то конкретный предпорядок на S .) Предпорядки обычно обозначаются символами ⩽ или ⊑. Запись s < t означает, что s ⩽ t ∧ s ̸= t («s строго меньше t »).
2.2.4 Рефлексивное, транзитивное и симметричное отноше-ние на множестве S называется отношением эквивалентности (equivalence relation) на S .

t ::= 				термы: 
	true 			константа «истина» 
	false 			константа «ложь» 
	if t then t else t 	условное выражение 
	0 				константа «ноль» 
	succ t 			следующее число 
	pred t 			предыдущее число 
	iszero t 			проверка на ноль.
Формат описания этой грамматики (и других грамматик в тексте этой книги) близок к стандартной форме Бэкуса - Наура. В первой строке (t ::=) определяется набор ТЕРМОВ (terms), а также объявляется, что для обозначения термов мы будем употреблять букву t. Остальные строки описывают синтаксические формы, допустимыe для термов. Всюду, где встречается символ t, можно подставить любой терм. В правой колонке - комментарии.

Для обозначения ЗНАЧЕНИЙ - возможных результатов вычислений - далее используется  буква v.

Семантика языка - то, как вычисляются термы.
Существует 3 основных подхода к формализации семантики:
1. Операционная семантика (operational semantics) специфицирует поведение языка программирования, определяя для него простую абстрактную машину (abstract machine). Машина эта «абстрактна» в том смысле, что в качестве машинного кода она использует термы языка, а не набор команд какого-то низкоуровневого микропроцессора. Для простых языков состояние (state) машины - это просто терм, а поведение ее определяется функцией перехода (transition function), которая для каждого состояния либо указывает следующее состояние, произведя шаг упрощения старого терма, либо объявляет машину остановившейся. Смыслом (meaning) терма t объявляется конечное состояние, которого машина достигает, будучи запущена с начальным состоянием t. 

2. Денотационная семантика (denotational semantics) рассматривает смысл с более абстрактной точки зрения: смыслом терма считается не последовательность машинных состояний, а некоторый математи- ческий объект, например число или функция. Построение денотационной семантики для языка состоит в нахождении некоторого набора семантических доменов (semantic domains), а также определении функции интерпретации (interpretation function), которая ставит элементы этих доменов в соответствие термам. Поиск подходящих семантических до- менов для моделирования различных языковых конструкций привел к возникновению сложной и изящной области исследований, известной как теория доменов (domain theory). Одно из важных преимуществ денотационной семантики состоит в том, что она абстрагируется от мелких деталей выполнения програм- мы и концентрирует внимание на основных понятиях языка. Кроме то- го, свойства выбранного набора семантических доменов могут исполь- зоваться для выявления важных законов поведения программ  - напри- мер, законов, утверждающих, что две программы ведут себя одинако- во или что поведение программы соответствует некоторой специфика- ции. Наконец, из свойств выбранного набора семантических доменов часто непосредственно ясно, что некоторые (желательные или нежелательные) вещи в данном языке невозможны.
 
3. Аксиоматическая семантика (axiomatic semantics) предполагает более прямой подход к этим законам: вместо того чтобы сначала опреде- лить поведение программ (с помощью операционной или денотацион- ной семантики), а затем выводить из этого определения законы, акси- оматические методы используют сами законы в качестве определения языка. Смысл терма - это то, что о нем можно доказать. Красота аксиоматических методов в том, что они концентрируют вни- мание на процессе рассуждений о программах. Именно эта традиция мышления обогатила информатику такими мощными инструментами, как инварианты (invariants).

Терм t находится в нормальной форме (normal form), если к нему не применимо никакое правило вычисления, т. е. если не существует такого t′ , что t → t′ . 
Всякое значение находится в нормальной форме.
Терм называется тупиковым (stuck), если он находится в нормальной форме, но не является значением.
->* обозначает операцию семантики с малым шагом

«λn. ...» обозначает «функция, которая для каждого n дает …»,
Синтаксис лямбда-исчисления состоит из трех видов термов1 : 
	ПЕРЕМЕННАЯ x сама по себе есть терм; 
	АБСТРАКЦИЯ переменной x в терме t1 (записывается как λx.t1 ) тоже терм; 
	ПРИМЕНЕНИЕ (АППЛИКАЦИЯ) t1 к терму t2 (записывается t1 t2 )  - третий вид термов. 
Эти способы конструирования термов выражаются следующей грамматикой: 
		t ::= 		термы: 
			x 		переменная 
			λx. t 	абстракция 
			t t 		применение
Чтобы избежать излишних скобок, для записи лямбда-термов в линейной форме мы следуем двум соглашениям. 
	Во-первых, ПРИМЕНЕНИЕ лево-ассоциативно т. е. s t u обозначает то же , что (s t) u
	Во-вторых, АБСТРАКЦИЯ ассоциативна вправо, т.е.  λx. λy. x обозначает то же, что и λx. (λy. x) 
	В-третьих, тела АБСТРАКЦИЙ простираются направо как можно дальше, так что, например, λx. x y x означает то же самое, что и λx. (x y x). Чтоюы остановить действие АБСТРАКЦИИ ее нужно заключить в скобки. 
	
Переменная x называется СВЯЗАННОЙ (bound) абстракцией λx.t., если она находится в теле t абстракции λx.t.  Если переменная не связана абстракцией она называется СВОБОДНОЙ
Терм без свободных переменных называется ЗАМКНУТЫМ (closed); замкнутые термы называют также КОМБИНАТОРАМИ (combinators). 

ПОДСТАНОВКА: t1[x→ s] обозначает подстановку s вместо СВОБОДНЫХ вхождений x в t1. 
Правила подстановки:
	x[x→ s]  		 = s 
	y[x→ s]  		 = y						если y ̸= x
	(t1 t2 )[x→ s]  = (t1[x→ s] ) (t2[x→ s] )	
	(λy.t1)[x→ s]  = λy. (t1 [x→ s])			если y ̸= x и y  /∈ F V (s) 
	(λy.t1)[x→ s]  = (λy.t1)					если y = x 	

Преобразование  (λy.t1)s  →  t1[y→ s] называется БЕТА-РЕДУКЦИЕЙ или БЕТА-ПРЕОБРАЗОВАНИЕМ.  (λy.t1)s  называется РЕДЕКСОМ.
Применение в  (λx.λy.λz.x y z)s p q всегда начинается с замены ПЕРВОЙ абстракции, т.е на первом шаге редукции будет (λy.λz.s y z)p q, далее (λz.s р z)q и конечный результат s p q.

Идея ДеБрауна - заменить именованнные переменные в термах натуральными числами так, чтобы число k означало «переменная, связанная k-й охватывающей λ». Например, обыкновенный терм λx.x соответствует безымянному терму (nameless term) λ.0, а терму λx.λy. x (y x) соответствует λ.λ. 1 (0 1). Безымянные термы иногда еще называют термами де Брауна (de Bruĳn terms), а нумерованные переменные в них называются индексами де Брауна (de Bruĳn indices).

Комбинатор неподвижной точки - Y= λf.(λx.f(x x)) (λx.f(x x)). Легко заметить, что подстановка  любой функции F даст: YF = (λx.F(x x)) (λx.F(x x)) = F(λx.F(x x)) (λx.F(x x))  = F(YF).

Теоремы:
λ-терм НАХОДИТСЯ в НОРМАЛЬНОЙ ФОРМЕ, если в нем нет подтермов, являющихся редексами.
λ-терм ИМЕЕТ НОРМАЛЬНУЮ ФОРМУ, если его подтермы можно привести к нормальной форме.
λ-терм ИМЕЕТ не более одной НОРМАЛЬНОЙ ФОРМЫ. 

Типы - синтаксические конструкции, приписываемые термам по определенным правилам.
Применение типа правоассоциативно.

Cистема ПРОСТОГО типизированного λ-исчисления (λ->)
В стиле Карри терм может обладать любым типом (используется в Haskell, например)
В стиле Чёрча тип терму приписывается сразу (используется в императивных языках)

В системе простого типизированного λ-исчисления в стиле Карри термы нетипизированного  λ-исчисления в точности соответствуют ПРЕДТЕРМАМ.
В системе простого типизированного λ-исчисления в стиле Черча ПРЕДТЕРМАМ образуются с помощью аннотирования типами абстракции в нетипизированном  λ-исчислении, остальные термы соответствуют. 

В системах по Чёрчу соблюдается единственность типов: Всякий терм t имеет не более одного типа. То есть если t типизируем, то у него есть единственный тип. Для систем по Карри единственности типов нет.
Теоремы, необходимые для безопасности системы типов:
Продвижение: Правильно типизированный терм не может быть тупиковым (либо это значение, либо он может проделать следующий шаг в соответствии с правилами вычисления).
Сохранение: Если правильно типизированный терм проделывает шаг вычисления, то получающийся терм также правильно типизирован. (т.е. тип терма сохраняется при бетта-редукции).
В отличие от единственности типов, которая присутствует в одних системах и отсутствует в других, продвижение и сохранение останутся важнейшими требованиями для всех систем типов, которые считаются типобезопасными.
Лемма об инверсии определяет для каждой синтаксической формы, какие условия должны выполняться, чтобы терм считался правильно типизированным.
Если в терме есть свободная переменная - она должна быть в контексте Г. По большому счету контекст и нужен для определения свободных переменных.
Переменная должна быть описана в контексте СТРОГО ОДИН РАЗ.
Предтермы ω = λx.xx,  Ω = ω ω и Y = λf.(λx.f(xx))(λx.f(xx)) не имеют типа (при самоприменении х к х возникает противоречие такое, что х должен иметь и простой и стрелочный тип).

Проблемы разрешимости:
⊢ x : σ? - задача проверки типа (ЗПТ, TCP)
⊢ x : ?  - задача синтеза типа (ЗСТ, TSP, TAP)
⊢ ? : σ  - задача обитаемости типа (ЗОТ, TIP)
Для простого типизированного λ-исчисления ( λ->) все эти задачи разрешимы.
Система типов λ-> СИЛЬНО НОРМАЛИЗУЕМА, т.е. любой допустимый терм λ-> редуцируется к нормальной форме.

Многие элементарные значения данных, такие как булевские значения, числа и списки, можно закодировать в виде функций в λ->.  Например:
	булевы значения
	tru = λt. λf. t; 
	fls = λt. λf. f;
	
	пары
	pair = λf.λs.λb. b f s; 
	fst = λp. p tru; 
	snd = λp. p fls;

	числа Чёрча
	c0 = λs. λz. z; 
	c1 = λs. λz. s z;
	c2 = λs. λz. s (s z); 
	c3 = λs. λz. s (s (s z));
	и.т.д и т. д. Здесь каждое число n представляется комбинатором cn , который принимает два аргумента, s и z («функцию следования» и «ноль»), и n раз применяет s к z. 

	Число в единичной системе счисления подобно списку из некоторых элементов, точная природа которых несущественна. 
	Способ кодирования списков по Чёрчу - список с элементами x, y и z представляется как функция, которая, получая функцию f и начальное значение v, вычисляет f x (f y (f z v)). 

В основном используются два альтернативных представления рекурсивных типов: эквирекурсивные типы, которые по определению эквивалентны своим разверткам, и изорекурсивные типы, где эквивалентность явно отмечается при помощи термов fold и unfold. 
Например, в языках семейства ML каждое определение datatype неявно вводит рекурсивный тип. Каждое использование конструктора при построении значения конкретного типа данных неявно включает fold, а конструктор, используемый при сопоставлении с образцом, неявно применяет unfold. Аналогично, в Java каждое определение класса вводит ре- курсивный тип, а выполнение метода объекта включает неявный unfold.

Можно рассматривать неинтерпретируемые базовые типы как типовые переменные (type variables), которые можно конкретизировать (instantiate) с помощью подстановки (substitution) другими типами.
Подстановку можно разделить на 2 части:
	ОПИСАТЬ отображение σ типовых переменных на типы, которое называется подстановкой типов (type substitution), и 
	ПРИМЕНИТЬ это отображение к конкретному типу T, получая конкретизацию σT. 
Например, можно определить σ = [X 7→ Bool], а затем применить σ к типу X→X, получая σ(X → X) = Bool → Bool.
Применение подстановки к типу определяется очевидным образом: 
	σ(X) = T, если (X 7→ T) ∈ σ 
	σ(X) = X, если X ∈ / dom(σ) 
	σ(Nat) = Nat 
	σ(Bool) = Bool 
	σ(T1 →T2 ) = σT1 → σT2
где σ - типовая переменная, dom(σ)  - множество типовых переменных.
Ключевое свойство подстановок типов состоит в том, что они сохра- няют корректность утверждений о типизации: если терм, содержащий типовые переменные, правильно типизирован, таков же будет и результат применения к нему произвольной подстановки.

Два СУЩЕСТВЕННО РАЗЛИЧНЫХ вопроса о типовых переменых:
	1. «Все ли конкретизации t правильно типизированы?» То есть верно ли, что при любой σ мы будем иметь σΓ ⊢ σt : T для некоторого T? 
	2. «Имеются ли правильно типизированные конкретизации t?» То есть можем ли мы найти такую σ, что σΓ ⊢ σt : T для некоторого T?
Согласно 1, типовые переменные должны оставаться абстрактными во время проверки типов, что приводит нас к ПАРАМЕТРИЧЕСКОМУ ПОЛИМОРФИЗМУ (parametric polymorphism), при котором типовые переменные используются для передачи того факта, что терм можно использовать в раз- личных контекстах с различными конкретными типами.
Поиск корректных конкретизаций для типовых переменных согласно 2 является основой идеи РЕКОНСТРУКЦИИ ТИПОВ (type reconstruction) (иногда ее еще называют выводом типов, type inference), в рамках которой компилятор помогает восстановить информацию о типах, опущенную программитом.

Идея отношения типизации с ОГРАНИЧЕНИЯМИ состоит в том, что мы можем проверить, типизируем ли терм t в контексте Γ, следующим образом: сначала собираем ограничения C , которым нужно удовлетворить, чтобы t имел тип, и одновременно получаем тип S, содержащий переменные из C и характеризующий возможные типы t с точностью до этих переменных. Затем, чтобы найти решения для t, мы просто ищем подстановки σ, удовлетворяющие ограничениям C (т. е. превращающие все уравнения из C в тождества); для каждой такой σ тип σS есть возможный тип t. Если мы обнаружим, что нет подстановок, удовлетворяющих ограничениям C , то значит, t невозможно конкретизировать так, чтобы он стал типизируемым.

Программирование путем копирования и вставки текста нарушает один из главных принципов разработки программ: 
	Каждая существенная область функциональности в программе должна быть реализована всего в одном месте программного кода. Если различные фрагменты кода реа лизуют аналогичную функциональность, то, как правило, имеет смысл слить их в один фрагмент, абстрагируя (abstracting out) различающиеся частию

	УНИВЕРСАЛЬНЫЕ ТИПЫ:	Логическая интуиция (logical intuition) говорит нам, что элемент типа ∀X.T является значением, которое имеет тип [X → S]T при ЛЮБОМ выборе S. Это интуитивное представление соответствует взгляду на поведение со стиранием типов: например, полиморфная функция тождества λX.λx:X.x при стирании дает бестиповую функцию тождества λx.x, которая переводит аргумент любого типа S в результат того же типа. па. Операционная интуиция (operational intuition) состоит в том, что элементом λX.T является функция, которая переводит тип S в специализированный терм типа [X → S]T. 
	ЭКЗИСТЕНЦИАЛЬНЫЕ ТИПЫ: Логическая интуиция (logical intuition) говорит нам, что элементом {∃X,T} является значение типа [X → S]T для КАКОГО-ТО типа S. С другой стороны, операционная интуиция говорит, что элементом {∃X,T} служит пара, которая записывается как {*S,t}, состоящая из типа S и терма t, имеющего тип [X → S]T.
	Экзистенциальные типы можно закодировать в виде универсальных типов, поскольку интуитивно элемент экзистенциального типа представляет собой пару из типа и значения: def {∃X,T} = ∀Y. (∀X.T→Y) → Y. То есть экзистенциальный пакет рассматривается как значение, которое, получая тип результата и продолжение (continuation), вызывает продолжение и получает окончательный результат. Продолжение принимает два аргумента  - тип X и значение типа T - и использует их при вычислении окончательного результата.

	Традиционный абстрактный тип данных, или АТД (abstract data type, ADT), состоит из а) имени типа A, б) типа конкретного представления T, в) реализации некоторых операций создания, извлечения информации и манипулирования значениями типа T и г) барьера абстракции (abstraction boundary), отделяющего представление и операции от внешнего мира. Внутри барьера абстракции элементы типа рассматриваются как конкретные значения (типа T). Вне барьера они рассматриваются абстрактно, как значения типа A. Значения типа A можно передавать из процедуры в процедуру, хранить в структурах данных и т. д., но нельзя напрямую обращаться к их представлению и изменять его. Над A разрешены только те операции, которые предоставляет АТД.