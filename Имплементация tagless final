Instead of committing to a concrete effect type (like Future, IO, or Option) early in the design, Tagless Final allows you to define your program logic using a higher-kinded type parameter, conventionally F[_]. This F represents any "container" or "effect" that satisfies certain capabilities (e.g., being a Monad, Sync, Applicative).
Algebras:
Business logic is defined as "algebras," which are typically traits or abstract classes parameterized by F[_]. These algebras declare the operations available within a specific domain, without specifying how those operations are performed or what effect they produce.
Interpreters:
"Interpreters" are concrete implementations of these algebras for specific effect types. For example, you might have an InMemoryUserRepository[F[_]] that interprets UserRepositoryAlgebra[F] using an in-memory data structure, and a DoobieUserRepository[F[_]] that interprets it using a database library like Doobie.

Benefits:

    Decoupling:
    Business logic is decoupled from the underlying effect system and implementation details, promoting modularity and reusability.
    Testability:
    Different interpreters can be used for testing (e.g., an in-memory interpreter for unit tests) and production (e.g., a database interpreter).
    Flexibility:
    The choice of effect type can be changed or adapted without modifying the core business logic.
    Referential Transparency:
    When used with pure functional effect types, it helps maintain referential transparency, making programs easier to reason about.

How it works (Simplified):
Код

// 1. Define an Algebra (trait)
trait Console[F[_]] {
  def putStrLn(s: String): F[Unit]
  def getStrLn: F[String]
}

// 3. Use the Algebra in your program logic
import cats.Monad
class Program[F[_]: Monad](console: Console[F]) {
  def greet: F[Unit] =
    for {
      _ <- console.putStrLn("What is your name?")
      name <- console.getStrLn
      _ <- console.putStrLn(s"Hello, $name!")
    } yield ()
}

// 2. Define an Interpreter for a specific effect (e.g., cats.effect.IO)
import cats.effect.IO
object IoConsole extends Console[IO] {
  def putStrLn(s: String): IO[Unit] = IO.println(s)
  def getStrLn: IO[String] = IO.readLine
}

// 4. Run the program with a concrete interpreter
object Main extends App {
  import cats.effect.unsafe.implicits.global // For running IO
  val program = new Program(IoConsole)
  program.greet.unsafeRunSync()
}



object TaglessFinal_V2 {
//Алгебра
  trait UserLogin[E[_]] {
    def checkLogin(mfa: Boolean): E[Boolean]
    def countActiveSessions(server: Int): E[Int]
    def mfa_v1(email: E[Boolean], sms: E[Boolean]): E[Boolean]
    def mfa_v2(phone: E[Boolean], mobileApp: E[Boolean]): E[Boolean]
    def totalSessionLogins(server1Logins: E[Int], server2Logins: E[Int]): E[Int]
  }
//Имплементация алгебры
  case class UserLoginStatus[A](value: A)
  given loginCapabilityImplementation: UserLogin[UserLoginStatus] with {
    override def checkLogin(mfa: Boolean) = UserLoginStatus(mfa)
    override def countActiveSessions(server: Int) = UserLoginStatus(server)
    override def mfa_v1(email: UserLoginStatus[Boolean], sms: UserLoginStatus[Boolean]) = UserLoginStatus(email.value || sms.value)
    override def mfa_v2(phone: UserLoginStatus[Boolean], mobileApp: UserLoginStatus[Boolean]) = UserLoginStatus(phone.value && mobileApp.value)
    override def totalSessionLogins(server1Logins: UserLoginStatus[Int], server2Logins: UserLoginStatus[Int]) = UserLoginStatus(server1Logins.value + server2Logins.value)
  }

//Бизнес-логика
  def userLoginFlow[E[_]](using alg: UserLogin[E]): E[Boolean] = {
    import alg._
    mfa_v1(checkLogin(true), mfa_v2(checkLogin(true), checkLogin(false)))
  }

  def checkLastStatus[E[_]](using alg: UserLogin[E]): E[Int] = {
    import alg._
    totalSessionLogins(countActiveSessions(24), countActiveSessions(3))
  }
}