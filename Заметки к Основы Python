============================================
Форматирование по правилам PEP8
============================================
Для неизменяемых глобальных переменных используется верхний регистр с подчеркиванием. Такой стиль сообщает разработчику, что данная переменная — константа.
#from doctest import IGNORE_EXCEPTION_DETAIL
Для глобальных переменных, которые являются изменяемыми и свободно доступны через импорт, следует применять строчные буквы с подчеркиванием в ситуациях, когда не требуется защита. Если переменная не должна использоваться и модифицироваться за пределами порождающего модуля, то мы считаем ее приватной для него. В этом случае начальное подчеркивание помечает переменную, как приватный элемент пакета:
_observers = []

# Однострочные комментарии начинаются с символа решётки.
Строковые литералы обозначаются __' '__ и __""__. Обратные кавычки запрещены.
Строки могут рассматриваться как массивы символов
Операторы __+__ и __*__ используются для конкатенации и повторения строк.
Оператор __//__ - целочисленное деление, __%__ - остаток от деления, функция __divmod()__ делит первый аргумент на второй и возвращает частное и остаток как кортеж
Обычное деление всегда возвращает float
__==__ - выделенный оператор сравнения "равно" ( "не равно" - __!=__)
В начальной строке определений функции (__def__ ...), ветвления ( __if__, __elif__, __else__) , циклов (__for__ , __while__) и т.д. обязательно последнее двоеточие
Допускается __аннотация типов__ (влияет только на предупреждения на уровне IDE!) :
#def prod(a: int, b: int) -> int: 
Инструкция __pass__ ничего не делает (пустой оператор)
Оператор ввода - __input__
Эквивалент тернарного оператора '?:' в C
#"да!" if 0 > 1 else "нет!"  # => "нет!"
Ключевое слово __is__ проверяет, относятся ли две переменные к одному и тому же объекту, а __==__ проверяет, имеют ли указанные объекты одинаковые значения.
None является объектом
Для сравнения объектов с None используйте оператор __is__
#"etc" is None  # => False
#None is None   # => True
None, 0 и пустые строки/списки/словари/кортежи приводятся к __False.__
Все остальные значения равны __True__
Чтобы переназначить глобальную переменную внутри функции, перед ее использованием вы должны объявить, что эта переменная глобальная (__global__)
Чтобы из вложенной функции обратиться к переменной вышестоящей функции, перед ее использованием вы должны объявить, что эта переменная нелокальная (__nonlocal__)
#been_called = False 
#def example2(): 
#	global been_called 
#	been_called = True
Функция __repr()__ принимает любой объект в качестве аргумента и возвращает строковое представление объекта.

__Генератор списка__ (list com­prehension) - в квадратных скобках:
#def capitalize_all(t): 
#	return [s.capitalize() for s in t]

__Выражения-генераторы__ (generator expressions) похожи на генераторы списков, но с круглыми скобками, а не с квадратными:
#g = (x**2 for x in range(5))
Генераторы эффективны с точки зрения памяти, потому что они загружают только данные необходимые для обработки следующего значения в итерации. Это позволяет им выполнять операции с недопустимо большими диапазонами значений. Генератор не вычисляет значения __сразу__. Он ожидает запрос. Функция __yield()__ получает результат.

В другом варианте оператор __yield()__ становится выражением, а некоторые значения могут быть переданы с помощью метода __send()__. Функция __next()__ в этом случае запускает генератор:
#def gen_by_answer:
#	while True:	
#		answer = (yield) 
#		if answer is not None:
...
Вызов:
#free = psychologist() 
#next(free)
#free.send('I feel bad')

Вы также можете использовать цикл for для перебора значений генератора. Выражения-генераторы часто используют с такими функциями, как __sum(), max() и min()__: 
#sum(x**2 for x in range(5))
Функции __any()__ и __all()__ работают с булевым массивом. __any()__ возвращает True, если __любой__ элемент массива равен True, __all()__ - если __все__ элементы массива равны True

============================================
Декораторы
============================================
Декоратор — это просто любая функция, которая принимает на вход функцию и возвращает ее расширенный вариант. Синтаксис декоратора — это просто синтаксический сахар.
#@some_decorator 
#def decorated_function(): 
#	pass 
Этот вариант всегда можно заменить явным вызовом декоратора и  функции: 
#def decorated_function(): 
#	pass 
#	decorated_function = some_decorator(decorated_function)
Все вызываемые объекты (любой объект, который реализует метод **__call__**, считается вызываемым) могут быть использованы в качестве декоратора.

Может быть реализован как функция:
#def mydecorator(function): 
#	def wrapped(*args, **kwargs):
#	# Действия, выполняемые перед вызовом оригинальной функции 
#	result = function(*args, **kwargs) 
#	# Действия после выполнения функции и результат 
#	return result Возвращает задекорированную функцию 
#return wrapped

 или как класс

Частые случаи применения декораторов
* проверка аргументов; 
* кэширование; 
* прокси; 
* провайдер контекста.

============================================
Списки (массивы) хранят последовательности
============================================
__li = []__
Обращение по индексу, отрицательный индекс - с конца, несуществующий индекс - выбросит ошибку
Есть срезы
__li[начало:конец:шаг]__
Можно  конкатенировать
Проверить элемент на наличие в списке можно оператором in
#1 in li  # => True
Объекты добавляются в конец списка методом __append()__
#li.append(1)
И удаляются с конца методом __pop()__
#li.pop()_
Удаление произвольных элементов из списка оператором del
#del li[2]  # [1, 2, 3]
Удаление первого вхождения значения
#li.remove(2)  # [1, 3]
 Вставка элемента по определенному индексу
#li.insert(1, 2)  # [1, 2, 3]
Получить индекс первого найденного элемента, соответствующего аргументу
#li.index(2)  # => 1


============================================
Строки
============================================
Конкатенация строк через += имеет квадратичную сложность, вместо нее для сложных литералов следует использовать __join__


============================================
Кортежи похожи на списки, только неизменяемые
============================================
#tup = (1, 2, 3)
Те же операции, что и с маccивами
Можно __распаковывать__ кортежи (или списки) в переменные
#a, b, c = (1, 2, 3)  # a == 1, b == 2 и c == 3
Простой swap
#e, d = d, e  # теперь d == 5, а e == 4
Использование кортежа для вывода отсортированных данных ассоциативного массива
#t = [] 
#for key, value in hist.items(): 
#	t.append((value, key)) 
#t.sort(reverse=True) 
#return t

============================================
Словари содержат ассоциативные массивы
============================================
#empty_dict = {}
Вот так описывается предзаполненный словарь
#filled_dict = {"one": 1, "two": 2, "three": 3}
Обратите внимание, что __ключи для словарей должны быть неизменяемыми типами__. Это сделано для того, чтобы ключ может быть преобразован в хеш для быстрого поиска.
Неизменяемые типы включают целые числа, числа с плавающей запятой, строки,кортежи.
Поиск значений с помощью []
#filled_dict["one"]  # => 1
Все ключи в виде списка получаются с помощью метода keys().  Его вызов нужно обернуть в list(), так как обратно мы получаем __итерируемый объект__
#list(filled_dict.keys())  # => ["one", "two", "three"] в Python 3.7+
Все значения в виде списка можно получить с помощью values().
#list(filled_dict.values())  # => [1, 2, 3] в Python 3.7+
При помощи ключевого слова __in__ можно проверять __наличие ключей__ в словаре
#"one" in filled_dict  # => True
Попытка получить значение по несуществующему ключу выбросит ошибку KeyError
#filled_dict["four"]  # Выбрасывает ошибку KeyError
Чтобы избежать этого, используйте метод get()
#filled_dict.get("one")      # => 1
#filled_dict.get("four")     # => None
Метод get поддерживает аргумент по умолчанию, когда значение отсутствует
#filled_dict.get("one", 4)   # => 1
#filled_dict.get("four", 4)  # => 4
Метод setdefault() вставляет пару ключ-значение, только если такого ключа нет
#filled_dict.setdefault("five", 5)  # filled_dict["five"] возвращает 5
#filled_dict.setdefault("five", 6)  # filled_dict["five"] по-прежнему возвращает 5
Добавление элементов в словарь
#filled_dict.update({"four":4})  # => {"one": 1, "two": 2, "three": 3, "four": 4}
#filled_dict["four"] = 4         # Другой способ добавления элементов
Удаляйте ключи из словаря с помощью ключевого слова del
#del filled_dict["one"]  # Удаляет ключ "one" из словаря
В худшем случае сложности для копирования и перебора словаря (O(n)), n  - это максимальный размер, которого словарь когда-либо достигал, а не текущий размер. Иными словами, перебор словаря, когда-то огромного, а затем значительно сокращенного, будет выполняться невероятно долго. В отдельных случаях даже разумнее создать новый объект словаря, который будет гораздо меньше и обрабатываться будет быстрее.

============================================
Множества содержат ... множества 
============================================
#empty_set = set()
Инициализация множества набором значений.
#filled_set = {1, 2, 2, 3, 4}  # => {1, 2, 3, 4}
Как и ключи словаря, элементы множества должны быть неизменяемыми.
__В множествах нет повторяющихся элементов__
Добавление элементов в множество происходит быстро, и так же быстро проверяется наличие элемента.
Операции над множествами - пересечение __&__, объединение __|__, разность __-__.
Кроме того:
Симметричная разница: __^__ - типа XOR (то, что есть только в одном списке)
#{1, 2, 3, 4} ^ {2, 3, 5}  # => {1, 4, 5}
Проверить, является ли множество слева надмножеством множества справа __>=__
#{1, 2} >= {1, 2, 3}  # => False
Проверить, является ли множество слева подмножеством множества справа __<=__
#{1, 2} <= {1, 2, 3}  # => True
Проверить на наличие элемента в множестве: __in__
#2 in filled_set   # => True
#10 in filled_set  # => False
Сделать однослойную глубокую копию
# some_set = filled_set.copy()  # {1, 2, 3, 4, 5}
#filled_set is some_set        # => False
Функция frozenset создает неизменяемое множество
Обратите внимание: использование литералов и генерации множеств требует особой осторожности, так как методика очень похожа на работу со словарями. Кроме того, в Python не предусмотрено литералов для пустого множества, поскольку пустые фигурные скобки {} зарезервированы для пустых литералов словаря.

============================================
Циклы и итераторы
============================================
Циклы for - только  c in
#for animal in ["собака", "кошка", "мышь"]:
__range(нижнее, верхнее, шаг)__ возвращает список чисел от нижнего числа к верхнему, с шагом __шаг__
Чтобы получить и индекс и значение:
#for i, value in enumerate(animals):
Циклы while
#while x < 4:

Python предоставляет фундаментальную абстракцию, которая называется итерируемым объектом (Iterable). Итерируемый объект — это объект, который воспринимается как последовательность.
#filled_dict = {"one": 1, "two": 2, "three": 3}
#our_iterable = filled_dict.keys() 	# => dict_keys(['one', 'two', 'three']). Это объект, реализующий интерфейс Iterable
Мы можем проходить по нему циклом.
#for i in our_iterable:
Но мы не можем обращаться к элементу по индексу.
Итерируемый объект знает, как создавать итератор.
#our_iterator = iter(our_iterable)
Итератор может запоминать состояние при проходе по объекту. Мы получаем следующий объект, вызывая функцию __next()__.
#next(our_iterator)  # => "one"
Возвратив все данные, итератор выбрасывает исключение StopIterator.
Можно проходить по итератору циклом:
#for i in our_iterator:
Вы можете получить сразу все элементы итератора, вызвав на нём функцию __list()__.
#list(our_iterable)  # => Возвращает ["one", "two", "three"]

============================================
Функции
============================================
Оператор __return__ определяет возвращаемое значение функции
Параметры в функцию передаются позиционно (в порядке следования в определении функции) или с указанием имени параметра в любом порядке
Поддерживаются параметры со значениями по умолчанию
Функции с переменным количеством параметров: 
* позиционные ххх(__*args__)
* именованные xxx(__*kwargs__)
Можно смешивать
Возврат нескольких значений (с назначением кортежей)
#def swap(x, y):
#    return y, x  # Возвращает несколько значений в виде кортежа без скобок.
#                 	# (Примечание: скобки исключены, но могут быть включены)
Встроенная функция isinstance() проверяет тип аргумента
#if not isinstance(n, int):
Анонимные функции
#(lambda x: x > 2)(3)                  # => True
#(lambda x, y: x ** 2 + y ** 2)(2, 1)  # => 5
Если вы хотите расширить сигнатуру метода новыми аргументами так, чтобы сохранить обратную совместимость, то должны указать __значения по умолчанию__ для этих аргументов следующим образом:
#def execute(self, query, logger=logging.info): 
#	self._query(query, 'EXECUTE', logger)

============================================
Обработка исключений 
============================================
Блоками __try/except/finally__
#try:
#    # Чтобы выбросить ошибку, используется raise
#    raise IndexError("Это ошибка индекса")
#except IndexError as e:
#    pass                  # pass — это просто отсутствие оператора. Обычно здесь происходит восстановление после ошибки.
#except (TypeError, NameError):
#    pass                  # Несколько исключений можно обработать вместе, если нужно.
#else:                     # Необязательное выражение. Должно следовать за последним блоком except
#    print("Всё хорошо!")  # Выполнится, только если не было никаких исключений
#finally:                  # Выполнить при любых обстоятельствах
#    print("Мы можем очистить ресурсы здесь")
Вместо try/finally чтобы очистить ресурсы, можно использовать оператор __with__
#with open("myfile.txt") as f:
#    for line in f:
#        print(line)

============================================
Работа с файлами
============================================
Открытие файла
#with open("myfile.txt") as f:
#    for line in f:
Запись в файл
#contents = {"aa": 12, "bb": 21}
#with open("myfile1.txt", "w+") as file:
#    file.write(str(contents))        # Записывает строку в файл
#with open("myfile2.txt", "w+") as file:
#   file.write(json.dumps(contents)) # Записывает объект в файл
Чтение из файла
#with open('myfile1.txt', "r+") as file:
#    contents = file.read()           # Читает строку из файла
#print(contents)
#with open('myfile2.txt', "r+") as file:
#    contents = json.load(file)       # Читает объект json из файла
#print(contents)

============================================
Работа с базой данных
============================================
Ограничение модуля __dbm__ в том, что ключи и значения должны быть строками или байтами.
#import dbm 
Открытие
#db = dbm.open('captions', 'c')
Режим __'с'__ означает, что база данных должна быть создана, если она еще не существует. Результатом будет объект базы данных, который можно использовать (для большинства операций) как словарь.
Вставка
#db['cleese.png'] = 'Фотография Ивана Клизина.'
Чтение
#db['cleese.png']
Результатом будет байтовый объект (bytes object).
Закрытие
#db.close()

============================================
Сериализация и десериализация
============================================
#import pickle
Функция __pickle.dumps()__ принимает объект в качестве параметра и возвращает строковое представление
Функция __pickle.loads()__ восстанавливает объект

============================================
Поверхностное м глубокое копирование
============================================
#import copy
Операция __copy__ называется __поверхностным копированием (shallow copy)__, потому что она копирует объект и любые содержащиеся в нем ссылки, но не вложенные объекты.
Операция __deepcopy__ называется __глубоким копированием (deep copy)__, потому что она копирует не только объект, но и объекты, на которые он ссылается, любой степени вложенности.

============================================
ООП
============================================
Используем оператор __class__ для создания класса
#class Human:
Конструктор - **__init__**. self - ссылка на экземпляр объекта
#def __init__(self, name):
__ВНИМАНИЕ !__ Значения по умолчанию для конструктора вычисляются __один раз__, поэтому если инициализировать таким образом ссылочные переменные (массивы и.т.д) каждый экземпляр будет ссылаться на одну и ту же переменную.

Присваивание значения аргумента атрибуту
#self.name = name
Инициализация свойства
#self._age = 0
Метод экземпляра. Все методы принимают __self__ в качестве первого аргумента
#def say(self, msg):
#    return "{name}: {message}".format(name=self.name, message=msg)
Для каждого оператора в Python есть возможность добавить в класс соответствующий оператору __переопределенный метод__, например:
**__str__** — это переопределенный метод, который должен возвращать строковое представление объекта.
#def __str__(self):
Встроенная функция __isinstance()__ принимает значение и объект класса и возвращает True, если значение является экземпляром класса.
Если вы не уверены, имеет ли объект определенный атрибут, вы можете использовать встроенную функцию __hasattr__
Другой способ доступа к атрибутам — встроенная функция __vars()__. Она принимает объект и возвращает словарь, который сопоставляет имена атрибутов (в виде строк) с их значениями
Встроенная функция __getattr()__ принимает объект и имя атрибута (в виде строки) и возвращает значение атрибута