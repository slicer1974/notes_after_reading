Пример категории — Set, объекты категории — разные множества, морфизмы — отображения между этими множествами.
Другой пример — категория типов с плавающей точкой, объекты — {Float, Double}, морфизмы — все возможные функции вида Float -> Double и Double -> Float между ними.

Для любой категории существует двойственная категория с теми же объектами, но с противоположными направлениями морфизмов.

Ковариантный функтор F : C → D  из категории C в категорию D — это отображение, которое:
    	сопоставляет каждому объекту X ∈ C  объект F ( X ) ∈ D ,
    	сопоставляет каждому морфизму f : X → Y в категории C  морфизм F ( f ) : F ( X ) → F ( Y ) в категории D. 
Это сопоставление должно обладать следующими свойствами:
        F ( i d A ) = i d F ( A ) ,
        F ( g ∘ f ) = F ( g ) ∘ F ( f ) 
Таким образом, функтор должен сохранять тождественные морфизмы и структуру композиции морфизмов. 

Аналогичным образом, контравариантный функтор — это отображение, обращающее стрелки (то есть сопоставляющее морфизму f : X → Y  морфизм F ( f ) : F ( Y ) → F ( X ) , сохраняющее тождественные морфизмы и удовлетворяющее равенству:
    	F ( g ∘ f ) = F ( f ) ∘ F ( g ) .
Также контравариантный функтор можно определить как ковариантный функтор из двойственной категории C o p.
 (прим. В контравариантном функторе обязательно присутствуют морфизмы с обращенными стрелками, например:
ковариантный функтор:
	fmap :: (c -> c`) -> (c -> LimD) -> (c’ -> LimD)
	fmap f u =  f . u 
тогда как контравариантный функтор:
	contramap :: (c’ -> c) -> (c -> LimD) -> (c’ -> LimD) 
	contramap f u = u . f 
Инверсия в порядке следования с и c` характеризует контравариантный функтор)

Можно думать об объектах и категориях как о существительных, а о морфизмах, функторах и естественных преобразованиях как о глаголах. Морфизмами соединяются объекты, функторы связывают категории, естественные преобразования связывают функторы.

Представляемое на одном уровне как действие становится на следующем уровне объектом. Множество морфизмов превращается в функциональный объект.

Множество морфизмов от объекта а к объекту b в категории С называется hom-множеством и записывается как С(а,b)

Функторы можно рассматривать как объекты в категории функторов. Их морфизмы - естественные преобразования, которые представляют собой особый тип полиморфных функций.
Функтор отображает объекты на объекты, поэтому мы можем использовать его в качестве конструктора типа или параметрического типа. Функтор также отображает морфизмы, так что, к примеру, fmap - это функция высшего порядка.

Начальный объект - объект, от которого к любому объекта категории исходит ровно один морфизм

Терминальный объект - объект, к которому от любого объекта категории приходит ровно один морфизм

Произведение - универсальная категория.

Проекция - морфизм, действующий из множества-произведения в соответствующее множество-множитель.
Произведение объектов А и В - это такой оснащенный двумя ПРОЕКЦИЯМИ объект С, что для любого оснащенного ПРОЕКЦИЯМИ объекта С` существует единственный морфизм М от С` к С, факторизующий эти ПРОЕКЦИИ.  В категории множеств, например, произведение это конъюнктивное объединение ( конъюнктивное объединение А и В это А и В). В программировании простейшее произведение типов это пара (tuple) : (a,b)

Вложение - морфизм, действующий из множества-множителя во множество-произведение.
Копроизведение объектов А и В - это такой оснащенный двумя ВЛОЖЕНИЯМИ объект	С, что для любого оснащенного ВЛОЖЕНИЯМИ объекта С` существует единственный морфизм М от С` к С, факторизующий эти ВЛОЖЕНИЯ. В категории множеств, например, копроизведение это дизъюнктивное объединение ( дизъюнктивное объединение А и В это либо А, либо В). В программировании простейшее копроизведение типов это помеченное  объединение:  Either a b = Left a | Right b

В соответствии с изоморфизмом Карри-Говарда, каждый тип может быть интерпретирован как суждение, которе может быть истинным или ложным. Тип Void  и тип Unit () соответствуют логическим константам: ложь и истина. Типы произведения и суммы соответствуют логической конъюнкции(и) и дизъюнкции (или). Функциональный тип соответствует логической импликации (если... то...). Соответственно суждение считается истинным, если тип населен и ложным, если это не так. В частности, логическая импликация является истинной, если тип соответствующей функции населен, а это значит, что существует функция этого типа. Реализация функции, следовательно, является доказательством теоремы.

Количество функций между конечными типами - наглядное объяснение ЭКСПОНЕНЦИАЛА. Такие функции в принципе могут быть полностью превращены в структуры данных. Например, множество всех возможных функций от Bool к Int есть множество пар Int, то есть Int х Int, то есть Int^2. Поэтому множество функций от Bool к Int выражается как (кол-во Int) в степени (кол-во Bool).

Функциональный объект от a к b это объект a->b вместе с морфизмом eval :: ((a => b) х a) -> b. Эта функция принимает пар,у, состоящую из функции и ее аргумента, и выдает результат соответствующего типа.

В Haskell полиморфная функция должна быть определена единообразно для всех типов. Одна формула должна работать для всех типов. Это  называется параметрическим полиморфизмом.

КОНУС - преобразование, вершинами которого являются отраженные через функторы объекты, а вертикальными ребрами являются компоненты естественного преобразования функторов этих объектов - конус является определением произведения.
Универсальный конус является терминальным объектом в категории конусов. Его также называют пределом. Интуитивно, предел воплощает в себе свойства всей диаграммы в одном объекте. Предел двухобъектной диаграммы, например, является произведением двух объектов.
Терминальный объект является пределом, основанным на пустой категории.
Начальный объект является копределом, основанным на пустой категории.

hom-функтор С(а,b) есть пример непрерывного функтора. Он является контравариантным по первой переменной и ковариантным - по второй. В Haskell hom-функтор является отображением любых двух типов на функуциональный тип. 
Когда мы фиксируем второй параметр, скажем, задавая String, мы получаем контравариантный функтор:
newtype ToString a = ToString (a -> String) 
instance Contravariant ToString where 
	contramap f (ToString g) = ToString (g . f)
Когда мы фиксируем первый параметр, скажем, задавая String, мы получаем ковариантный функтор:
newtype FromString a = FromString (String -> a) 
instance Functor FromString where 
	map f (FromString g) = FromString (f . g)
(прим. то есть при фиксации второго параметра - результата, при композиции функций мы должны вызвать функцию приведения к типу последней, а при фиксации первого параметра мы должны вызвать функцию приведения первой)

Забывающий функтор - теоретико-категорный функтор, который "забывает" некоторые или все алгебраические структуры и свойства исходной области, то есть переводит области, наделённые дополнительными структурами и свойствами, в кообласти с меньшими ограничениями.

