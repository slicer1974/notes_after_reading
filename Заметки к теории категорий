__Категория__ состоит из объектов и морфизмов между ними. 
Должна существовать композиция этих морфизмов, обладающая следующими свойствами:
1.  должна быть ассоциативна
2.  должен быть единичный морфизм (от объекта к самому себе) который служит единицей композиции. 
Для морфизма f: A->B  А является доменом (областью), а В - кодоменом (кообластью). 

Объекты категории не имеют структуры, а только отношения к другим объектам (и к самим себе) посредством морфизмов.

Категория называется __малой__, если все ее объекты и морфизмы составляют малые множества.

Примеры категорий: 
					Set (категория множеств): объекты — разные множества, морфизмы — функции,
					Cat (категория малых категорий): объекты — малые категории, морфизмы  — функторы.
					Категория стрелок: объекты - стрелки, стрелки - коммутативные квадраты с участие стрелок
					Hask: объекты - типы, морфизмы - функции

Категория Hask является категорией CPO, категорией __полных частично упорядоченных множеств__.

Для любой категории существует двойственная категория с теми же объектами, но с противоположными направлениями морфизмов.

Морфизмы по своей природе ассиметричны.

__Гомоморфизм__ - морфизм, сохраняющий основные отношения категории и ее основные операции (Например, для моноида гомоморфизм должен отображать единицу в единицу, а произведение элементов - в произведение отображений этих элементов):
h (a * b) = h a * h b, где h - гомоморфизм

Пусть C — произвольная категория. 
Морфизм f : A -> B в C называется __мономорфизмом__, если для любых g, h : Z -> A из f.g = f.h следует g = h. 
Морфизм f : A -> B в C называется __эпиморфизмом__, если для любых i, j : B -> D из i.f = j.f следует i = j. 
Морфизм f : A -> B в C называется __изоморфизмом__, если существует g : B -> A такая, что g.f = 1А (__левый обратный__) и f.g  = 1В (__правый обратный__). 

Другими словами изоморфизм - это __обратимый морфизм__.  Любой изоморфизм является мономорфизмом и эпиморфизмом. Обратное неверно.

Морфизм, у которого есть левый обратный, называется __расщепимым мономорфизмом__; морфизм, у которого есть правый обратный, называется __расщепимым эпиморфизмом.__
Если f : A -> B и g : B -> A таковы, что fg = 1B , то морфизм g называется __сечением__ морфизма f, а морфизм f называется __ретракцией__ морфизма g; при этом объект B называется ретракцией объекта A. 
Очевидно, что любой функтор сохраняет расщепимые мономорфизмы и расщепимые эпиморфизмы (но не обязан сохранять мономорфизмы и эпиморфизмы).

В конкретных категориях морфизм, имеющий левый обратный является __инъективным__(отображающим __отдельные__ элементы домена на __отдельные__ элементы кодомена).
Условие инъекции сильнее, чем условие мономорфизма, но слабее, чем условие расщепленного мономорфизма.

В конкретных категориях морфизм, имеющий правый обратный является __сюръективным__ (для __каждого__ элемента кодомена __есть__ соответствующий ему элемент домена).
Условие сюръекции сильнее, чем условие эпиморфизма, но слабее, чем условие расщепленного эпиморфизма.

Множество морфизмов от объекта а к объекту b в категории С называется __hom-множеством__ и записывается как С(а,b). Другими словами hom-множество - отображение морфизмов между объектами в некоторой категории на объекты категории Set.
Любая категория, в которой морфизмы образуют множество, изоморфна категории, объекты которой  - множества, а морфизмы  - отображения между ними.

Объект __0__ в категории C называется __инициальным__, если для любого объекта C в C существует единственный морфизм 0 -> С. 
( в Haskell  - Void : : Void -> a )
Объект __1__ в категории C называется __терминальным__, если для любого объекта C в C существует единственный морфизм C -> 1. 
( в Haskell - Unit  :: a -> ()  )

Начальный и терминальный объекты в категории __единственны__ с точностью до изоморфизма.

Морфизмы __из__ терминального объекта любой категории 1 -> A называются __точками__ (или глобальными элементами) объекта А (напр. для множеств каждая такая стрелка соответствует элементу множества А).  Морфизм X -> A называется обобщенным элементом A, или X-точкой A.

__Катаморфизм__ – это функция, которая ставит в соответствие объекту категории с начальным объектом стрелки, которые начинаются из начального объекта, а заканчиваются в данном объекте.  ( другими словами   - __свертка__. Функция свёртки строит функции, которые ведут из рекурсивного типа в произвольный тип, поэтому в данном случае рекурсивный тип будет начальным объектом.)
__Анаморфизм__ – это перевёрнутый наизнанку катаморфизм (другими словами - __развертка__. Функция развёртки строит из произвольного типа данный рекурсивный тип: на языке теории категорий она строит стрелку из произвольного объекта в рекурсивный, а это означает, что рекурсивный тип будет конечным объектом.)
Категории, которые определяют рекурсивные типы таким образом, называются __(ко)алгебрами функторов.__
В теории категорий типы являются начальными и конечными объектами в алгебрах функторов. Катаморфизм и анаморфизм отображают объекты в стрелки. Определив тип, мы получаем вместе с ним две функции структурной рекурсии, это катаморфизм (для начальных объектов) и анаморфизм (для конечных объектов). С помощью катаморфизма мы можем сворачивать значение данного типа в значения любого другого типа, а с помощью анаморфизма мы можем разворачивать значения данного типа из значений любого другого типа. 

Категория над объектом С/А - ...

__Проекция__ - морфизм, действующий из множества-произведения в соответствующее множество-множитель. (В Haskell это fst и snd)
__Произведение__ объектов А и В - это такой оснащенный двумя проекциями к А и В объект С, что для любого другого оснащенного __проекциями__ А и В объекта С' существует единственный морфизм М от C' к C, факторизующий эти проекции. (Грубо говоря, отсутствие факторизирующего морфизма позволяет считать объект С наилучшим кандидитом в произведение А и В).
Hom(C, AxB) = Hom(C,A) x Hom(C,B)
В категории множеств, например, произведение это конъюнктивное объединение (конъюнктивное объединение А и В это А и В). 
В программировании простейшее произведение типов это пара (tuple) : (a,b)

__Вложение__ - морфизм, действующий из множества-множителя во множество-произведение.
__Копроизведение__ объектов А и В - это такой оснащенный двумя вложениями объект С, что для любого оснащенного __вложениями__ объекта AvB существует единственный морфизм М от AvB к С, факторизующий эти ВЛОЖЕНИЯ. 
В категории множеств, например, копроизведение это дизъюнктивное объединение ( дизъюнктивное объединение А и В это либо А, либо В). 
В программировании простейшее копроизведение типов это помеченное  объединение:  Either a b = Left a | Right b

Произведение в категории типов индуцирует произведение типов, копроизведение порождает сумму типов.

----------------------------------------
В теории категорий __моноид ( M , μ , η )__ в моноидальной категории ( C , ⊗ , I )  — это объект M вместе с двумя морфизмами:
μ : M ⊗ M (называемый умножением),
и
η : I → M (называемый единицей),
Морфизмы должны быть ассоциативными и замкнутыми (не выходить за пределы категории).  В моноиде можно компоновать __любые__ два морфизма.
Для любой категории C, категория [C,C] эндофункторов (функторов в себя) [C,C] имеет моноидальную структуру, индуцированную операцией композиции. Моноид в категории эндофункторов [C,C] — это монада в C.

__Свободным моноидом__ (англ. free monoid) M над множеством S (обозначается как MS) называется моноид над множеством S∗ — набором всевозможных последовательностей (или списков) конечной длины (в том числе и нулевой), образованных из элементов множества S — с ассоциативной операцией конкатенации ++ этих последовательностей.

Свободный моноид не имеет никакой структуры, кроме того, что он генерируется законами единицы и ассоциативности. Свободные моноиды, вместо выполнения моноидальной операции, накапливают аргументы, которые были переданы ей. Преимущество этой схемы  в том, что нам не надо указывать, какую моноидальную операцию использовать. В самом конце мы можем применить любую моноидальную операцию (умножение, сложение, конкатенацию...). Свободный моноид отделяет создание выражения от его обработки. Пример свободных моноидов в Haskell - списки.

----------------------------------------
__Функтор__ - отображение объектов и морфизмов в из одной категории в другую.
Функтор "встраивает" одну категорию в другую. Одним из способов представить это является то, что с помощью функтора мы моделируем __одну категорию внутри другой__.
_Функтор должен сохранять структуру начальной категории_: объекты должны отображаться в объекты, морфизмы должны отображаться в соответственные морфизмы, композиции морфизмов - аналогично, единичный морфизм - аналогично. Можно склеивать, но нельзя разрывать.

__Ковариантный__ функтор F : C → D  из категории C в категорию D — это отображение, которое:
    	сопоставляет каждому объекту X ∈ C  объект F ( X ) ∈ D ,
    	сопоставляет каждому морфизму f : X → Y в категории C  морфизм F ( f ) : F ( X ) → F ( Y ) в категории D. 
Это сопоставление должно обладать следующими свойствами:
        F ( i d A ) = i d F ( A ) ,
        F ( g ∘ f ) = F ( g ) ∘ F ( f ) 
Таким образом, __функтор должен сохранять тождественные морфизмы и структуру композиции морфизмов__. 

Аналогичным образом, __контравариантный__ функтор — это отображение, обращающее стрелки (то есть сопоставляющее морфизму f : X → Y  морфизм F ( f ) : F ( Y ) → F ( X ) , сохраняющее тождественные морфизмы и удовлетворяющее равенству:
    	F ( g ∘ f ) = F ( f ) ∘ F ( g ) .
Также контравариантный функтор можно определить как ковариантный функтор из двойственной категории C op.
 (прим. В контравариантном функторе обязательно присутствуют морфизмы с обращенными стрелками, например:
ковариантный функтор:
	fmap :: (c -> c`) -> (c -> LimD) -> (c’ -> LimD)
	fmap f u =  f . u 
тогда как контравариантный функтор:
	contramap :: (c’ -> c) -> (c -> LimD) -> (c’ -> LimD) 
	contramap f u = u . f 
Инверсия в порядке следования с и c` характеризует контравариантный функтор)

__Эндофунктор__  - функтор из категории в нее же (как бы "вкладывает" категорию внутрь нее же). 

__Бифунктор__ - функтор двух аргументов. Важным примером бифунктора является категорное произведение - произведение двух объектов, определяемое универсальной конструкцией. Если произведение существует для любой пары объектов, отображение этих объектов к их произведению бифунктериально.

__Функториальность__ - свойство отображения соответствовать всем законам функторов.
 Сумма и произведение типов функториальны. Параметризированные АТД функториальны соответственно.
 
__Забывающий__ функтор - теоретико-категорный функтор, который "забывает" некоторые или все алгебраические структуры и свойства исходной области, то есть переводит области, наделённые дополнительными структурами и свойствами, в кообласти с меньшими ограничениями.

__Функциональный объект__ от a к b это 
		объект a=>b (где a=>b - универсально лучший объект из множества функций типа z)
		вместе с морфизмом eval :: ((a => b) , a) -> b  такие, что 
		для любого другого объекта z c морфизмом 
		g :: z Х a -> b, 	(где Х - декартово произведение объектов z и а, которое характеризует ВСЕ функции типа z с аргументами типа а)
		существует единственный морфизм
		h :: z -> (a =>b)
		который факторизует g через eval
В частности, в Set, g является функцией от пар значений, одно из множества z, а другое из множества а.

Для категории Set h :: z -> (a =>b) просто обозначает, что  h является функцией, которая принимает одну переменную типа z и возвращает функцию от a к b, т.е функцией высшего порядка. Поскольку если исключить bottom, категория Hask точно соответствует категории Set, то таким образом мы выводим каррирование в Haskell. 

Функциональный объект, или внутренний hom-объект между двумя объектами а и в, часто называют __экспоненциалом__.
 
В КАТЕГОРИИ ТИПОВ:
Функциональный тип - отображение типа а на тип функций, возвращающих а. 
Эта функция принимает пару, состоящую из функции и ее аргумента, и выдает результат соответствующего типа.
В Haskell мы интерпретируем функциональный тип a->b как категорный функциональный объект a=>b.

__Представимый функтор__ - функтор к hom-множеству.
Пусть C — локально малая категория, A (- C.
Функтор вида Hom(A, -) : C -> Sets называется (ковариантным) представимым функтором (и A — его представляющим объектом). Hom(A,-) отображает каждый объект X категории C во множество морфизмов Hom(A, X).
Функтор вида Hom(-, A) : C -> Sets называется (контравариантным) представимым функтором (и A — его представляющим объектом).
Также можно определить бифунктор Hom(-,-) из C × C в Set, контравариантный по первому аргументу и ковариантный по второму.

Из условия изоморфности функторов (наличие обратимого естественного преобразования между ними) можно вывести условие представимости функторов:
1. Должен существовать объект а в С
2. Должно существовать __одно__ естественное преобразование А от С( а , _ )  к F
3. Должно существовать __одно__ естественное  преобразование В от F к С( а , _ ) 
4. Композиция этих естественных преобразований должна быть тождественным естественным преобразованием

В Haskell мы можем думать о представимых функторах как о контейнерах для хранения результатов вызова функций (члены hom-множеств в Haskell это просто функции). Представляющий объект - тип а в С( а , _ ) мыслится как тип ключа, с помощью которого мы можем получить доступ к табличным значениям функции.
На основе этого механизма основана __мемоизация__

__Каждая__ категория оснащена каноническим семейством отображения к категории Set (категория множеств). Эти отображения фактически являются функторами, поскольку они сохраняют структуру категорий. Такие функторы называются __hom-функторами__. 
Любой другой функтор F получается из hom-функтора посредством преобразования с забыванием.

__Лемма Йонеды__ говорит, что все функторы,ведущие в Set, могут быть получены из hom-функторов через естественные преобразования и явно перечисляет все такие преобразования.

__Лемма. Между естественными преобразованиями от hom-функторов объекта А к функтору F и значениями функтора F в А существует взаимно однозначное соответствие:__
#	Nat(h_A, F) ~ F(A)

Вообще в любой категории, состоящей из алгебраических структур на основе множества, элементы этого множества можно совершенно спокойно «забыть», а затем восстановить «внутрекатегорными методами» при помощи леммы Йонеды.
Лемма Йонеды это достаточно простое соображение о том, что математический объект полностью (с точностью до изоморфизма) определяется тем, как он взаимодействует с другими объектами. Ну, неудивительно: с точки зрения теории категорий у объекта нет никакой внутренней структуры, поэтому он восстанавливается, если мы знаем, какие морфизмы в него (или из него) действуют.

Пример:
Возьмем в качестве функтора F список,  в качестве конструктора типов будет list, а fmap - это простой List.map. Возьмем в качестве объекта А тип int, тогда F(A) - список интов. Передадим список интов [3; 2; 1] в нашу функцию-изоморфизм yoneda и получим  естественное преобразование, которое для любого типа 'b из Hom(int, 'b), т.е. функций int -> 'b, сделает список значений типа 'b, т.е. F('b). Применим его для парочки типов string и float, передав функции string_of_int и float_of_int, получим автоматически список строк и список флоатов. Внутри она просто помнит список интов, полученный при рождении, и применяет к нему поэлементно переданную функцию. Это потому что в качестве функтора F мы выбрали список, а его fmap - это List.map, поэлементное преобразование. Сдругим функтором она бы делала что-то другое, но код не меняется, он сводится к использованию fmap функтора. 

Частный случай:
Если взять в Nat(h_A, F) в качестве F hom-функтор h_C тогда получим, для любого типа b : 
	Nat(Hom(a,b), Hom(c,b)) ~ Hom(c,a) 	то есть
	(a->b) -> (c->b) ~ (c->a)
что приводит нас к 
	 (c->a) ~ (a->b) -> (c->b).
То есть если у нас есть функция (c->a) то для любого типа b,  если a используется для получения значения типа b, можно соорудить функцию с->b как последовательное применение функций с->a и a->b - __continuation passing transform.__

В HASKELL:
В Haskell hom-функтор является отображением любых двух типов на функциональный тип. 
Когда мы фиксируем __первый__ параметр, скажем, задавая String, мы получаем ковариантный функтор:
newtype FromString a = FromString (String -> a) 
instance Functor FromString where 
	map f (FromString g) = FromString (f . g)
Когда мы фиксируем второй параметр, скажем, задавая String, мы получаем контравариантный функтор:
newtype ToString a = ToString (a -> String) 
instance Contravariant ToString where 
	contramap f (ToString g) = ToString (g . f)
(прим. то есть при фиксации типа второго параметра - результата, при композиции функций мы должны вызвать функцию приведения к типу последней, а при фиксации типа первого параметра мы должны вызвать функцию приведения первой)

Члены hom-множеств в Haskell это просто функции. hom-функтор в Haskell это функтор Reader:
type Reader a x = a -> x 
instance Functor (Reader a) where 
	fmap f h = f . h 
Представляемое на одном уровне как действие становится на следующем уровне объектом. Множество морфизмов превращается в функциональный объект.

----------------------------------------
Пусть C, D — категории, F, G : C -> D — функторы между ними. __Естественным преобразованием__ α : F -> G из функтора F в функтора G называется задание для каждого объекта S (- C морфизма αS : F(S) -> G(S) в категории D таким образом, что диаграмма  коммутативна для любого морфизма f : S -> S` в категории C. Морфизмы αS называются __компонентами__s естественного преобразования α. Иногда встречается специальное обозначение α : F => G для естественного преобразования.
__Естественное преобразование__ это функция принимающая функтор и возвращающая другой функтор. 
__Естественное преобразование это семейство морфизмов__.
Можно думать об объектах и категориях как о существительных, а о морфизмах, функторах и естественных преобразованиях как о глаголах. Морфизмами соединяются объекты, функторы связывают категории, естественные преобразования связывают функторы.

Можно сказать, что естественное преобразование отображает морфизмы в __коммутативные квадраты__. 

В КАТЕГОРИИ ТИПОВ:
Конструктор типов представляет собой n-арный ти́повый оператор (англ. type operator, оператор над типами), принимающий на входе ноль или более типов, и возвращающий другой тип.
В качестве аргумента конструктора типов используется переменная типа. 
Типы, параметризованные одним и более аргументами, называются полиморфными; типы без аргументов — мономорфными. 
Функтор - конструктор типа или параметрического типа. Сконструированный тип отображает объекты типа аргумента, fmap - морфизмы.
Эндофунктор в категории типов - это тип, параметризированный другим типом (Maybe, списки итд) . Любой такой тип - кандидат в функторы.
Если взять функциональный тип a->b,  (->)a можно считать конструктором типа, а b - его параметром. Комбинацию конструктора типов (->)r и fmap = (.) называют функтором Reader. 
Функторы можно рассматривать как объекты в категории функторов. Их морфизмы - естественные преобразования, которые представляют собой особый тип полиморфных функций.
Один из вариантов понимания функтора - считать их обобщенными контейнерами.  Тогда, следуя этой аналогии, действие функтора изменяет содержимое контейнера без изменения его формы, в то время как естественное преобразование переупаковывает нетронутое содержимое в другой контейнер. В принципе, все полиморфные функции, вроде head и tail для списков, fst и snd для туплов, - это естественные преобразования. Они работают с формой структуры данных, не трогая ее наполнение, не зная конкретного его типа, т.е. превращают один функтор в другой.
Естественное преобразование от или к функтору Const выглядит точно  так же, как и функция,  полиморфная по одному из аргументов (например length :: [a] ->Int можно рассматривать, как length :: [a] -> Const  Int a ). 
Естественный изоморфизм - это изоморфизм, который является естественным преобразованием, каждая компонента которого обратима, - это способ формулировки в теории категорий того, что "две вещи одинаковы".

В том же духе, мы можем думать о представимых функторах, как о контейнерах для хранения результатов вызова функций. 
Параметрически полиморфная функция между двумя функторами это всегда естественное преобразование.

В соответствии с изоморфизмом Карри-Говарда, каждый тип может быть интерпретирован как суждение, которе может быть истинным или ложным. Тип Void  и тип Unit () соответствуют логическим константам: ложь и истина. Типы произведения и суммы соответствуют логической конъюнкции(и) и дизъюнкции (или). Функциональный тип соответствует логической импликации (если... то...). Соответственно суждение считается истинным, если тип населен и ложным, если это не так. В частности, логическая импликация является истинной, если тип соответствующей функции населен, а это значит, что существует функция этого типа. Реализация функции, следовательно, является доказательством теоремы.

Количество функций между конечными типами - наглядное объяснение __экспоненциала__. Такие функции в принципе могут быть полностью превращены в структуры данных. Например, множество всех возможных функций от Bool к Int есть множество пар Int, то есть Int х Int, то есть Int^2. Поэтому множество функций от Bool к Int выражается как (кол-во Int) в степени (кол-во Bool).
Экспоненциал - это представление функционального типа в АТД.

В Haskell полиморфная функция должна быть определена единообразно для всех типов. Одна формула должна работать для всех типов. Это называется __параметрическим полиморфизмом__.

__Два функтора изоморфны и могут рассматриваться как идентичные, если существует обратимое естественное преобразование между ними.__

-------------------------------
Категории C и D называются __эквивалентными__, если существуют функторы F : C -> D и G : D -> C и естественные изоморфизмы α : G.F => idC , β : F.G => idD. При этом говорят, что функтор F (и функтор G) является эквивалентностью категорий.

Пусть C, D — категории, и F : C ->D, G : D -> C — функторы между ними. Говорят, что функторы G и F __сопряжены__, если для любых объектов X (- C, Y (- D существует биекция HomC (X, G(Y)) -> HomD (F(X), Y), естественная по X и по Y. При этом функтор F называется __левым__ сопряженным к функтору G, а G— __правым__ сопряженным к F. 
Обозначение: F |- G.

__Сопряжение__ двух категорий предусматривает существование одностроннего естественного перехода от тождественного функтора к композиции встречных функторов (которая является эндофунктором для одной из категорий) между этими категориями. Эти переходы называются __единицей__ и __коединицей__ сопряжения.
__Единица сопряжения и коединица сопряжения  являются естественными преобразованиями, то есть семействами морфизмов__. Единица позволяет вводить эндофунктор там, куда бы мы могли вставить тождественный функтор. Коединица позволяет исключить эндофунктор, заменив его тождественным функтором.
nu :: I D -> R o L 		- единица сопряжения 
epsilon :: L o R -> I C	- коединица сопряжения
Асимметрия определений важна. L - левый сопряженный к функтору R , а R соответственно правый сопряженный к функтору L. Копозиции RoL и LoR являются эндофункторами в соответствующих категориях. 
Очевидные условия согласованности сопряженных функторов называются тождествами треугольника:
L = L o ID -> L o R o L -> IC o L = L 
R = ID o R -> R o L o R -> R o IC = R

Единица известна в Hаskell как return (или pure, в определении Аpplicative) :
	return :: d -> m d, где m - эндофунктор, соответствующий R o L 
коединица  - как extract:
	extract :: w c -> c.
Они являются частью определения монады и комонады соответственно.

join и return являются полиморфными функциями, поэтому мы можем догадаться, что они соответствуют  естественным преобразованиям.
Операторы категории Клейсли можно сопоставить с fmap следующим образом: fmap f = id >=> (\x -> return (f x))

Возьмем произвольную категорию С с объектами а и b. Соответствующая категория Клейсли имеет те же объекты, что и С, но ее морфизмы другие. Морфизм между двумя объектами а и b в категории Клейсли реализуется как морфизм 
	a -> mb
в исходной категории С. 
Стрелки (морфизмы) Клейсли образуют категорию __только в том случае__, если мы можем определить для них правильную композицию. Если есть композиция, которая ассоциативна и имеет тождественную стрелку для каждого объекта, то функтор m называется __монадой__, а результрующая категория называется категорией Клейсли.

Определение. __Монадой__ в категории K называется тройка (𝑇,𝜂,𝜇) из функтора и двух естественных преобразований, где
𝑇 : K →K
𝜂: 𝐼𝑑K →𝑇 то есть 𝜂𝐴 : 𝐴 →𝑇(𝐴)
𝜇: 𝑇 ∘𝑇 →𝑇 то есть 𝜇𝐴 : 𝑇(𝑇(𝐴)) →𝑇(𝐴)
(здесь 𝐴 – любой объект K), 

Композиции стрелок Клейсли позволяют работать с монадами, не раскрывая внутреннего содержимого.
Программа на Haskell - по сути  большая стрелка Клейсли в монаде IO. Из монады IO нет возможности получить значение (нет runIO)!
Главная жалоба на монады - их трудно компоновать друг с другом (есть много трансформеров монад, но нет универсального способа компоновки произвольных монад).

__Моноидальная категория__ - это категория С, снабженная:
бифунктором (функтором от двух аргументов), который называется тензорным произведением:
__⌦__ :: C х C -> C
особым объектом __I_ , называемым __единичным__ или __тождественным__ объектом,
тремя естественными изморфизмами, выражающими тот факт, что операция тензорного произведения :
- ассоцивативна
						alpha a b c :: (a ⌦ b) ⌦ c -> a ⌦ (b ⌦ c) 
- I является единицей	
						lambda a :: I ⌦ a -> a 
						ro a :: a ⌦ I-> a

Поскольку эндофункторы всегда компонуемы, они образуют строгую моноидальную категорию с композицией функторов как тензорным произведением.
Моноид в этой категории - это объект эндофунктор Т и два морфизма:
- mu :: Т о Т -> T и
- nu :: I -> T.
Поэтому монада - это моноид в моноидальной категории эндофункторов.

__Конус__ - отражение между двумя категориями. Образуется двумя функторами: первый обычный, отражает объекты и морфизмы первой категории на вторую; второй - постоянный, отражает любые объекты и их морфизмы из первой категории на один объект, а все морфизмы - в тождественный морфизм того объекта. __Универсальный конус__ - конус, к вершине которого существует единственный факторизующий морфизм от любого другого конуса. Конус хорошо определяет __произведение__ объектов.
__Категория конусов__: конусы - объекты, факторизующие морфизмы - морфизмы, универсальный конус - терминальный объект. Универсальный конус называют __пределом__ и обозначают __Lim__. В качестве условного термина называют пределом (или предельным объектом) вершину этого конуса.
Функтор D от I к C имеет предел LimD тогда и только тогда, когда существует естественный изоморфизм между двумя функторами:
__C(c, LimD) ~ N at( c , D)__

Интуитивно, предел воплощает в себе свойства всей диаграммы в одном объекте. Предел двухобъектной диаграммы, например, является произведением двух объектов.
Терминальный объект является пределом, основанным на пустой категории.
Начальный объект является копределом, основанным на пустой категории.