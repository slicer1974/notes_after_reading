КАТЕГОРИЯ состоит из объектов, морфизмов между ними и композицией этих морфизмов. 
Композиция морфизмов :
1) должна быть ассоциативна
2) должен быть единичный морфизм (от объекта к самому себе) который служит единицей композиции. 
Для морфизма f: A->B  А является доменом (областью), а В - кодоменом (кообластью). 

Объекты категории не имеют структуры, а только отношения к другим объектам (и к самим себе) посредством морфизмов.

Категория называется малой, если все ее объекты и стрелки составляют малые множества.

Примеры категорий:  Set (категория множеств): объекты — разные множества, морфизмы — функции,
					Cat (категория малых категорий): объекты — малые категории, морфизмы  — функторы.
					Категория стрелок: объекты - стрелки, стрелки - коммутативные квадраты с участие стрелок
					Hask: объекты - типы, стрелки - функции

Категория Hask является категорией CPO, категорией полных частично упорядоченных множеств.

Множество морфизмов от объекта а к объекту b в категории С называется hom-множеством и записывается как С(а,b). Другими словами hom-множество - отображение морфизмов между объектами в некоторой категории на объекты категории Set.

Любая категория, в которой морфизмы образуют множество, изоморфна категории, объекты которой  - множества, а морфизмы  - отображения между ними.

Для любой категории существует двойственная категория с теми же объектами, но с противоположными направлениями морфизмов.

Морфизмы по своей природе ассиметричны.

Гомоморфизм - отображение, сохраняющее основные отношения и основные операции.

Пусть C — произвольная категория. 
Морфизм f : A -> B в C называется мономорфизмом, если для любых g, h : Z -> A из f.g = f.h следует g = h. 
Морфизм f : A -> B в C называется эпиморфизмом, если для любых i, j : B -> D из i.f = j.f следует i = j. 
Морфизм f : A -> B в C называется изоморфизмом, если существует g : B -> A такая, что g.f = 1А (левый обратный) и f.g  = 1В (правый обратный). 

Любой изоморфизм является мономорфизмом и эпиморфизмом.

Морфизм, у которого есть левый обратный, называется расщепимым мономорфизмом; морфизм, у которого есть правый обратный, называется расщепимым эпиморфизмом.
Если f : A -> B и g : B -> A таковы, что fg = 1B , то морфизм g называется сечением морфизма f, а морфизм f называется ретракцией морфизма g; при этом объект B называется ретракцией объекта A. 
Очевидно, что любой функтор сохраняет расщепимые мономорфизмы и расщепимые эпиморфизмы (но не обязан сохранять мономорфизмы и эпиморфизмы).

В конкретных категориях морфизм, имеющий левый обратный является инъективным (отображающим отдельные элементы домена на отдельные элементы кодомена).
Условие инъекции сильнее, чем условие мономорфизма, но слабее, чем условие расщепленного мономорфизма.

В конкретных категориях морфизм, имеющий правый обратный является сюръективным (для каждого элемента кодомена есть соответствующий ему элемент домена).
Условие сюръекции сильнее, чем условие эпиморфизма, но слабее, чем условие расщепленного эпиморфизма.

Объект 0 в категории C называется инициальным, если для любого объекта C в C существует единственный морфизм 0 -> С. 
( в Haskell  - Void : : Void -> a )
Объект 1 в категории C называется терминальным, если для любого объекта C в C существует единственный морфизм C -> 1. 
( в Haskell - Unit  :: a -> ()  )

Начальный и терминальный объекты в категории единственны с точностью до изоморфизма.

Морфизмы ИЗ терминального объекта любой категории 1 -> A называются ТОЧКАМИ (или глобальными элементами) объекта А (напр. для множеств каждая такая стрелка соответствует элементу множества А).  Морфизм X -> A называется обобщенным элементом A, или X-точкой A.

Катаморфизм – это функция, которая ставит в соответствие объектам категории с начальным объектом стрелки, которые начинаются из начального объекта, а заканчиваются в данном объекте. Анаморфизм – это перевёрнутый наизнанку катаморфизм.

В теории категорий типы являются начальными и конечными объектами в специальных категориях, которые называются алгебрами функторов. Слоган теории категорий гласит:
Управляющие структуры определяются структурой типов. Определив тип, мы получаем вместе с ним две функции структурной рекурсии, это катаморфизм (для начальных объектов) и анаморфизм (для конечных объектов). С помощью катаморфизма мы можем сворачивать значение данного типа в значения любого другого типа, а с помощью анаморфизма мы можем разворачивать значения данного типа из значений любого другого типа. 

Категория над объектом С/А - ...

Проекция - морфизм, действующий из множества-произведения в соответствующее множество-множитель. (В Haskell это fst и snd)
Произведение объектов А и В - это такой оснащенный двумя ПРОЕКЦИЯМИ к А и В объект С, что для любого другого оснащенного ПРОЕКЦИЯМИ к А и В объекта С` существует единственный морфизм М от C` к C, факторизующий эти ПРОЕКЦИИ. (Грубо говоря, отсутствие факторизирующего морфизма позволяет считать объект С наилучшим кандидитом в произведение А и В).
Hom(C, AxB) = Hom(C,A) x Hom(C,B)
В категории множеств, например, произведение это конъюнктивное объединение (конъюнктивное объединение А и В это А и В). В программировании простейшее произведение типов это пара (tuple) : (a,b)

Вложение - морфизм, действующий из множества-множителя во множество-произведение.
Копроизведение объектов А и В - это такой оснащенный двумя ВЛОЖЕНИЯМИ объект	С, что для любого оснащенного ВЛОЖЕНИЯМИ объекта AvB существует единственный морфизм М от AvB к С, факторизующий эти ВЛОЖЕНИЯ. В категории множеств, например, копроизведение это дизъюнктивное объединение ( дизъюнктивное объединение А и В это либо А, либо В). 
В программировании простейшее копроизведение типов это помеченное  объединение:  Either a b = Left a | Right b

Произведение в категории типов индуцирует произведение типов, копроизведение порождает сумму типов.

МОНОИД - множество с бинарной операцией.  От этой операции требуется ассоциативность и наличие единичного элемента.  В моноиде определено произведение любых двух элементов. С точки зрения категории, если для любых двух морфизмов определена композиция — это то же самое, что «категория состоит из одного объекта». Т.о каждый моноид может быть описан, как категория с одним объектом и множеством морфизмов (если расценивать бинарную функцию как m->(m->m) то есть принимающую объект и возвращающую функцию) (например в Sets: объект 1 и морфизмы (+1), (+2) и т.д., с помощью которых можно получить все остальные элементы моноида).   Т.о моноид это категория из объекта m и Hom-множества M(m,m) с бинарной операцией  - композицией морфизмов из M.

Свободным моноидом (англ. free monoid) M над множеством S (обозначается как MS) называется моноид над множеством S∗ — набором всевозможных последовательностей (или списков) конечной длины (в том числе и нулевой), образованных из элементов множества S — с ассоциативной операцией конкатенации ++ этих последовательностей.

ФУНКТОР - отображение объектов и морфизмов в из одной категории в другую.
Функтор "встраивает" одну категорию в другую. Одним из способов представить это является то, что с помощью функтора мы моделируем ОДНУ КАТЕГОРИЮ ВНУТРИ ДРУГОЙ.
ФУНКТОР ДОЛЖЕН СОХРАНЯТЬ СТРУКТУРУ начальной категории: объекты должны отображаться в объекты, морфизмы должны отображаться в соответственные морфизмы, композиции морфизмов - аналогично, единичный морфизм - аналогично. Можно склеивать, но нельзя разрывать.

Ковариантный функтор F : C → D  из категории C в категорию D — это отображение, которое:
    	сопоставляет каждому объекту X ∈ C  объект F ( X ) ∈ D ,
    	сопоставляет каждому морфизму f : X → Y в категории C  морфизм F ( f ) : F ( X ) → F ( Y ) в категории D. 
Это сопоставление должно обладать следующими свойствами:
        F ( i d A ) = i d F ( A ) ,
        F ( g ∘ f ) = F ( g ) ∘ F ( f ) 
Таким образом, функтор должен сохранять тождественные морфизмы и структуру композиции морфизмов. 

Аналогичным образом, контравариантный функтор — это отображение, обращающее стрелки (то есть сопоставляющее морфизму f : X → Y  морфизм F ( f ) : F ( Y ) → F ( X ) , сохраняющее тождественные морфизмы и удовлетворяющее равенству:
    	F ( g ∘ f ) = F ( f ) ∘ F ( g ) .
Также контравариантный функтор можно определить как ковариантный функтор из двойственной категории C op.
 (прим. В контравариантном функторе обязательно присутствуют морфизмы с обращенными стрелками, например:
ковариантный функтор:
	fmap :: (c -> c`) -> (c -> LimD) -> (c’ -> LimD)
	fmap f u =  f . u 
тогда как контравариантный функтор:
	contramap :: (c’ -> c) -> (c -> LimD) -> (c’ -> LimD) 
	contramap f u = u . f 
Инверсия в порядке следования с и c` характеризует контравариантный функтор)

Эндофунктор  - функтор из категории в нее же (как бы "вкладывает" категорию внутрь нее же). 

Бифунктор - функтор двух аргументов. Важным примером бифунктора является категорное произведение - произведение двух объектов, определяемое универсальной конструкцией. Если произведение существует для любой пары объектов, отображение этих объектов к их произведению бифунктериально.

Функториальность - свойство отображения соответствовать всем законам функторов.
 
Сумма и произведение типов функториальны. Параметризированные АТД функториальны соответственно.
 
Забывающий функтор - теоретико-категорный функтор, который "забывает" некоторые или все алгебраические структуры и свойства исходной области, то есть переводит области, наделённые дополнительными структурами и свойствами, в кообласти с меньшими ограничениями.

Функциональный объект от a к b это объект a=>b 	(где a=>b - универсально лучший объект из множества функций типа z)
	вместе с морфизмом eval :: ((a => b) , a) -> b  такие, что 
	для любого другого объекта z c морфизмом 
	g :: z Х a -> b, 	(где Х - декартово произведение объектов z и а, которое характеризует ВСЕ функции типа z с аргументами типа а)
	существует единственный морфизм
	h :: z -> (a =>b)
	который факторизует g через eval
В частности, в Set, g является функцией от пар значений, одно из множества z, а другое из множества а.

Для категории Set h :: z -> (a =>b) просто обозначает, что  h является функцией, которая принимает одну переменную типа z и возвращает функцию от a к b, т.е функцией высшего порядка. Поскольку если исключить bottom, категория Hask точно соответствует категории Set, то таким образом мы выводим каррирование в Haskell. 

Функциональный объект, или внутренний hom-объект между двумя объектами а и в, часто называют ЭКСПОНЕНЦИАЛОМ.
 
В КАТЕГОРИИ ТИПОВ:
Функциональный тип - отображение типа а на тип функций, возвращающих а. 
Эта функция принимает пару, состоящую из функции и ее аргумента, и выдает результат соответствующего типа.
В Haskell мы интерпретируем функциональный тип a->b как категорный функциональный объект a=>b.

Представимый функтор - функтор к hom-множеству.
Пусть C — локально малая категория, A (- C.
Функтор вида Hom(A, -) : C -> Sets называется [ковариантным] представимым функтором (и A — его представляющим объектом). Hom(A,-) отображает каждый объект X категории C во множество морфизмов Hom(A, X).
Функтор вида Hom(-, A) : C -> Sets называется [контравариантным] представимым функтором (и A — его представляющим объектом).
Также можно определить бифунктор Hom(-,-) из C × C в Set, контравариантный по первому аргументу и ковариантный по второму.



КАЖДАЯ категория оснащена каноническим семейством отображения к категории Set (категория множеств). Эти отображения фактически являются функторами, поскольку они сохраняют структуру категорий. 
Такие функторы называются hom-функторами. 
Любой другой функтор F получается из hom-функтора посредством преобразования с забыванием.
Лемма Йонеды говорит, что все функторы,ведущие в Set, могут быть получены из hom-функторов через естественные преобразования и явно перечисляет все такие преобразования.
Вообще в любой категории, состоящей из алгебраических структур на основе множества, элементы этого множества можно совершенно спокойно «забыть», а затем восстановить «внутрекатегорными методами» при помощи леммы Йонеды.
Лемма Йонеды это достаточно простое соображение о том, что математический объект полностью (с точностью до изоморфизма) определяется тем, как он взаимодействует с другими объектами. Ну, неудивительно: с точки зрения теории категорий у объекта нет никакой внутренней структуры, поэтому он восстанавливается, если мы знаем, какие морфизмы в него (или из него) действуют.

Пример использования: (Ocaml) 

module M(F : Functor) = struct 
  type 'a natt = { fn : 'b . ('a -> 'b) -> 'b F.t }   
  let yoneda : 'a F.t -> 'a natt = fun a -> { fn = fun f -> F.fmap f a }   
  let adenoy : 'a natt -> 'a F.t = fun t -> t.fn id 
end 
Здесь F - параметр, произвольный функтор (выразимый в ЯП).
'a natt - тип, описывающий множество естественных преобразований между h_A и F, т.е. Nat(h_A, F). Каким образом? Прямо по определению: всякому объекту В исходной категории, т.е. всякому типу 'b, соответствует стрелка между его образами, получаемыми двумя функторами. Образ 'b, т.е. h_A(В), - это множество функций типа ('a -> 'b). F(B) - образ В в функторе F, записывается прямо - 'b F.t. Выражение "для любого типа 'b", то что в хаскеле обозначается "forall b .", в окамле пишется "'b .", но доступна такая конструкция не в любом месте. Она доступна, в частности, в определении структур, и тут мы описали структуру с одним полем по имени fn такого вот полиморфного типа.

let module L = M(struct type 'a t = 'a list let fmap = List.map end) in 
let open L in 
let nt = yoneda [3; 2; 1] in 
let strings = nt.fn string_of_int in 
let floats = nt.fn float_of_int in 
List.iter print_endline strings; 
List.iter (Printf.printf "%f ") floats; 
let back = adenoy nt in 
List.iter (Printf.printf "%d ") back;; 

Возьмем в качестве функтора F список, передадим его параметром в модуль М, где описаны наши типы и функции, сообщив, что в качестве конструктора типов 'a t надо брать 'a list, а fmap - это простой List.map. Возьмем в качестве объекта А тип int, тогда F(A) - список интов. Передадим список интов [3; 2; 1] в нашу функцию-изоморфизм yoneda и получим значение nt типа int natt. Это естественное преобразование, которое для любого типа 'b из Hom(int, 'b), т.е. функций int -> 'b, сделает список значений типа 'b, т.е. F('b). Применим его для парочки типов string и float, передав функции string_of_int и float_of_int, получим автоматически список строк и список флоатов. Внутри она просто помнит список интов, полученный при рождении, и применяет к нему поэлементно переданную функцию. Это потому что в качестве функтора F мы выбрали список, а его fmap - это List.map, поэлементное преобразование. Сдругим функтором она бы делала что-то другое, но код не меняется, он сводится к использованию fmap функтора. Потом передадим это чудо-значение nt в обратный морфизм adenoy и получим back - исходный список интов. Вот и вся Йонеда.


В HASKELL:
В Haskell hom-функтор является отображением любых двух типов на функциональный тип. 
Когда мы фиксируем второй параметр, скажем, задавая String, мы получаем контравариантный функтор:
newtype ToString a = ToString (a -> String) 
instance Contravariant ToString where 
	contramap f (ToString g) = ToString (g . f)
Когда мы фиксируем первый параметр, скажем, задавая String, мы получаем ковариантный функтор:
newtype FromString a = FromString (String -> a) 
instance Functor FromString where 
	map f (FromString g) = FromString (f . g)
(прим. то есть при фиксации второго параметра - результата, при композиции функций мы должны вызвать функцию приведения к типу последней, а при фиксации первого параметра мы должны вызвать функцию приведения первой)

Члены hom-множеств в Haskell это просто функции. hom-функтор в Haskell это функтор Reader:
type Reader a x = a -> x 
instance Functor (Reader a) where 
	fmap f h = f . h 

Представляемое на одном уровне как действие становится на следующем уровне объектом. Множество морфизмов превращается в функциональный объект.

Пусть C, D — категории, F, G : C -> D — функторы между ними. Естественным преобразованием α : F -> G из функтора F в функтора G называется задание для каждого объекта S (- C морфизма αS : F(S) -> G(S) в категории D таким образом, что диаграмма  коммутативна для любого морфизма f : S -> S` в категории C. Морфизмы αS называются компонентами естественного преобразования α. Иногда встречается специальное обозначение α : F => G для естественного преобразования.

Естественное преобразование это функция принимающая функтор и возвращающая другой функтор. 

Можно думать об объектах и категориях как о существительных, а о морфизмах, функторах и естественных преобразованиях как о глаголах. Морфизмами соединяются объекты, функторы связывают категории, естественные преобразования связывают функторы.

Можно сказать, что естественное преобразование отображает морфизмы в коммутативные квадраты. 

В КАТЕГОРИИ ТИПОВ:
Конструктор типов представляет собой n-арный ти́повый оператор (англ. type operator, оператор над типами), принимающий на входе ноль или более типов, и возвращающий другой тип.
В качестве аргумента конструктора типов используется переменная типа. 
Типы, параметризованные одним и более аргументами, называются полиморфными; типы без аргументов — мономорфными. 
Функтор - конструктор типа или параметрического типа. Сконструированный тип отображает объекты типа аргумента, fmap - морфизмы.
Эндофунктор в категории типов - это тип, параметризированный другим типом (Maybe, списки итд) . Любой такой тип - кандидат в функторы.
Если взять функциональный тип a->b,  (->)a можно считать конструктором типа, а b - его параметром. Комбинацию конструктора типов (->)r и fmap = (.) называют функтором Reader.   
Функторы можно рассматривать как объекты в категории функторов. Их морфизмы - естественные преобразования, которые представляют собой особый тип полиморфных функций.
Один из вариантов понимания функтора - считать их обобщенными контейнерами.  Тогда, следуя этой аналогии, действие функтора изменяет содержимое контейнера без изменения его формы, в то время как естественное преобразование переупаковывает нетронутое содержимое в другой контейнер. В принципе, все полиморфные функции, вроде head и tail для списков, fst и snd для туплов, - это естественные преобразования. Они работают с формой структуры данных, не трогая ее наполнение, не зная конкретного его типа, т.е. превращают один функтор в другой.
Естественное преобразование от или к функтору Const выглядит точно  так же, как и функция,  полиморфная по одному из аргументов (например length :: [a] ->Int можно рассматривать, как length :: [a] -> Const  Int a ). 
В том же духе, мы можем думать о представимых функторах, как о контейнерах для хранения результатов вызова функций. 
Параметрически полиморфная функция между двумя функторами это всегда естественное преобразование.

В соответствии с изоморфизмом Карри-Говарда, каждый тип может быть интерпретирован как суждение, которе может быть истинным или ложным. Тип Void  и тип Unit () соответствуют логическим константам: ложь и истина. Типы произведения и суммы соответствуют логической конъюнкции(и) и дизъюнкции (или). Функциональный тип соответствует логической импликации (если... то...). Соответственно суждение считается истинным, если тип населен и ложным, если это не так. В частности, логическая импликация является истинной, если тип соответствующей функции населен, а это значит, что существует функция этого типа. Реализация функции, следовательно, является доказательством теоремы.

Количество функций между конечными типами - наглядное объяснение ЭКСПОНЕНЦИАЛА. Такие функции в принципе могут быть полностью превращены в структуры данных. Например, множество всех возможных функций от Bool к Int есть множество пар Int, то есть Int х Int, то есть Int^2. Поэтому множество функций от Bool к Int выражается как (кол-во Int) в степени (кол-во Bool).
Экспоненциал - это представление функционального типа в АТД.

В Haskell полиморфная функция должна быть определена единообразно для всех типов. Одна формула должна работать для всех типов. Это  называется параметрическим полиморфизмом.

КОНУС - преобразование, вершинами которого являются отраженные через функторы объекты, а вертикальными ребрами являются компоненты естественного преобразования функторов этих объектов - конус является определением произведения.
Универсальный конус является терминальным объектом в категории конусов. Его также называют пределом. Интуитивно, предел воплощает в себе свойства всей диаграммы в одном объекте. Предел двухобъектной диаграммы, например, является произведением двух объектов.
Терминальный объект является пределом, основанным на пустой категории.
Начальный объект является копределом, основанным на пустой категории.

Два функтора изоморфны и могут рассматриваться как идентичные, если существует обратимое естественное преобразование между ними. 

Категории C и D называются эквивалентными, если существуют функторы F : C -> D и G : D -> C и естественные изоморфизмы α : G.F => idC , β : F.G => idD. При этом говорят, что функтор F (и функтор G) является эквивалентностью категорий.

Пусть C, D — категории, и F : C ->D, U : D -> C — функторы между ними. Говорят, что функторы U и F сопряжены, если для любых объектов X (- C, Y (- D существует биекция HomC (X, U(Y)) -> HomD (F(X), Y), естественная по X и по Y. При этом функтор F называется левым сопряженным к функтору U, а U — правым сопряженным к F. 
Обозначение: F |- U.

Сопряжение двух категорий предусматривает существование одностроннего естественного перехода от тождественного функтора к композиции встречных функторов (которая является эндофунктором для одной из категорий) между этими категориями. Эти переходы называются единицей и коединицей сопряжения.
Единица сопряжения и коединица сопряжения  - семейства морфизмов. Единица позволяет вводить эндофунктор там, куда бы мы могли вставить тождественный функтор. Коединица позволяет исключить эндофунктор, заменив его тождественным функтором.
nu :: I D -> R o L 		- единица сопряжения 
epsilon :: L o R -> I C	- коединица сопряжения
Асимметрия определений важна. L - левый сопряженный к функтору R , а R соответственно правый сопряженный к функтору L. Копозиции RoL и LoR являются эндофункторами в соответствующих категориях. 
Очевидные условия согласованности сопряженных функторов называются тождествами треугольника:
L = L o ID -> L o R o L -> IC o L = L 
R = ID o R -> R o L o R -> R o IC = R

Единица известна в Hаskell как return (или pure, в определении Аpplicative) :
	return :: d -> m d, где m - эндофунктор, соответствующий R o L 
коединица  - как extract:
	extract :: w c -> c.
Они являются частью определения монады и комонады соответственно.

join и return являются полиморфными функциями, поэтому мы можем догадаться, что они соответствуют  естественным преобразованиям.
Операторы категории Клейсли можно сопоставить с fmap следующим образом: fmap f = id >=> (\x -> return (f x))

Свободный моноид не имеет никакой структуры, кроме того, что он генерируется законами единицы и ассоциативности. Свободные моноиды, вместо выполнения моноидальной операции, накапливают аргументы, которые были переданы ей. Преимущество этой схемы  в том, что нам не надо указывать, какую моноидальную операцию использовать. В самом конце мы можем применить любую моноидальную операцию (умножение, сложение, конкатенацию...). Свободный моноид отделяет создание выражения от его обработки. Пример свободных моноидов в Haskell - списки.

Возьмем произвольную категорию С с объектами а и b. Соответствующая категория Клейсли имеет те же объекты, что и С, но ее морфизмы другие. Морфизм между двумя объектами а и b в категории Клейсли реализуется как морфизм 
	a -> mb
в исходной категории С. Стрелки (морфизмы) Клейсли образуют категорию ТОЛЬКО в том случае, если мы можем определить для них правильную композицию. Если есть композиция, которая ассоциативна и имеет тождественную стрелку для каждого объекта, то функтор m называется МОНАДОЙ, а результрующая категория называется категорией Клейсли.

Композиции стрелок Клейсли позволяют работать с монадами, не раскрывая внутреннего содержимого.
Программа на Haskell - по сути  большая стрелка Клейсли в монаде IO. Из монады IO нет возможности получить значение (нет runIO)!
Главная жалоба на монады - их трудно компоновать друг с другом (есть много трансформеров монад, но нет универсального способа компоновки произвольных монад).

В теории категорий монада определяется как эндофунктор Т, снабженный парой естественных преобразований:
mu :: T2 -> T, где Т2 = Т о Т.
nu :: I -> T,  где I - тождественный функтор

Моноидальная категория - это категория С, снабженная бифунктором, который называется тензорным произведением:
⌦ :: C х C -> C
и особым объектом i , называемым единичным объектом вместе с тремя естественными изморфизмами:
alpha a b c :: (a ⌦ b) ⌦ c -> a ⌦ (b ⌦ c) 
lambda a :: i ⌦ a -> a 
ro a :: a ⌦ i -> a

Поскольку эндофункторы всегда компонуемы, они образуют строгую моноидальную категорию с композицией функторов как тензорным произведением.
Моноид в этой категории - это объект эндофунктор Т и два морфизма:
mu :: Т о Т -> T и
nu :: I -> T.
Поэтому монада - это моноид в моноидальной категории эндофункторов.
