КАТЕГОРИЯ состоит из объектов, морфизмов между ними и композицией этих морфизмов. 
Композиция морфизмов :
1) должна быть ассоциативна
2) должен быть единичный морфизм (от объекта к самому себе) который служит единицей композиции. 
Для морфизма f: A->B А является доменом (областью), а В - кодоменом(кообластью). 

Объекты категории не имеют структуры, а только отношения к другим объектам (и к самим себе) посредством морфизмов.

Примеры категорий:  Set (категория множеств), объекты — разные множества, морфизмы — функции,
					Cat (категория малых категорий), объекты — малые категории, морфизмы  — функторы.

Категория называется малой, если все ее объекты и стрелки составляют малые множества.

Множество морфизмов от объекта а к объекту b в категории С называется hom-множеством и записывается как С(а,b). Другими словами hom-множество - отображение морфизмов между объектами в некоторой категории на объекты категории Set.

Любая категория, в которой морфизмы образуют множество, изоморфна категории, объекты которой  - множества, а морфизмы  - отображения между ними.

 Для любой категории существует двойственная категория с теми же объектами, но с противоположными направлениями морфизмов.

МОНОИД - множество с бинарной операцией.  От этой операции требуется ассоциативность и наличие единичного элемента. Каждый моноид может быть описан, как категория с одним объектом и множеством морфизмов (если расценивать бинарную функцию как m->(m->m) то есть принимающую объект и возвращающую функцию).   

Произведение в категории множеств индуцирует произведение типов, копроизведение порождает сумму типов.

ФУНКТОР - отображение объектов и морфизмов в из одной категории в другую.
Функтор "встраивает" одну категорию в другую. Одним из способов представить это является то, что с помощью функтора мы моделируем ОДНУ КАТЕГОРИЮ ВНУТРИ ДРУГОЙ.
Должна сохраняться структура начальной категории: объекты должны отображаться в объекты, морфизмы должны отображаться в соответственные морфизмы, композиции морфизмов - аналогично, единичный морфизм - аналогично. Можно склеивать, но нельзя разрывать.
Функтор отображает объекты на объекты, поэтому мы можем использовать его в качестве конструктора типа или параметрического типа. Функтор также отображает морфизмы, так что, к примеру, fmap - это функция высшего порядка.

Эндофунктор в категории типов - это тип, параметризированный другим типом (Maybe, списки итд) .
Если взять функциональный тип a->b,  (->)a можно считать конструктором типа, а b - его параметром. Комбинацию конструктора типов (->)r и fmap = (.) называют функтором Reader.   

Бифунктор - функтор двух аргументов. Важным примером бифунктора является категорное произведение - произведение двух объектов, определяемое универсальной конструкцией. Если произведение существует для любой пары объектов, отображение этих объектов к их произведению бифунктериально.
 
Сумма и произведение типов функториальны. Параметризированные АТД функториальны соответственно.
 
Функциональный тип - отображение типа а на тип функций, возвращающих а. Функциональный объект от a к b это объект a->b вместе с морфизмом eval :: ((a -> b) , a) -> b. Эта функция принимает пару, состоящую из функции и ее аргумента, и выдает результат соответствующего типа.

Если исключить bottom, категория Hask точно соответствует категории Set.

Hom-функтор - это морфизм в категории Set.  Члены hom-множеств в Haskell это просто функции. hom-функтор в Haskell это функтор Reader:
type Reader a x = a -> x 
instance Functor (Reader a) where 
	fmap f h = f . h 

Можно думать об объектах и категориях как о существительных, а о морфизмах, функторах и естественных преобразованиях как о глаголах. Морфизмами соединяются объекты, функторы связывают категории, естественные преобразования связывают функторы.

Можно сказать, что естественное преобразование отображает морфизмы в коммутативные квадраты. В Haskell естественное преобразование это функция принимающая функтор и возвращающая другой функтор. Параметрически полиморфная функция между двумя функторами это всегда естественное преобразование.

Функторы можно рассматривать как объекты в категории функторов. Их морфизмы - естественные преобразования, которые представляют собой особый тип полиморфных функций.
Один из вариантов понимания функтора - считать их обобщенными контейнерами.  Тогда, следуя этой аналогии, действие функтора изменяет содержимое контейнера без изменения его формы, в то время как естественное преобразование переупаковывает нетронутое содержимое в другой контейнер. 
В том же духе, мы можем думать о представимых функторах (функторах к hom-множеству), как о контейнерах для хранения результатов вызова функций. 

Начальный объект - объект, от которого к любому объекта категории исходит ровно один морфизм ( в Haskell  - Void : : Void -> a )

Терминальный объект - объект, к которому от любого объекта категории приходит ровно один морфизм ( в Haskell - Unit  :: a -> ()  )

Произведение - универсальная категория.  

Проекция - морфизм, действующий из множества-произведения в соответствующее множество-множитель.
Произведение объектов А и В - это такой оснащенный двумя ПРОЕКЦИЯМИ объект С, что для любого оснащенного ПРОЕКЦИЯМИ объекта С` существует единственный морфизм М от С` к С, факторизующий эти ПРОЕКЦИИ.  В категории множеств, например, произведение это конъюнктивное объединение ( конъюнктивное объединение А и В это А и В). В программировании простейшее произведение типов это пара (tuple) : (a,b)

Вложение - морфизм, действующий из множества-множителя во множество-произведение.
Копроизведение объектов А и В - это такой оснащенный двумя ВЛОЖЕНИЯМИ объект	С, что для любого оснащенного ВЛОЖЕНИЯМИ объекта С` существует единственный морфизм М от С` к С, факторизующий эти ВЛОЖЕНИЯ. В категории множеств, например, копроизведение это дизъюнктивное объединение ( дизъюнктивное объединение А и В это либо А, либо В). В программировании простейшее копроизведение типов это помеченное  объединение:  Either a b = Left a | Right b

В соответствии с изоморфизмом Карри-Говарда, каждый тип может быть интерпретирован как суждение, которе может быть истинным или ложным. Тип Void  и тип Unit () соответствуют логическим константам: ложь и истина. Типы произведения и суммы соответствуют логической конъюнкции(и) и дизъюнкции (или). Функциональный тип соответствует логической импликации (если... то...). Соответственно суждение считается истинным, если тип населен и ложным, если это не так. В частности, логическая импликация является истинной, если тип соответствующей функции населен, а это значит, что существует функция этого типа. Реализация функции, следовательно, является доказательством теоремы.

Количество функций между конечными типами - наглядное объяснение ЭКСПОНЕНЦИАЛА. Такие функции в принципе могут быть полностью превращены в структуры данных. Например, множество всех возможных функций от Bool к Int есть множество пар Int, то есть Int х Int, то есть Int^2. Поэтому множество функций от Bool к Int выражается как (кол-во Int) в степени (кол-во Bool).

В Haskell полиморфная функция должна быть определена единообразно для всех типов. Одна формула должна работать для всех типов. Это  называется параметрическим полиморфизмом.

Ковариантный функтор F : C → D  из категории C в категорию D — это отображение, которое:
    	сопоставляет каждому объекту X ∈ C  объект F ( X ) ∈ D ,
    	сопоставляет каждому морфизму f : X → Y в категории C  морфизм F ( f ) : F ( X ) → F ( Y ) в категории D. 
Это сопоставление должно обладать следующими свойствами:
        F ( i d A ) = i d F ( A ) ,
        F ( g ∘ f ) = F ( g ) ∘ F ( f ) 
Таким образом, функтор должен сохранять тождественные морфизмы и структуру композиции морфизмов. 

Аналогичным образом, контравариантный функтор — это отображение, обращающее стрелки (то есть сопоставляющее морфизму f : X → Y  морфизм F ( f ) : F ( Y ) → F ( X ) , сохраняющее тождественные морфизмы и удовлетворяющее равенству:
    	F ( g ∘ f ) = F ( f ) ∘ F ( g ) .
Также контравариантный функтор можно определить как ковариантный функтор из двойственной категории C o p.
 (прим. В контравариантном функторе обязательно присутствуют морфизмы с обращенными стрелками, например:
ковариантный функтор:
	fmap :: (c -> c`) -> (c -> LimD) -> (c’ -> LimD)
	fmap f u =  f . u 
тогда как контравариантный функтор:
	contramap :: (c’ -> c) -> (c -> LimD) -> (c’ -> LimD) 
	contramap f u = u . f 
Инверсия в порядке следования с и c` характеризует контравариантный функтор)

Представляемое на одном уровне как действие становится на следующем уровне объектом. Множество морфизмов превращается в функциональный объект.

КОНУС - преобразование, вершинами которого являются отраженные через функторы объекты, а вертикальными ребрами являются компоненты естественного преобразования функторов этих объектов - конус является определением произведения.
Универсальный конус является терминальным объектом в категории конусов. Его также называют пределом. Интуитивно, предел воплощает в себе свойства всей диаграммы в одном объекте. Предел двухобъектной диаграммы, например, является произведением двух объектов.
Терминальный объект является пределом, основанным на пустой категории.
Начальный объект является копределом, основанным на пустой категории.

hom-функтор С(а,b) есть пример непрерывного функтора. Он является контравариантным по первой переменной и ковариантным - по второй. В Haskell hom-функтор является отображением любых двух типов на функуциональный тип. 
Когда мы фиксируем второй параметр, скажем, задавая String, мы получаем контравариантный функтор:
newtype ToString a = ToString (a -> String) 
instance Contravariant ToString where 
	contramap f (ToString g) = ToString (g . f)
Когда мы фиксируем первый параметр, скажем, задавая String, мы получаем ковариантный функтор:
newtype FromString a = FromString (String -> a) 
instance Functor FromString where 
	map f (FromString g) = FromString (f . g)
(прим. то есть при фиксации второго параметра - результата, при композиции функций мы должны вызвать функцию приведения к типу последней, а при фиксации первого параметра мы должны вызвать функцию приведения первой)
Два функтора изоморфны и могут рассмариваться как идентичные, если существует обратимое естественное преобразование между ними. 

Забывающий функтор - теоретико-категорный функтор, который "забывает" некоторые или все алгебраические структуры и свойства исходной области, то есть переводит области, наделённые дополнительными структурами и свойствами, в кообласти с меньшими ограничениями.

Сопряжение двух категорий предусматривает существование одностроннего естественного перехода от тождественного функтора к композиции встречных функторов (которая является эндофунктором для одной из категорий) между этими категориями. Эти переходы называются единицей и коединицей сопряжения.
Единица сопряжения и коединица сопряжения  - семейства морфизмов. Единица позволяет вводить эндофунктор там, куда бы мы могли вставить тождественный функтор. Коединица позволяет исключить эндофунктор, заменив его тождественным функтором.

nu::I D -> R o L 		- единица сопряжения 
epsilon :: L o R -> I C	- коединица сопряжения
Асимметрия определений важна. Из-за этой асимметрии L называется левым сопряженным к функтору R , а R соответственно правым сопряженным к функтору L. Копозиции RoL и LoR являются эндофункторами в соответствующих категориях. 

Единица известна в Hаskell как return (или pure, в определении Аpplicative) :
	return :: d -> m d
коединица  - как extract:
	extract :: w c -> c.
Они являются частью определения монады и комонады соответственно.

join и return являются полиморфными функциями, поэтому мы можем догадаться, что они соответствуют  естественным преобразованиям.

Свободный моноид не имеет никакой структуры, кроме того, что он генерируется законами единицы и ассоциативности. Свободные моноиды, вместо выполнения моноидальной операции, накапливают аргументы, которые были переданы ей. Преимущество этой схемы  в том, что нам не надо указывать, какую моноидальную операцию использовать. В самом конце мы можем применить любую моноидальную операцию (умножение, сложение, конкатенацию...). Свободный моноид отделяет создание выражения от его обработки.

Возьмем произвольную категорию С с объектами а и b. Соответствующая категория Клейсли имеет те же объекты, что и С, но ее морфизмы другие. Морфизм между двумя объектами а и b в категории Клейсли реализуется как морфизм 
	a -> mb
в исходной категории С. Стрелки (морфизмы) Клейсли образуют категорию ТОЛЬКО в том случае, если мы можем определить для них правильную композицию. Если есть композиция, которая ассоциативна и имеет тождественную стрелку для каждого объекта, то функтор m называется МОНАДОЙ, а результрующая категория называется категорией Клейсли.

Композиции стрелок Клейсли позволяют работать с монадами, не раскрывая внутреннего содержимого.
Программа на Haskell - по сути  большая стрелка Клейсли в монаде IO. Из монады IO нет возможности получить значение (нет runIO)!
Главная жалоба на монады - их трудно компоновать друг с другом (есть много трансформеров монад, но нет универсального способа компоновки произвольных монад).
