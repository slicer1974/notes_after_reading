Специальные значения:
__null__
__undefined__
В спецификации считается, что null и undefined равны "==" между собой, но эти значения не равны никакому другому значению.
Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям __null/undefined__ участвовать в сравнениях > >= < <= .

__Примитивные типы: строки, числа, булевы значения, null/undefined__. Хранятся  и копируются в виде __значения__.
__Сложные типы: объекты и массивы__. Хранятся и копируются в виде __ссылки__. 

Для __проверки типа__ у примитивных значений используется оператор __typeof__, для объектов - оператор __instanceof__.

__Оператор "=" возвращает значение__. Все операторы возвращают значение. Вызов x = выражение не является исключением. Он записывает выражение в x , а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:

Исключающее ИЛИ ( ^ ) с нулём можно использовать для __округления до целых__:
#alert(12.3 * 14.5 ^ 0); 	// (=178) "12.3 умножить на 14.5 и округлить до целых" 
У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики: 
#alert( 1.1 + 1.2 ^ 0 ); // 2, сложение выполнится раньше округления

Из-за представления внутреннего формата отрицательных чисел равенство __~n == 0__ выполняется только __если n == ‐1__. Проверка на ‐1 пригождается, например, при поиске символа в строке. Вызов str.indexOf("подстрока") возвращает позицию подстроки в str , или ‐1 если не нашёл. 
#var str = "Проверка"; 
#if (~str.indexOf("верка")) { 	// Сочетание "if (~...indexOf)" читается как "если найдено" 
#alert( 'найдено!' );
#}

__Деструктуризация (destructuring assignment)__ – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.
● Деструктуризация позволяет разбивать объект или массив на переменные при присвоении. 
● Синтаксис: 
#let {prop : varName = default, ...} = object 
Здесь двоеточие : задаёт отображение свойства prop в переменную varName , а равенство =default задаёт выражение, которое будет использовано, если значение отсутствует (не указано или undefined ). 
Для массивов имеет значение порядок, поэтому нельзя использовать : , но значение по умолчанию – можно: 
#let [var1 = default, var2, ...rest] = array 
Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки. 
● Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
#let options = { size: {width: 100, height: 200 }, items: ["Пончик", "Пирожное"] }
#let { title="Меню", size: {width, height}, items: [item1, item2] } = options;
Деструктуризации особенно удобны при чтении объектных параметров функций.

Операторы __spread__ и __rest__ имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью __spread__ мы передаем или распространяем __данные массива__ на другие данные, а с помощью __rest__ — получаем все __параметры функции__ и помещаем их в массив (или извлекаем часть параметров).
#function add(a, b){
#    return a + b
#}
#const nums = [5, 6]
#const sum = add(...nums)
#console.log(sum) // 11
В этом примере мы используем __spread__ при вызове функции add с данными массива nums. Значением переменной «a» будет 5, b = 6, sum = 11.

#function add(...rest){
#    return rest.reduce((total, current) => total + current)
#}
#console.log(add(1, 2)) // 3
#console.log(add(1, 2, 3, 4, 5)) // 15
Здесь мы вызываем функцию add с любым количеством аргументов. Add возвращает сумму этих аргументов.

#const [first, ...others] = [1, 2, 3, 4, 5]
#console.log(first) // 1
#console.log(others) // [2, 3, 4, 5]
В этом примере мы используем __rest__ для помещения любого количества параметров, кроме первого, в массив others.

===================================
● __alert__ выводит сообщение. 
● __prompt__ выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или null , если ввод отменён (CANCEL/ Esc ). 
● __confirm__ выводит сообщение и ждёт, пока пользователь нажмёт «OK» или «CANCEL» и возвращает true/false .

Оператор __if (...)__ вычисляет и преобразует выражение в скобках к логическому типу. В логическом контексте: 
● Число 0 , пустая строка "" , null и undefined , а также NaN являются false , 
● Остальные значения – true .

Методы __setInterval(func, delay)__ и __setTimeout(func, delay)__ позволяют запускать func регулярно/один раз через delay миллисекунд. На самом деле, ни setTimeout, ни setInterval не запускают код. Они лишь регистрируют коллбек. Запускает код уже внутреннее API, которое напрямую связано с такой штукой, как eventloop. Это и есть сердце асинхронности и работы всех асинк-функций. Так вот, что в случае с setTimeout, что в случае с setInterval, код из следующего коллбека будет запущен только и только тогда, когда в callstack'e не будет никаких операций.
Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом clearInterval/clearTimeout . В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо setInterval используют рекурсивный setTimeout . Минимальная задержка по стандарту составляет 4 мс . Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки. В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.

===================================
Логические операторы
===================================
JavaScript вычисляет __несколько ИЛИ (||)__ слева направо. Чтобы экономить ресурсы, используется так называемый «короткий цикл вычисления».
При этом оператор ИЛИ возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу.
#alert( 1 || 0 ); 	// 1 
#alert( true || 'неважно что' ); 	// true 
#alert( null || 1 ); 	// 1 
#alert( undefined || 0 ); 	// 0

Если левый аргумент – false , оператор __И (&&)__ возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.
#// Первый аргумент ‐ true, поэтому возвращается второй аргумент 
#alert( 1 && 0 ); 	// 0 
#alert( 1 && 5 ); 	// 5

Приоритет оператора И && больше, чем ИЛИ || , так что он выполняется раньше.

Оператор __НЕ (!)__ 
1. Сначала приводит аргумент к логическому типу true/false . 
2. Затем возвращает противоположное значение.
В частности, двойное НЕ используют для преобразования значений к логическому типу:
#alert( !!"строка" ); 	// true 
#alert( !!null ); 	// false

===================================
Преобразования типов
===================================
Всего есть три преобразования: 
1. Строковое преобразование. 
2. Численное преобразование. 
3. Преобразование к логическому значению.

Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция alert .
Можно также осуществить преобразование явным вызовом String(val). Также для явного преобразования применяется оператор "+" , у которого __один из аргументов строка__. В этом случае он приводит к строке и другой аргумент, например:
#alert( "123" + undefined ); // "123undefined"

Для преобразования к числу в явном виде можно вызвать Number(val) , либо, что короче, поставить перед выражением унарный плюс "+" :
Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений === , !== ).
● Сравнение разных типов (кроме сравнений === , !== ) – значит __численное__ преобразование

Логическое преобразование
Преобразование к true/false происходит в логическом контексте, таком как if(value) , и при применении логических операторов. 
Все значения, которые интуитивно «пусты», становятся false . Их несколько: 0 , пустая строка, null , undefined и NaN . 
Остальное, в том числе и любые объекты – true .
Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value) .
В отличие от многих языков программирования, __"0" в JavaScript является true , как и строка из пробелов__

===================================
Ветвления
===================================
Конструкция __switch__ заменяет собой сразу несколько if .
switch(x) { 
#case 'value1': 	// if (x === 'value1') 
#... 
#[break] 
#case 'value2': 	// if (x === 'value2') 
#... 
#[break] 
#default: 
#... 
#[break] 
#}

===================================
Циклы
===================================
JavaScript поддерживает три вида циклов: 
● while – проверка условия перед каждым выполнением. 
#while (условие) { /
#	// код, тело цикла 
#}
● do..while – проверка условия после каждого выполнения. 
#do { 
#	// тело цикла 
#} while (условие);
● for – проверка условия перед каждым выполнением, а также дополнительные настройки. 
#for (начало; условие; шаг) {
#	// ... тело цикла ... 
#}
Любая часть for может быть пропущена.
● for–in
Инструкция for-in используется для перебора несимвольных ключевых свойств объектов и имеет следующий синтаксис: 
__for (свойство in выражение) инструкция__ 
#for (const propName in window) { 
#document.write(propName); 
#}
● for–of
__for (variable of iterable) {  statement }__
#let iterable = [10, 20, 30];
#for (let value of iterable) {
#  value += 1;
#}

Чтобы организовать бесконечный цикл, используют конструкцию while(true) . При этом он, как и любой другой цикл, может быть прерван директивой __break__. Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву __continue__. Обе этих директивы поддерживают «метки», которые ставятся перед циклом. Метки – единственный способ для break/continue повлиять на выполнение внешнего цикла. Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.

===================================
Функции
===================================
Объявление (__Function Declaration__):
#function showMessage() { 
#var message = 'Привет, я ‐ Вася!'; 	// локальная переменная 
#alert( message ); 
#}

Параметры передаются __по значению__, то есть копируются в локальные переменные функции

Функцию можно вызвать с любым количеством аргументов. Если параметр не передан при вызове – он считается равным undefined .
При объявлении функции необязательные аргументы, как правило, располагают в конце списка. Для указания значения «по умолчанию», то есть, такого, которое используется, если аргумент не указан, используется два способа: 
1. Можно проверить, равен ли аргумент undefined , и если да – то записать в него значение по умолчанию. 
2. Использовать оператор || : 
#function showMessage(from, text) { 
#text = text || 'текст не передан'; 
#...
# }

Для возврата значения используется директива __return__ . Директива return может также использоваться без значения, чтобы немедленно прекратить выполнение и выйти из функции. В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула __undefined__.

Функции являются объектами первого класса.

Один из уникальных аспектов JavaScript заключается в том, что функции на самом деле являются экземплярами типа Function, то есть объектами. Соответственно, у функций есть методы, которые можно использовать для расширения их поведения.

Функции могут объявлятся через функциональные выражения __Function Expression__ :
#var f = function(параметры) { 
#// тело функции 
#};
Если функция задана как Function Expression, ей можно дать имя. Оно будет доступно только внутри функции (кроме IE8-). Это имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную.

Основное отличие между ними: функции, созданные __через Function Declaration__, создаются интерпретатором до выполнения кода. Поэтому их можно вызвать до объявления.

Еще один, редкий способ создания функций - функция создаётся вызовом __new Function__(params, code) :
#var sum = new Function('a,b', ' return a+b; '); 
#var result = sum(1, 2); 
#alert( result ); 	// 3
Когда функция вызывается с указанием перед ней new, также известный как вызов конструктора, автоматически выполняются следующие вещи:
●  Создается новенький объект (т.е. конструируется) прямо из воздуха
●  Только что сконструированный объект связывается с [[Прототипом]]
●  Только что сконструированный объект устанавливается как привязка this для этого вызова функции
●  За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с new автоматически вернет только что сконструированный объект.

__Улучшения в функциях ES2015__:
● Можно задавать параметры по умолчанию, а также использовать деструктуризацию для чтения приходящего объекта. 
● Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: 
#function f(arg1, arg2, ...rest) . 
● Тот же оператор spread в вызове функции позволяет передать ей массив как список аргументов (вместо apply ). 
#let numbers = [2, 3, 15];
#let max = Math.max(...numbers); / Этот вызов аналогичен Math.max(2, 3, 15)  
● У функции есть свойство name , оно содержит имя, указанное при объявлении функции, либо, если его нет, то имя свойства или переменную, в которую она записана. Есть и некоторые другие ситуации, в которых интерпретатор подставляет «самое подходящее» имя. 
● __Объявление Function Declaration в блоке {...} видно только в этом блоке.__
● Появились функции-стрелки: 
	● Без фигурных скобок возвращают выражение expr : 
#(args) => expr . 
	● С фигурными скобками требуют явного return . 
	● Не имеют своих this и arguments , при обращении получают их из окружающего контекста. 
	● Не могут быть использованы как конструкторы, с new .

__Привязка к this__
	Существуют два дополнительных метода для функций: __apply() и call()__. Оба эти метода вызывают функцию с определенным значением this, эффективно устанавливая значение объекта this внутри тела функции. 
	Определение привязки this для вызова функции требует поиска непосредственной точки вызова этой функции. Как уже выяснилось, к точке вызова могут быть применены четыре правила, в именно таком порядке приоритета:
● Вызвана с new? Используем только что созданный объект.
● Вызвана с помощью call или apply (или bind)? Используем указанный объект.
● Вызвана с объектом контекста, владеющего вызовом функции? Используем этот объект контекста.
● По умолчанию: undefined в режиме strict mode, в противном случае объект global.
	Остерегайтесь случайного/неумышленного вызова с применением правила привязки по умолчанию. В случаях, когда вам нужно "безопасно" игнорировать привязку this, "DMZ"-объект, подобный ø = Object.create(null), — хорошая замена, защищающая объект global от непредусмотренных побочных эффектов.
	Вместо четырех стандартных правил привязки __стрелочные__ функции ES6 используют лексическую область видимости для привязки this, что означает, что они заимствуют привязку this (какой бы она ни была) от вызова своей окружающей функции. Они по существу являются синтаксической заменой self = this в до-ES6 коде.
	ECMAScript 5 определяет дополнительный метод функции, называемый __bind()__. Метод bind() создает новый экземпляр функции, значение this которого связано со значением, переданным в bind(). 

__Функциональное программирование__
Метод bind может быть использован для реализации частичного применения функции : 
#function mypartfunc = myfunction.bind(null,"первый аргумент")
Можно реализовать высшую функцию композиции: 
#const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

__Требования для хвостовой рекурсии (если поддерживает движок)__:
● код выполняется в строгом режиме; 
● возвращаемым значением внешней функции является вызванная функция хвостового вызова; 
● после возврата функции хвостового вызова дальнейшего выполнения не требуется; 
● функция хвостового вызова не является замыканием, относящимся к переменным в области видимости внешней функции.

===================================
Структуры данных
===================================
Все значения в JavaScript, за исключением null и undefined , содержат набор вспомогательных функций и значений, доступных «через точку». Такие функции называют «методами», а значения – «свойствами».
Обращение к методу всегда идет со скобками, а к свойству – без скобок.

При использовании операторов сравнения:
* Если операнды — числа, выполняется числовое сравнение. 
* Если операнды — строки, сравниваются коды знаков в одинаковых позициях. 
* Если один операнд — число, другой операнд преобразуется в число и выполняется числовое сравнение.
* Если операнд — объект, вызывается метод valueOf() и его результат сравнивается с другим операндом по предыдущим правилам. Если метод valueOf() недоступен, вызывается метод toString() и полученное значение сравнивается по предыдущим правилам. 
* Если операнд — логическое значение, он преобразуется в число и выполняется сравнение.

В ECMAScript определили два набора операций: равенство (equal) и неравенство (not equal), которые преобразуют данные перед сравнением, и строгое равенство (identically equal) и строгое неравенство (not identically equal), которые выполняют сравнение без преобразования.
При преобразовании типов для операторов равенства и неравенства применяются свои правила:
* Если операнд — логическое значение, перед проверкой на равенство оно преобразуется в число. Значение false преобразуется в 0, а true — в 1. 
* Если операнды — строка и число, перед сравнением предпринимается попытка преобразовать строку в число. 
* Если один из операндов — объект, для него вызывается метод valueOf(), чтобы получить примитивное значение, которое затем сравнивается по предыдущим правилам.
Операторы строгих равенства и неравенства делают то же самое, что и обычные операторы равенства и неравенства, но не преобразуют операнды перед сравнением.

========
Числа
========
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное. 
#alert( parseInt('12px') ) 	// 12, ошибка на символе 'p' 
#alert( parseFloat('12.3.4') ) 	// 12.3, ошибка на второй точке

Для проверки строки на число можно использовать функцию isNumeric(str) .

========
Строки
========
Строки в JavaScript имеют внутреннюю кодировку Юникод.
Строки создаются при помощи двойных или одинарных кавычек
Экранирование - обратным слешем \
Для доступа к символу можно использовать квадратные скобки: 
#var str = "Я ‐ современный браузер!"; 
#alert( str[0] ); 	// "Я"
Для поиска подстроки лучше использовать slice:
#alert( "testme".slice(1, ‐1) ); // 	"estm", от 1 позиции до первой с конца.
Сравнение строк работает лексикографически
Числа в виде строк сравниваются как строки

__Улучшения в строках ES2015__:
● Строки-шаблоны – для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования. ● Юникод – улучшена работа с суррогатными парами. 
● Полезные методы для проверок вхождения одной строки в другую.

========
Объекты как ассоциативные массивы
========
Объекты -- это коллекции ключ-значение. 
Объект объявляется через __фигурные скобки__:
#var person = {};
Объект можно заполнить значениями при создании, указав их в фигурных скобках: { ключ1: значение1, ключ2: значение2, ... } . Такой синтаксис называется литеральным (англ. literal).
В качестве значения можно указать другой объект. 
Значения могут быть получены через свойства, посредством синтаксиса .propName или ["propName"]. Вне зависимости от синтаксиса, движок вызывает встроенную стандартную операцию [[Get]] (и [[Put]] для установки значений), которая не только ищет свойство непосредственно в объекте, но и перемещается по цепочке [[Prototype]] , если свойство не найдено.

Как вариант объект можно создать с использованием ключевого слова __new__:
Когда вы добавляете ключевое слово new перед обычным вызовом функции, это превращает вызов функции в "вызов конструктора". На самом деле new как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, а также выполняется код самой функции.
Например:
#function NothingSpecial() {
#  console.log("Don't mind me!");
#}
#var a = new NothingSpecial();
#// "Don't mind me!"
#a; // {}
NothingSpecial — обычная функция, но когда она вызывается с new, то практически в качестве побочного эффекта создает объект, который мы присваиваем a. Этот вызов был вызовом конструктора, но сама по себе функция NothingSpecial не является конструктором.
Иначе говоря, в JavaScript "конструктор" — это любая функция, вызванная с ключевым словом new перед ней.

В JavaScript можно обратиться к любому свойству объекта, даже если его нет. Ошибки не будет. Но если свойство не существует, то вернется специальное значение undefined.
Имя свойства обязано быть строкой.
К свойству можно обратиться через __точку__:
#person.age = 25; 	// запишем ещё одно свойство: с именем 'age' и значением 25
или через __квадратные скобки__:
#person['любимый стиль музыки'] = 'Джаз';
Квадратные скобки это единственный способ обратиться к свойству, имя которого хранится в переменной: 
#var person = {}; 
#person.age = 25; 
#var key = 'age'; 
#alert( person[key] ); 	// выведет person['age']
Для перебора всех свойств из объекта используется цикл по свойствам __for..in__.
#for (key in obj) { 
#/* ... делать что‐то с obj[key] ... */ 
#}
Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).

	У свойств есть определенные характеристики, которыми можно управлять через дескрипторы свойств, такие как writable и configurable. В дополнение, мутабельностью объектов (и их свойств) можно управлять на разных уровнях иммутабельности, используя Object.preventExtensions(..), Object.seal(..), и Object.freeze(..).
	Свойства не обязательно содержат значения -- они могут быть также «свойствами доступа» с геттерами/сеттерами. Они могут быть перечисляемыми или нет, что влияет на их появление в итерациях цикла, например for..in.
	Вы также можете перебирать значения структур данных (массивов, объектов и т.п.) используя синтаксис ES6 __for..of__, который ищет встроенный или самодельный объект __@@iterator__, содержащий метод next() для перебора значений по одному.  По умолчанию у объекта iterator отсутствует.

========
Прототипное наследование
========
Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как __[[Prototype]]__, которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-null значение.
Если стандартная операция __[[Get]]__ не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке [[Prototype]] этого объекта. В конце каждой типичной цепочки [[Prototype]] находится встроенный объект Object.prototype. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта Object.prototype (иными словами, имеют его на вершине своей цепочки [[Prototype]]).
__Для ясности - объект, на который ссылаются [[Prototype]] и prototype не имеют отношения к связям и наследованию. Это просто объект, в котором ищутся ссылки на свойства, не наденные в самом объекте с помощью [[Get]]__.
Cсылка [[Prototype]] указывает движку, что свойство/метод нужно искать в связанном объекте. Если и в этом объекте ничего не находится, то происходит переход по его ссылке [[Prototype]], и так далее. Эта последовательность ссылок между объектами образует то, что называется "цепочкой прототипов".
Примеры создания связанного прототипа:
До ES5 (создаем частичный полифилл):
#if (!Object.create) {
#  Object.create = function (o) {
#    function F() {}
#    F.prototype = o;
#    return new F();
#  };
#}
Object.create(..) была добавлена в ES5:
#var bar = Object.create(foo);
__Object.create(..)__ создает новый объект (bar), связанный с объектом, который мы указали (foo), и это дает нам всю мощь (делегирование) механизма [[Prototype]], но без ненужных сложностей вроде функции new, выступающей в роли классов и вызовов конструктора, сбивающих с толку ссылок .prototype и .constructor, и прочих лишних вещей.
Другими словами, эта строка означает: "создать новый объект bar, связанный с foo.
__Object.create(null)__ создает объект с пустой (или null) ссылкой [[Prototype]], поэтому этот объект не сможет ничего делегировать. Поскольку у такого объекта нет цепочки прототипов, оператору instanceof (рассмотренному ранее) нечего проверять, и он всегда вернет false. Эти специальные объекты с пустым [[Prototype]] часто называют "словарями", поскольку они обычно используются исключительно для хранения данных в свойствах, потому что у них не может быть никаких побочных эффектов от делегируемых свойств/функций цепочки [[Prototype]], и они являются абсолютно плоскими хранилищами данных.
Второй аргумент Object.create(..) указывает свойства, которые будут добавлены в создаваемый объект, объявляя дескриптор каждого нового свойства.
В ES6 добавлена вспомогательная утилита Object.setPrototypeOf(..), которая меняет привязку существующего объекта стандартным и предсказуемым способом без создания промежуточного объекта:
#Object.setPrototypeOf(bar,foo);
Свойство-функция isPrototypeOf(..) отвечает на вопрос: присутствует ли где-либо в цепочке [[Prototype]] объекта a объект Foo.prototype?
#b.isPrototypeOf(c);
Мы можем напрямую получить [[Prototype]] объекта. В ES5 появился стандартный способ сделать это:
#Object.getPrototypeOf(a);

========
Массивы
========
Объявление
Пустой массив: 
#var arr = []; 
Массив fruits с тремя элементами: 
#var fruits = ["Яблоко", "Апельсин", "Слива"];

Общее число элементов, хранимых в массиве, содержится в его свойстве __length__.
В массиве может храниться любое число элементов __любого типа__.
Методы:
__pop__ 		Удаляет последний элемент из массива и возвращает его
__push__ 	Добавляет элемент в конец массива
__shift__ 	Удаляет из массива первый элемент и возвращает его
__unshift__ 	Добавляет элемент в начало массива
Методы push/pop выполняются быстро, а shift/unshift – медленно.

Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством __length__. Так как это объект, то в функцию он передаётся __по ссылке__.
Ещё одно следствие – можно присваивать в массив __любые свойства__.

Для перебора элементов обычно используется цикл. __Не используйте for..in для массивов__ - это медленнее и выведет кроме цифровых и другие своства объекта-массива.
Длина __length__ – не количество элементов массива, а последний индекс + 1 . При уменьшении length массив укорачивается. Самый простой способ очистить массив – это arr.length=0 .
Многомерные массивы - массивы, содержащие в виде значений другие массивы.
Метод __split(s)__ позволяет превратить строку в массив, разбив ее по разделителю s. Вызов split с s='' разобьёт строку по буквам.
Метод __join(str)__ делает в точности противоположное split . Он берет массив и склеивает его в строку, используя str как разделитель.

Для удаления используются методы: из начала – __shift__ , с конца – __pop__ , а из середины – __splice__.

Метод __splice(index[, deleteCount, elem1, ..., elemN])__ умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.
Он удаляет __deleteCount__ элементов, начиная с номера __index__ , а затем вставляет __elem1, ..., elemN__ на их место. Возвращает массив из удалённых элементов.
Отрицательные индексы отсчитываются о конца.

Метод __slice(begin, end)__ копирует участок массива от begin до end , не включая end .
Отрицательные индексы отсчитываются о конца.
Синтаксис метода slice одинаков для строк и для массивов.

Метод __sort()__ сортирует массив на месте. По __умолчанию__ sort сортирует, __преобразуя элементы к строке__.  Для указания своего порядка сортировки в метод __sort(fn)__ нужно передать функцию __fn от двух элементов__, которая умеет сравнивать их.

Метод __reverse()__ меняет порядок элементов в массиве на обратный.

Метод __arr.concat(value1, value2, … valueN)__ создаёт новый массив, в который копируются элементы из arr , а также value1, value2, ... valueN . Если аргумент concat – массив, то concat добавляет элементы из него.

Метод __arr.indexOf(searchElement[, fromIndex])__ возвращает номер элемента searchElement в массиве arr или ‐1 , если его нет. Поиск начинается с номера fromIndex , если он указан. Если нет – с начала массива. Для поиска используется строгое сравнение === .
Метод __arr.lastIndexOf(searchElement[, fromIndex])__ ищет справа-налево: с конца массива или с номера fromIndex , если он указан.

Метод Object.keys(obj) позволяет перебирать свойства в виде массива:
#var user = { name: "Петя", age: 30 } 
#var keys = Object.keys(user); 
#alert( keys ); 	// name, age

Метод __arr.forEach(callback[, thisArg])__ используется для перебора массива. Для каждого элемента массива метод вызывает функцию callback . Этой функции он передаёт три параметра callback(item, i, arr) : 
● item – очередной элемент массива. 
● i – его номер. 
● arr – массив, который перебирается.
#var arr = ["Яблоко", "Апельсин", "Груша"]; 
#arr.forEach(function(item, i, arr) { 
#	alert( i + ": " + item + " (массив:" + arr + ")" ); 
#});
Метод __arr.forEach(..)__ перебирает все значения массива и игнорирует любые значения, возвращаемые функцией обратного вызова. 
Метод __arr.ﬁlter(callback[, thisArg])__ используется для фильтрации массива через функцию callback(item, i, arr).
Метод __arr.map(callback[, thisArg])__ используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
Метод __arr.every(callback[, thisArg])__ возвращает true , если вызов callback вернёт true для __каждого__ элемента arr. 
Метод __arr.some(callback[, thisArg])__ возвращает true , если вызов callback вернёт true для __какого-нибудь__ элемента arr .
Метод __arr.reduce(callback[, initialValue])__ используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата (__свертка__). При отсутствии initialValue в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Но что если вместо __индексов__ массива (или свойств объекта) вы хотите перебрать __значения__ напрямую? ES6 добавляет синтаксис цикла __for..of__ для перебора массивов:
#var myArray = [ 1, 2, 3 ];
#for (var v of myArray) {
#    console.log( v );
#}
#// 1
#// 2
#// 3

========
ДАТА И ВРЕМЯ
========
● Дата и время представлены в JavaScript одним объектом: Date. Создать «только время» при этом нельзя, оно должно быть с датой.
#new Date() 		//Создает объект Date с текущей датой и временем
#new Date(milliseconds) 		//Создает объект Date , значение которого равно количеству миллисекунд, прошедших с 1 января 1970 года GMT+0.
#new Date(year, month, date, hours, minutes, seconds, ms) 	//Используя компоненты в местной временной зоне. Обязательны первые два аргумента. 
#														//Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице.
Метод __Date.now()__ возвращает дату сразу в виде миллисекунд. Технически, он аналогичен вызову __+new Date()__ , но в отличие от него не создаёт промежуточный объект даты, а поэтому – во много раз быстрее.
● Отсчёт месяцев начинается с нуля. 
● Отсчёт дней недели (для getDay() ) тоже начинается с нуля (и это воскресенье). 
● Объект Date удобен тем, что автокорректируется. Благодаря этому легко сдвигать даты.
● Для доступа к компонентам даты-времени объекта Date используются следующие методы: 
__getFullYear()__  	//Получить год (из 4 цифр) 
__getMonth()__ 		//Получить месяц, от 0 до 11. 
__getDate()__ 		//Получить число месяца, от 1 до 31. 
__getDay()__ 			//Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).
__getHours(), getMinutes(), getSeconds(), getMilliseconds()__ 		//Получить соответствующие компоненты.
Все методы, указанные выше, возвращают результат для __местной временной зоны__. Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear() , getUTCMonth() , getUTCDay() . То есть, сразу после "get" вставляется "UTC" .
__getTime()__ 		//Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе new Date(milliseconds) . __getTimezoneOffset()__ 		//Возвращает разницу между местным и UTC-временем, в минутах.
● Следующие методы позволяют устанавливать компоненты даты и времени: 
__setFullYear(year [, month, date])__
__setMonth(month [, date])__
__setDate(date)__
__setHours(hour [, min, sec, ms])__
__setMinutes(min [, sec, ms])__
__setSeconds(sec [, ms])__
__setMilliseconds(ms)__
__setTime(milliseconds)__ 		//(устанавливает всю дату по миллисекундам с 01.01.1970 UTC) 
Все они, кроме setTime() , обладают также UTC-вариантом, например: setUTCHours().
● При преобразовании к числу объект Date даёт количество миллисекунд, прошедших с 1 января 1970 UTC. Побочное следствие – даты можно вычитать, результатом будет разница в миллисекундах. 
● Для получения текущей даты в миллисекундах лучше использовать Date.now() , чтобы не создавать лишний объект Date (кроме IE8-) 
● Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.

===================================
РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ И URI
===================================
Тип __RegExp__ реализует в ECMAScript регулярные выражения, которые можно с легкостью создавать, используя синтаксис, похожий на Perl: 
__let выражение = /шаблон/флаги__

Методы encodeURI() и encodeURIComponent() используются для кодирования универсальных идентификаторов ресурса (Uniform Resource Identifier, URI), передаваемых браузеру. Допустимые URI не могут содержать определенные знаки.
Методы encodeURI() , encodeURIComponent() , decodeURI() и decodeURIComponent() заменяют методы escape() и unescape(), которые признаны устаревшими в третьей редакции ECMA-262. Новые методы предпочтительнее.

===================================
Замыкания, область видимости
===================================
В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» ( global object ).  В браузере этот объект явно доступен под именем __window__. Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.

__Выполнение скрипта__ происходит в две фазы: 
1. На первой фазе происходит инициализация, подготовка к запуску. Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var . Каждое такое объявление добавляется в window . Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined . 
2. На второй фазе – собственно, выполнение. Присваивание ( = ) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они undefined .

В JavaScript нет разницы между объявлением переменной с помощью __var__ вне блока и в блоке. Объявление __let__ ограничено блоком. Поведение let особенно полезно при использовании итераторов внутри циклов.

При создании функция получает скрытое свойство __[[Scope]]__ , которое ссылается на лексическое окружение, в котором она была создана.
При запуске функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]] . Если переменная не найдена в функции – она будет искаться снаружи. Переменную во внешней области видимости можно не только читать, но и изменять. 
При использовании вложенной функции:
#function makeCounter() { 
#	var currentCount = 1; 
#	return function() { 
#		return currentCount++; 
#		}; 
#	}
в ее окружение попадает переменная __currentCount__. При каждом вызове функции __make_counter__ будет возвращаться новая функция со __своим собственным__ начальным значением __currentCount__:
#var counter = makeCounter(); 
#var counter2 = makeCounter(); 
#alert( counter() ); // 1 
#alert( counter() ); // 2 
#alert( counter() ); // 3 
#alert( counter2() ); // 1, счётчики независимы

Замыкание наблюдается тогда, когда функция использует пере­ менную(-ые) из другой(-их) области(-ей) видимости даже при выполнении в области видимости, в которой эта(-и) пере­мен­ ная(‑ые) должна(ы) быть недоступна(-ы). Ключевые части определения: 
* в замыкании должна быть задействована функция; 
* она должна обращаться хотя бы к одной переменной из внешней области видимости; 
* функция должна вызываться из другой ветви цепочки областей видимости относительно той, в которой находи(-я)тся пере­ мен­ная(-ые).

===================================
__JSON__
===================================
Данные в формате JSON (RFC 4627) представляют собой: 
● JavaScript-объекты { ... } или 
● Массивы [ ... ] или 
● Значения одного из типов: 
	● строки в двойных кавычках, 
	● число, 
	● логическое значение true / false , 
	● null . 
Основные методы для работы с JSON в JavaScript – это: 
● __JSON.parse__ – читает объекты из строки в формате JSON. 
● __JSON.stringify__ – превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети 

Для интеллектуального восстановления из строки у __JSON.parse(str, reviver)__ есть второй параметр reviver , который является функцией function(key, value) .

Метод __JSON.stringify(value, replacer, space)__ преобразует («сериализует») значение в JSON-строку. При сериализации объекта вызывается его метод __toJSON__. Если такого метода нет – перечисляются его свойства, кроме функций.
Во втором параметре JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации. Для сложных ситуаций вторым параметром можно передать функцию function(key, value) , которая возвращает сериализованное value либо undefined , если его не нужно включать в результат:
#var str = JSON.stringify(user, function(key, value) { 
#	if (key == 'window') return undefined; 
#	return value; 
#});
Функция replacer работает рекурсивно То есть, если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через replacer .

===================================
__Работа с данными__
===================================
__Запрос Данных По Http__
В JavaScript самый популярный способ сделать HTTP-запрос — использовать функцию __fetch__ (выборку). Например, чтобы запросить у GitHub информацию о пользователе MoonHighway: 
#fetch(`https://api.github.com/users/moonhighway`) 
#.then(response => response.json()) 
#.then(console.log) 
#.catch(console.error);
Второй аргумент функции fetch позволяет передать объект с параметрами, которые fetch может использовать при создании HTTP-запроса:
#fetch("/create/user", { 
#	method: "POST", body: JSON.stringify({ username, password, bio }) 
#});

Другой способ работы с промисами — использовать __async и await__. Поскольку fetch возвращает промис, мы можем ожидать запрос на выборку внутри функции async: 
#async function requestGithubUser(githubLogin) { 
#try { 
#	const response = await fetch( `https://api.github.com/users/${githubLogin}` 
#	); 
#	const userData = await response.json(); 
#	console.log(userData);
#	} catch (error) { 
#		console.error(error); 
#	} 
#}	

__Сохранение данных локально__
Мы можем сохранять данные локально в браузере через Web Storage API с помощью объектов __window.localStorage__ или __window.sessionStorage__. sessionStorage API сохраняет данные только для сеанса пользователя: при закрытии вкладок или перезапуске браузера эти данные удалятся. localStoragt будет хранить данные до тех пор, пока вы их не удалите.

Данные JSON хранятся в хранилище браузера в виде строки. Это подразумевает преобразование объекта в строку JSON перед его сохранением и анализ этой строки в JSON при ее загрузке. Функция для обработки сохранения и загрузки данных JSON в браузер может выглядеть так: const loadJSON = key => key && JSON.parse(localStorage.getItem(key)); const saveJSON = (key, data) => localStorage.setItem(key, JSON.stringify(data));
===================================
__Обработка ошибок__
===================================
В JavaScript для этого предусмотрены: 
● Конструкция try..catch..finally – она позволяет обработать произвольные ошибки в блоке кода. Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего. Кроме того, иногда проверить просто невозможно, например JSON.parse(str) не позволяет «проверить» формат строки перед разбором. В этом случае блок try..catch необходим. 
Полный вид конструкции: 
#try { .. 
#	пробуем выполнить код .. 
#} catch(e) { 
#.. перехватываем исключение ..
#} finally { 
#.. выполняем всегда .. 
#}
● Оператор __throw err__ генерирует свою ошибку, в качестве err рекомендуется использовать объекты, совместимые с встроенным типом Error, содержащие свойства message и name . Кроме того, мы рассмотрели некоторые важные приёмы: 
● Проброс исключения – catch(err) должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные – пробрасывать дальше через throw err . Определить, нужная ли это ошибка, можно, например, по свойству name . 
● Оборачивание исключений – функция, в процессе работы которой возможны различные виды ошибок, может «обернуть их» в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы при необходимости можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования. 
● В __window.onerror__ можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис.






ДОПОЛНИТЕЛЬНО
========
Псевдомассив аргументов "arguments"
========
В JavaScript нет «перегрузки» функций. Может быть только одна функция с именем __имя__ , которая вызывается с любыми аргументами. А уже внутри она может посмотреть, с чем вызвана и по-разному отработать. Как получить значения аргументов, которых нет в списке параметров? 
Доступ к ним осуществляется через «псевдо-массив» __arguments__. Он содержит список аргументов по номерам: arguments[0] , arguments[1] …, а также свойство length . Например, выведем список всех аргументов: 
#function sayHi() { 
#	for (var i = 0; i < arguments.length; i++) { 
#		alert( "Привет, " + arguments[i] ); 
#	} 
#} 
#sayHi("Винни", "Пятачок"); 		// 'Привет, Винни', 'Привет, Пятачок'

__arguments – это не массив__. Это обычный объект, просто ключи числовые и есть length.

Аргументы по умолчанию через || 
Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined . Зачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое «стандартное» значение или, иначе говоря, значение «по умолчанию». Это можно удобно сделать при помощи оператора логическое ИЛИ || .
#function showWarning(width, height, title, contents) { 
#	width = width || 200; 		// если не указана width, то width = 200
#}

Изобразить работу с именованными аргументами в JavaScript можно передавая __объект__, содержащий в свойствах праметры:
#function showWarning(options) { 
#	var contents = options.contents || "Предупреждение";
#}
Вызов:
#showWarning({ 
#	contents: "Вы вызвали функцию" 	// и всё понятно! 
#});

В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с arguments организуют передачу данных через объект, который как правило называют options . Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – options , который содержит всевозможные дополнительные параметры.

========
Тип MAP
========
Недавно добавленный в ECMAScript 6, Map является новым типом коллекций, который вводит истинное поведение пар ключ–значение в язык.
Новый экземпляр типа Map создается с помощью ключевого слова new: 
#const m = new Map(); 
Если необходимо заполнить Map при инициализации, конструктор может принять итеративный объект, ожидая, что тот будет содержать массивы пар ключ–значе- ние. Каждая пара в итерируемом параметре будет вставлена во вновь созданный экземпляр Map в том порядке, в котором она были вызвана: /
/ Инициализация экземпляра Map с вложенными массивами 
#const m1 = new Map([ ["key1", "val1"], ["key2", "val2"], ["key3", "val3"] ]); 
#alert(m1.size); // 3 /
/ Инициализация экземпляра Map с вручную заданным итератором 
#const m2 = new Map({ 
#	[Symbol.iterator]: function*() { 
#		yield ["key1", "val1"]; yield ["key2", "val2"]; yield ["key3", "val3"]; 
#	} 
#}); 
#alert(m2.size); // 3

В отличие от Object, который может использовать только цифры или строки в качестве ключей, Map может использовать любой тип данных JavaScript в качестве ключа.
keys() и values() возвращают итератор, который содержит все ключи или все зна- чения в Map в порядке вставки

Тип Map в целом производительнее Object особенно в объеме хранения пар(+50%) и операциях удаления.

========
Тип SET
========
Недавно добавленный в ECMAScript 6, Set — это новый тип коллекции, который вводит поведение набора в язык. Set во многих отношениях ведет себя как расширенный Map, так как большая часть API и поведения у них является общей. 
Новый Set можно создать при помощи ключевого слова new: 
#const m = new Set();

========
Тип Symbol
========
Тип данных Symbol является новым в ECMAScript 6. Символы — примитивные значения, а экземпляры символов уникальны и неизменны. Цель символа — быть гарантированным уникальным идентификатором для свойств объекта без риска столкновения свойств.
Cимволы предназначены для использования в качестве уникальных токенов, которые можно использовать для обозначения специальных свойств чем-то отличным от строки.
Символы создаются с помощью функции Symbol. Поскольку это собственный примитивный тип, оператор typeof идентифицирует символ как symbol. 
#let sym = Symbol(); 
#console.log(typeof sym); 	// symbol

===================================
ИТЕРАТОРЫ
===================================
Реализация интерфейса Iterable требует от объекта как способности идентифицировать себя как объект, поддерживающей итерации, так и способности создавать объект, реализующий интерфейс Iterator. В ECMAScript это означает, что он должен предоставлять свойство «итератор по умолчанию», снабженное специальным ключом Symbol.iterator. 
Многие встроенные типы реализуют интерфейс Iterable: 
● строки; 
● массивы; 
● Map; 
● наборы; 
● объект arguments; 
● некоторые типы коллекций DOM, такие как NodeList.

Все, что реализует этот протокол, автоматически совместимо с любыми языковыми функциями, которые допускают итерируемость. Эти встроенные языковые конструкции включают в себя: 
● цикл for...of;
● деструктурирование массива;
● оператор распространения;
● Array.from();
● конструирование Set; 
● конструирование Map;
● Promise.all(), ожидающий промисы для перебора;
● Promise.race(), ожидающий промисы для перебора; 
● оператор yield*, используемый в генераторах.

Пример:
// Итерируемый объект 
#let arr = ['foo', 'bar'];
// Итератор 
#let iter = arr[Symbol.iterator]();

Iterator API использует метод next() для продвижения через итерируемый объект. Каждый раз при вызове next() он возвращает объект IteratorResult, содержащий следующее значение в итераторе. Метод next() возвращает объект с двумя свойствами: done, которое является логическим значением, указывающим, можно ли снова вызывать next() для получения большего количества значений, и значением, которое будет содержать следующее значение в итерируемом объекте или undefined, если done равен true:
#class Counter { 
#	constructor(limit) { this.limit = limit; }
#	[Symbol.iterator]() { 
#		let count = 1, limit = this.limit; 
#		return { 
#			next() { 
#				if (count <= limit) { 
#					return { done: false, value: count++ }; 
#				} else { 
#					return { done: true, value: undefined }; 
#				} 
#			} 
#		}; 
#	}
# }

Поскольку каждый итератор также реализует интерфейс Iterable, их можно ис- пользовать везде, где ожидается итерация, например в цикле for...of: 
#let arr = [3, 1, 4]; 
#let iter = arr[Symbol.iterator](); 
#for (let item of arr) { console.log(item); }

Необязательный метод return() позволяет указать поведение, которое будет вы- полняться, только если итератор закрыт преждевременно. «Закрытие» итератора происходит, когда конструкция, выполняющая итерацию, хочет указать итератору, что она не намерена завершать обход до конца.
#return() { 
#	console.log('Exiting early'); 
#	return { done: true };
#}

Итератор — это интерфейс, который может быть реализован любым объектом и позволяет последовательно просматривать значения, которые он создает. Все, что реализует интерфейс Iterable, имеет свойство Symbol.iterator, которое ссылается на итератор по умолчанию. Итератор по умолчанию ведет себя как фабрика итераторов: функция, которая при вызове создает объект, реализующий интерфейс Iterator.

===================================
__ГЕНЕРАТОРЫ__
===================================
Генераторы представляют собой восхитительно гибкую конструкцию, которая дает возможность __приостанавливать и возобновлять выполнение кода__ внутри одного функционального блока. Последствия этой новой способности глубоки; среди прочего, она позволяет определять пользовательские итераторы и реализовывать сопрограммы.
Генераторы принимают форму функции, а сам генератор обозначается звездочкой. Везде, где определение функции является допустимым, определение функции генератора также допустимо: 
1. Объявление функции генератора 
#function* generatorFn() {} 
2. Функциональное выражение генератора 
#let generatorFn = function* () {} 
3. Функция генератора литерала объекта 
#let foo = { * generatorFn() {} } 
4. Функция генератора метода экземпляра класса 
#class Foo { * generatorFn() {} } 
5. Функция генератора статического метода класса 
#class Bar { static * generatorFn() {} }
__ПРИМЕЧАНИЕ Стрелочные функции не могут быть использованы в качестве функций генератора.__
При вызове функции генератора создают объект генератора. Объекты генератора __начинаются в состоянии приостановленного выполнения__. Подобно итераторам, объекты генератора реализуют интерфейс Iterator и, следовательно, имеют метод __next()__, который при вызове говорит генератору начать или возобновить выполнение. 
#function* generatorFn() {} 
#const g = generatorFn(); 
#console.log(g); // generatorFn {<приостановленный>} 
#console.log(g.next); // { done: true, value: undefined }
Свойство __value__ — это возвращаемое значение функции генератора, которое по умолчанию задано как undefined и может быть переопределено через возвращаемое значение функции генератора. 
#function* generatorFn() { return 'foo'; }
Ключевое слово __yield__ ведет себя как промежуточная функция возврата, а полученное значение доступно внутри объекта, возвращаемого методом __next()__. Функция генератора, завершающая работу через ключевое слово yield, будет иметь значение false; функция генератора, завершающаяся через ключевое слово return, будет иметь значение true: 
#function* generatorFn() { 
#	yield 'foo'; 
#	yield 'bar'; 
#	return 'baz'; 
#} 
#let generatorObject = generatorFn(); 
#console.log(generatorObject.next()); // { done: false, value: 'foo' } 
#console.log(generatorObject.next()); // { done: false, value: 'bar' } 
#console.log(generatorObject.next()); // { done: true, value: 'baz' }

Ход выполнения в функции генератора определяется для каждого экземпляра объекта генератора. Вызов next() для одного объекта генератора не влияет на другие.
Ключевое слово __yield__ можно использовать только внутри функции генератора.
__yield*__ перед итератором перебирает указанную итерацию и выводит ее содержимое по одному.
#yield* [1, 2, 3];
yield* наиболее полезен при использовании в рекурсивной операции, где генератор может сам вызывать yield. 
Генераторы отлично подходят для использования в качестве итераторов по умолчанию.
Методы return() и throw() — два метода, которые можно использовать для приведения генератора в закрытое состояние.
Метод return() переведет генератор в закрытое состояние, а значение, переданное в return(), будет значением, переданным в конечный объект итератора.
Метод throw() вставит переданную в него ошибку в объект генератора в точке, в которой он приостановлен. Если ошибка не обработана, генератор закроется. Однако если ошибка обрабатывается внутри функции генератора, то тот не закро- ется и может возобновить выполнение. Обработка ошибок пропустит этот выход.