В Scala каждый __вспомогательный конструктор__ в качестве первого действия __должен вызывать еще один конструктор того же класса__. Иными словами, первой инструкции в каждом вспомогательном конструкторе каждого класса Scala следует иметь вид this(...). Вызываемым должен быть либо первичный конструктор (как в примере с классом Rational), либо другой вспомогательный конструктор, который появляет­ся в тексте программы перед вызывающим его конструктором. Конечный __результат__ применения данного правила заключается в том, что __каждый__ вызов конструктора в Scala __должен в конце концов завершаться вызовом первичного конструктора класса__. Первичный конструктор, таким образом, — __единственная__ точка входа в класс.

Модификаторы доступа в Scala могут дополняться __спецификаторами__. Модифика­ тор вида private[X] или protected[X] означает, что доступ закрыт или защищен вплоть до X, где X определяет некий внешний пакет, класс или объект-одиночку.

#Все четыре формы составления идентификаторов в Scala:

__Буквенно-цифровые идентификаторы__ начинаются с буквы или знака подчерки­ вания, за которыми могут следовать другие буквы, цифры или знаки подчеркива­ ния. Символ $ также считается буквой, но зарезервирован для идентификаторов, создаваемых компилятором Scala. Идентификаторы в пользовательских програм­ мах не должны содержать символы $, несмотря на возможность успешно пройти компиляцию: если это произойдет, то могут возникнуть конфликты имен с теми идентификаторами, которые будут созданы компилятором Scala. __Следует избегать подчеркивания__. Используется __смешанный регистр__.
`Имена полей, параметры методов, имена локальных переменных и имена функций в смешанном регистре должны начинаться с буквы в нижнем регистре`, например: length, flatMap и s. 
`Имена классов, трейтов и констант в смешанном регистре должны начинаться с буквы в верхнем регистре`, 
например: BigInt, List и UnbalancedTreeMap2.

__Идентификатор оператора__ состоит из одного или нескольких символов опе­раторов. Таковыми являются выводимые на печать ASCII-символы, такие как +, :, ?, ~ или #1. Примеры идентификаторов операторов: 
+ ++ ::: <?> :–> 
Компилятор Scala на внутреннем уровне перерабатывает идентификаторы операторов, чтобы превратить их в допустимые Java-идентификаторы со встро­енными символами $ . Например, идентификатор :-> будет представлен как $colon$minus$greater.

__Смешанный идентификатор__ состоит из буквенно-цифрового идентификато­ра, за которым стоят знак подчеркивания и идентификатор оператора. Напри­мер, unary_+, использованный как имя метода, определяет унарный оператор +. А myvar_=, использованный как имя метода, определяет оператор присваивания.

__Литеральный идентификатор__ представляет собой произвольную строку, за­ ключенную в обратные кавычки (`...`). Примеры литеральных идентификаторов выглядят следующим образом: 
`x` `<clinit>` `yield` 
Замысел состоит в том, что между обратными кавычками можно поместить лю­ бую строку, которую среда выполнения станет воспринимать в качестве идентифи­ катора. В результате всегда будет получаться идентификатор Scala. Это сработает даже в том случае, если имя, заключенное в обратные кавычки, является в Scala зарезервированным словом. Обычно такие идентификаторы используются при обращении к статическому методу yield в Java-классе Thread.

###КЛАССЫ###
Базовый класс по умолчанию для классов и трейтов - __AnyRef__

__В классах Scala не могут содержаться статические элементы__. Вместо этого в Scala есть __объекты-одиночки, или синглтоны__. Объект-одиночка имеет __то же имя__, что и соответвующий ему __класс__. Определение объекта-одиночки выглядит так же, как определение класса, за исключением того, что вместо ключевого слова class используется __ключевое слово object__. Пример:
#object ChecksumAccumulator { 
#	private val cache = mutable.Map.empty[String, Int] 
#	def calculate(s: String): Int = 
#		if (cache.contains(s)) cache(s) 
#		else { val acc = new ChecksumAccumulator for (c <- s) acc.add(c.toByte) val cs = acc.checksum() cache += (s -> cs) cs } 
#}
Если объект-одиночка использует __общее с классом имя__, то для класса он называется __объектом-компаньоном__. И класс, и его объект-компаньон нужно определять в одном и том же исходном файле. Класс по отношению к объекту-одиночке называется __классом-компаньоном__. Класс __делится всеми__ своими __правами доступа__ со своим объектом-компаньоном, и наоборот. В частности, объект может обращаться ко всем приватным членам своего класса-компаньона точно так же, как класс может обращаться ко всем при­ватным членам своего объекта-компаньона.

##ТРЕЙТЫ##
__Трейты__в Scala являются фундаментальными повторно используемыми блоками кода. В трейте инкапсулируются определения тех методов и полей, которые затем могут повторно использоваться путем их примешивания в классы. В отличие от наследования классов, в котором каждый класс должен быть наследником только одного суперкласса, __в класс может примешиваться любое количество трейтов__.
#trait Philosophical { 
#	def philosophize() = { println("На меня тратится память, следовательно, я существую!") } 
#}
После того как трейт определен, он может быть __примешан__ в класс с помощью ключевого слова: __либо extends, либо with__.
Если нужно примешать трейт в класс, который явно расширяет суперкласс, то ключевое слово extends используется для указания суперкласса, а для примеши­ вания трейта — ключевое слово with. Если нужно примешать сразу __несколько трейтов__, то дополнительные трейты указываются с помощью ключевого слова with.
#class Frog extends Animal with Philosophical with HasLegs { override def toString = "зеленая" }

В трейтах можно объявлять поля и сохранять состояние. Фактически в определении трейта можно делать то же самое, что и в определении класса, и син­ таксис выглядит почти так же, но с двумя исключениями. Начнем с того, что в трейте не может быть никаких присущих классу параме­ тров (то есть параметров, передаваемых первичному конструктору класса). Иными словами, хотя у вас есть возможность определить класс таким вот образом: 
#class Point(x: Int, y: Int) 
следующая попытка определить трейт окажется неудачной: 
#trait NoPoint(x: Int, y: Int) // Не пройдет компиляцию 
Второе отличие классов от трейтов заключается в том, что в классах вызовы super имеют статическую привязку, а в трейтах — динамическую. Если в __классе__ воспользоваться кодом super.toString, то вы будете точно знать, какая именно реа­лизация метода будет вызвана. Но когда точно такой же код применяется в __трейте__, то вызываемая с помощью super реализация метода при определении трейта __еще не определена__. Вызываемая реализация станет определяться __заново при каждом примешивании__ трейта в конкретный класс. Такое своеобразное поведение super является ключевым фактором, позволяющим трейтам работать в качестве наращиваемых модификаций.

При реализации набора __повторно используемого поведения__ придется решать, к чему прибегнуть: трейту или абстрактному классу. Золотого правила не суще­ ствует, но в этом разделе содержатся несколько __полезных рекомендаций__, к которым стоит прислушаться:
* Если поведение __не будет повторно__ использовано, то создавайте __конкретный класс__, поскольку в нем вообще нет повторно используемого поведения. 
* Если поведение может быть __повторно__ использовано различными __неродственными__ классами, то создайте __трейт__. Только трейты могут примешиваться в раз­личные части иерархии классов. 
* Если хотите __наследовать__ поведение в коде __Java__, то задействуйте __абстрактный класс__.
* Если планируется __распространение кода в скомпилированном виде__ и ожида­ется, что сторонние группы разработчиков станут создавать классы, что-либо __наследующие__ из него, то следует предпочесть __абстрактные классы__. Проблема в том, что при появлении в трейте нового элемента или удалении из него старого элемента все классы, являющиеся его наследниками, должны быть перекомпи­лированы, даже если в них не было никаких изменений. Если сторонние клиен­ты будут только вызывать поведение, а не наследовать его, то с использованием трейта не будет никаких проблем. 
* Если вы __не пришли к решению__ даже после того, как взвесили все ранее предоставленные рекомендации, то __начните с создания трейта__. Позже вы всегда сможете его изменить, а в целом использование трейта предоставляет вам больше возможностей.

##CASE-классы##
Классы модификатором case называются case-классами. Все данные сase-классов являются __неизменяемыми__.
Использование этого модификатора заставляет компилятор Scala добавлять к вашему классу некоторые синтаксиче­ские удобства. 
* Первое синтаксическое удобство заключается в том, что к классу __добавляется фабричный метод с именем данного класса__. Это означает, к примеру, что для соз­ дания var-объекта можно применить код Var("x"), не используя несколько более длинный вариант new Var("x"): 
#scala> val v = Var("x") v: Var = Var(x) 
Особенно полезны фабричные методы благодаря их вложенности. Теперь код не загроможден ключевыми словами new, поэтому структуру выражения можно воспринять с одного взгляда: 
#scala> val op = BinOp("+", Number(1), v) 
#op: BinOp = BinOp(+,Number(1.0),Var(x)) 
* Второе синтаксическое удобство заключается в том, что __все аргументы в списке параметров__ case-класса автоматически получают префикс val, то есть __сохраняются в качестве полей__: 
#scala> v.name res0: String = x
* Третье удобство состоит в том, что компилятор __добавляет__ к вашему классу «естественную» реализацию методов __toString, hashCode и equals__. Они будут за­ ниматься подготовкой данных к выводу, их хешированием и сравнением всего дерева, состоящего из класса, и (рекурсивно) всех его аргументов. Поскольку метод == в Scala всегда передает полномочия методу equals, то это значит, что __элементы case-классов всегда сравниваются структурно__:
#scala> println(op) BinOp(+,Number(1.0),Var(x)) 
#scala> op.right == Var("x") 
#res3: Boolean = true
* И наконец, чтобы создать измененные копии, компилятор __добавляет__ к вашему классу метод __copy__. Он пригодится для создания нового экземпляра класса, анало­гичного другому экземпляру, за исключением того, что будет отличаться одним или двумя атрибутами. Метод работает за счет использования именованных па­ раметров и параметров по умолчанию. Применение именованных параметров позволяет указать требуемые изменения. А для любого неуказанного параметра используется значение из старого объекта. Посмотрим в качестве при­мера, как можно создать операцию, похожую на op во всем, кроме того, что будет изменен параметр operator: 
#scala> op.copy(operator = "-") 
#res4: BinOp = BinOp(-,Number(1.0),Var(x))
* Но самым большим преимуществом case-классов является то, что они поддерживают __сопоставления с образцом__.

##Запечатанные классы
У __запечатанного__ класса не может быть никаких до­ полнительных подклассов, кроме тех, которые определены в том же самом файле. Особую пользу из этого можно извлечь при сопоставлении с образцом, поскольку запечатанность класса будет означать, что беспокоиться придется только по по­ воду тех подклассов, о которых вам уже известно. Более того, будет улучшена поддержка со стороны компилятора. При сопоставлении с образцом case-классам, являющимся наследниками запечатанного класса, компилятор в предупреждении отметит пропущенные комбинации паттернов. Если создается иерархия классов, предназначенная __для сопоставления с образцом__, то __нужно__ предусмотреть ее запечатанность. Чтобы это сделать, просто поставьте перед классом на вершине иерархии ключевое слово __sealed__.
__Запечатанные трейты__ - аналогично.

###Параметризация типов
Параметризация типов позволяет создавать обобщенные классы и трейты. Например, множества имеют обобщенный характер и получают параметр типа: они определяются как Set[T]. В результате любой отдельно взятый экземпляр множе­ства может иметь тип Set[String], Set[Int] и т. д., но должен быть множеством чего-либо. В отличие от языка __Java__, в котором __разрешено использовать сырые типы__ (raw types), __Scala требует указывать параметры типа__. Вариантность определяет взаимоотношения наследования параметризованных типов, к примеру таких, при которых Set[String] является подтипом Set[AnyRef].
__T*__ — форма записи для повторяющихся параметров.

Если S — подтип T и Constructor[S] рассматривается как подтип Constructor[T], можно сказать, что трейт Constructor __ковариантный__ в своем параметре типа T, то есть можно передать, например, Constructor[String] методу, который принимает параметр значения типа Constructor[AnyRef].
Полу­чить __ковариантность__ подтипизации можно следующим определением Constructor: 
#trait Constructor[+T] { ... }
Помимо префикса +, существует префикс -, который показывает __контравариантность__ подтипизации. Если определение Constructor имеет вид: 
#trait Constructor[-T] { ... } 
и если тип T — подтип типа S, то это будет означать, что Constructor[S] — подтип Constructor[T]
По умолчанию в Scala у обобщенных типов изначально имеется __нонвариантная__ (или жесткая) подтипизация, то есть если тип T — подтип типа S, то тип
Constructor[S] __не связан отношением типизации__ с Constructor[T].
__Ограничение типизации__:  с помощью синтаксиса __U >: T__ тип T определяется как __нижний ограничитель__ для U. В результате от типа U требуется, чтобы он был __супертипом__ для T.
Отношения супертипов и подтипов рефлексивны. Это значит, тип является одновремен­ но супертипом и подтипом по отношению к себе. Даже притом, что T — нижняя граница для U, T все же можно передавать методу, принимающему U.
