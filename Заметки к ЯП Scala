Модификаторы доступа в Scala могут дополняться __спецификаторами__. Модифика­тор вида private[X] или protected[X] означает, что доступ закрыт или защищен вплоть до X, где X определяет некий внешний пакет, класс или объект-одиночку.

??? — это метод, который генерирует ошибку scala.NotImplementedError и имеет результирующий тип Nothing. Он может применяться в качестве временной реализации в процессе разработки приложения.

Чтобы создать переменную со значением по умолчанию можно воспользоваться символом "_":
# var myString: String = _

Если object extends App - код внутри такого объекта будет непосредствнно исполняемым (типа main в С).
Конкатенация строк - оператор +.
Строки со вставкой значений - s"Строка $значение"
Все языковые конструкции являются __выражениями__, то есть вычисляются и имеют результат. 
Блок кода - выражение, ограниченное {}. Результат последнего выражения в блоке кода - результат этого блока. 
Отсутствие возвращаемого значения обозначается типом Unit и обозначает наличие __побочных эффектов__. Пример - println. Конструктор для значения Unit  __()__.
Операторы в Scala являются методами классов.

#Все четыре формы составления идентификаторов в Scala:
__Буквенно-цифровые идентификаторы__ начинаются с буквы или знака подчерки­ вания, за которыми могут следовать другие буквы, цифры или знаки подчеркива­ ния. Символ $ также считается буквой, но зарезервирован для идентификаторов, создаваемых компилятором Scala. Идентификаторы в пользовательских програм­ мах не должны содержать символы $, несмотря на возможность успешно пройти компиляцию: если это произойдет, то могут возникнуть конфликты имен с теми идентификаторами, которые будут созданы компилятором Scala. __Следует избегать подчеркивания__. Используется __смешанный регистр__.
* Имена полей, параметры методов, имена локальных переменных и имена функций в смешанном регистре должны начинаться с буквы в нижнем регистре`, например: length, flatMap и s. 
* Имена классов, трейтов и констант в смешанном регистре должны начинаться с буквы в верхнем регистре`, 
например: BigInt, List и UnbalancedTreeMap2.

__Идентификатор оператора__ состоит из одного или нескольких символов опе­раторов. Таковыми являются выводимые на печать ASCII-символы, такие как +, :, ?, ~ или #1. Примеры идентификаторов операторов: 
+ ++ ::: <?> :–> 
Компилятор Scala на внутреннем уровне перерабатывает идентификаторы операторов, чтобы превратить их в допустимые Java-идентификаторы со встро­енными символами $ . Например, идентификатор :-> будет представлен как $colon$minus$greater.

__Смешанный идентификатор__ состоит из буквенно-цифрового идентификато­ра, за которым стоят знак подчеркивания и идентификатор оператора. Напри­мер, unary_+, использованный как имя метода, определяет унарный оператор +. А myvar_=, использованный как имя метода, определяет оператор присваивания.

__Литеральный идентификатор__ представляет собой произвольную строку, за­ ключенную в обратные кавычки (`...`). Примеры литеральных идентификаторов выглядят следующим образом: 
`x` `<clinit>` `yield` 
Замысел состоит в том, что между обратными кавычками можно поместить лю­ бую строку, которую среда выполнения станет воспринимать в качестве идентифи­ катора. В результате всегда будет получаться идентификатор Scala. Это сработает даже в том случае, если имя, заключенное в обратные кавычки, является в Scala зарезервированным словом. Обычно такие идентификаторы используются при обращении к статическому методу yield в Java-классе Thread.

###КЛАССЫ###
Класс оъявляется с ключевым словом __class__ и инстациируется с ключевым словом __new__.
Наследование описывется ключевым словом __extends__ (если больше одного родителя - то __with__) :
#class Dog extends Animal
Объявление класса с указанными параметрами описывает __конструктор объектов класса__. Если перед аргументом не указать спецификатор (например __val__) значение аргумента не становится атрибутом экземпляра, если указать - становится.
В наличии полимофизм подтипов: экземпляр типа наследника может быть присвоен переменной типа родителя
Атрибуты и методы классов по умолчанию __public__.

Базовый класс по умолчанию для классов и трейтов - __AnyRef__
В Scala каждый __вспомогательный конструктор__ в качестве первого действия __должен вызывать еще один конструктор того же класса__. Иными словами, первой инструкции в каждом вспомогательном конструкторе каждого класса Scala следует иметь вид this(...). Вызываемым должен быть либо первичный конструктор (как в примере с классом Rational), либо другой вспомогательный конструктор, который появляет­ся в тексте программы перед вызывающим его конструктором. Конечный __результат__ применения данного правила заключается в том, что __каждый__ вызов конструктора в Scala __должен в конце концов завершаться вызовом первичного конструктора класса__. Первичный конструктор, таким образом, — __единственная__ точка входа в класс.

Если в классе есть метод, имеющий __ровно один параметр__ - этот метод может быть вызван в __инфиксной форме__.
Пример:
#point1.move(point2) эквивалентно point1 move point2
Если имя метода не заканчивается на ":" - метод имеет левую ассоциативность, иначе - правую. Возможно придется заключить название такого метода в ``.

__Анонимные классы__ объявляются как val smth = new <trait> { }. 
 
Любое __использование__ объекта в от­ношении каких-либо аргументов в круглых скобках будет преобразовано в вызов метода __apply__. Разумеется, данный код будет скомпилирован, только если в этом типе объекта определен метод apply. Иначе говоря, если в классе есть метод __apply__, при вызове этого метода слово "apply" можно опустить. Пример:
#greetStrings(i) преобразуется в greetStrings.apply(i).
По аналогии с этим, когда __присваивание__ выполняется в отношении переменной, к которой применены круглые скобки с одним или несколькими аргументами вну­три, компилятор выполнит преобразование в вызов метода __update__, получающего не только аргументы в круглых скобках, но и объект, расположенный справа от знака равенства. Пример:
#greetStrings(0) = "Hello" будет преобразован в greetStrings.update(0, "Hello")
Справа от = будет __последний__ аргумент update
 
__В классах Scala не могут содержаться статические элементы__. Вместо этого в Scala есть __объекты-одиночки, или синглтоны__. Объект-одиночка имеет __то же имя__, что и соответвующий ему __класс__. Определение объекта-одиночки выглядит так же, как определение класса, за исключением того, что вместо ключевого слова class используется __ключевое слово object__. Пример:
#object ChecksumAccumulator { 
#	private val cache = mutable.Map.empty[String, Int] 
#	def calculate(s: String): Int = 
#		if (cache.contains(s)) cache(s) 
#		else { val acc = new ChecksumAccumulator for (c <- s) acc.add(c.toByte) val cs = acc.checksum() cache += (s -> cs) cs } 
#}
Если объект-одиночка использует __общее с классом имя__, то для класса он называется __объектом-компаньоном__. И класс, и его объект-компаньон нужно определять в одном и том же исходном файле. Класс по отношению к объекту-одиночке называется __классом-компаньоном__. Класс __делится всеми__ своими __правами доступа__ со своим объектом-компаньоном, и наоборот. В частности, объект может обращаться ко всем приватным членам своего класса-компаньона точно так же, как класс может обращаться ко всем при­ватным членам своего объекта-компаньона.

__Имплиситы__ (применять с большой осторожностью!):
* для неявного преобразования типов
Ключевое слово implicit используется в целях маркировки того объявления, которое компилятор может применять в качестве неявного. Им можно помечать любое объявление переменной, функции или объекта. Пример объявления:
#implicit def intToRational(x: Int) = new Rational(x) 
Определяется метод преобразования из типа Int в тип Rational. Модификатор implicit перед определением метода сообщает компилятору о том, что в ряде ситуа­ций данный метод следует применять автоматически.
Важные замечания:
 Чтобы неявное преобразование заработало, оно должно находиться в области видимости в качестве простого идентификатора или быть связанным с исходным или целевым типом преобразования.
 Может быть вставлено только одно неявное преобразование. 
 Когда код в том виде, в котором он записан, проходит проверку типов, не делаются попытки применения неявных преобразований. Компилятор не станет изменять уже работающий код.
__Внимание!!!__Выполнение компилятором неявного преобразования никак внешне не проявляет­ся и не записывается в явном виде в исходный код.

* для использования в тайплассах 

* для неявных классов
Неявные классы были добавлены в Scala 2.10 с целью облегчить создание обо­гащающих классов-оболочек. Неявным называется класс, перед определением которого ставится ключевое слово implicit. Для любого такого класса компилятор создает неявное преобразование из параметра конструктора класса в сам класс.

* для неявных параметров

##ТРЕЙТЫ##
__Трейты__в Scala являются фундаментальными повторно используемыми блоками кода. В трейте инкапсулируются определения тех методов и полей, которые затем могут повторно использоваться путем их примешивания в классы. В отличие от наследования классов, в котором каждый класс должен быть наследником только одного суперкласса, __в класс может примешиваться любое количество трейтов__.
#trait Philosophical { 
#	def philosophize() = { println("На меня тратится память, следовательно, я существую!") } 
#}
После того как трейт определен, он может быть __примешан__ в класс с помощью ключевого слова: __либо extends, либо with__.
Если нужно примешать трейт в класс, который явно расширяет суперкласс, то ключевое слово extends используется для указания суперкласса, а для примеши­ вания трейта — ключевое слово with. Если нужно примешать сразу __несколько трейтов__, то дополнительные трейты указываются с помощью ключевого слова with.
#class Frog extends Animal with Philosophical with HasLegs { override def toString = "зеленая" }

В трейтах можно объявлять поля и сохранять состояние. Фактически в определении трейта можно делать то же самое, что и в определении класса, и син­таксис выглядит почти так же, но с двумя __исключениями__:
1. В трейте __не может быть__ никаких присущих классу __параме­тров__ (то есть параметров, передаваемых __первичному конструктору__ класса). Иными словами, хотя у вас есть возможность определить класс таким вот образом: 
#class Point(x: Int, y: Int) 
следующая попытка определить трейт окажется неудачной: 
#trait NoPoint(x: Int, y: Int) // Не пройдет компиляцию 
2. В __классах__ вызовы __super__ имеют __статическую__ привязку, а в __трейтах — динамическую__. Если в __классе__ воспользоваться кодом super.toString, то вы будете __точно знать__, какая именно реа­лизация метода будет вызвана. Но когда точно такой же код применяется в __трейте__, то вызываемая с помощью super реализация метода при определении трейта __еще не определена__. Вызываемая реализация станет определяться __заново при каждом примешивании__ трейта в конкретный класс. Такое своеобразное поведение super является ключевым фактором, позволяющим трейтам работать в качестве наращиваемых модификаций.

При примешивании трейт может требовать указания __параметра типа__.
#class Rational(n: Int, d: Int) extends Ordered[Rational]

Трейты используются также для __наращиваемых модификаций__
#trait Doubling extends IntQueue { // Можно примешивать только к классам extends IntQueue
#	abstract override def put(x: Int) = { super.put(2 * x) } 
#}

Если трейт должен быть __обязательно примешан к классу с другим трейтом__ и это нужно проверить во время компиляции используется конструкция __self type__:
# trait Person
# trait Diet { this: Person => // вместо this может быть какой-нибудь другой идентификатор
# // какая-то имплементация, включающая this, если this не будет использоваться - можно использовать "_"
#}
Теперь нельзя примешать трейт Diet к какому либо классу без примешивания трейта Person

Ключевые особенности примешивания трейтов:
1. Объявлен суперкласс
Если в трейте объявлен __суперкласс__ - этот трейт может быть примешан __только в класс, расширяющий__ этот суперкласс.

2. Имеется __вызов super__ в отношении метода, который объявлен __абстрактным__
В трейте вызовы super динамически связаны, поэтому вызов super в трейте Doubling будет работать при условии, что трейт примешан __после другого трейта__ или класса, в котором дается __конкретное определение метода.__Чтобы сообщить компилятору, что это делается намеренно, подобные методы следует помечать модификаторами __abstract override__. Это со­четание модификаторов позволительно __только для членов трейтов__, но не классов, и означает, что трейт должен быть примешан в некий __класс, имеющий конкретное определение рассматриваемого метода__.
Располагая __несколькими__ модифицирующими трейтами, можно выбрать, какой из них вам понадобится для той или иной очереди. 
__Порядок примешивания играет существенную роль__. Грубо говоря, трейт, находящийся __правее__, вступает в силу __первым__. Когда метод вызывается в отношении экземпляра класса с примешанными трейтами, первым вызывается тот метод, который определен в самом правом трейте. Если этот метод выполняет вызов __super__, то вызывается метод, который определен __в следующем трейте левее данного трейта__, и т.д.

При реализации набора __повторно используемого поведения__ придется решать, к чему прибегнуть: трейту или абстрактному классу. Золотого правила не суще­ ствует, но в этом разделе содержатся несколько __полезных рекомендаций__, к которым стоит прислушаться:
* Если поведение __не будет повторно__ использовано, то создавайте __конкретный класс__, поскольку в нем вообще нет повторно используемого поведения. 
* Если поведение может быть __повторно__ использовано различными __неродственными__ классами, то создайте __трейт__. Только трейты могут примешиваться в раз­личные части иерархии классов. 
* Если хотите __наследовать__ поведение в коде __Java__, то задействуйте __абстрактный класс__.
* Если планируется __распространение кода в скомпилированном виде__ и ожида­ется, что сторонние группы разработчиков станут создавать классы, что-либо __наследующие__ из него, то следует предпочесть __абстрактные классы__. Проблема в том, что при появлении в трейте нового элемента или удалении из него старого элемента все классы, являющиеся его наследниками, должны быть перекомпи­лированы, даже если в них не было никаких изменений. Если сторонние клиен­ты будут только вызывать поведение, а не наследовать его, то с использованием трейта не будет никаких проблем. 
* Если вы __не пришли к решению__ даже после того, как взвесили все ранее предоставленные рекомендации, то __начните с создания трейта__. Позже вы всегда сможете его изменить, а в целом использование трейта предоставляет вам больше возможностей.

##CASE-классы##
Классы c модификатором case называются case-классами. Все данные сase-классов являются __неизменяемыми__.
Использование этого модификатора заставляет компилятор Scala добавлять к вашему классу некоторые синтаксиче­ские удобства. 
* Первое синтаксическое удобство заключается в том, что к классу __добавляется фабричный метод с именем данного класса__. Это означает, к примеру, что для соз­дания объекта класса Var можно применить код Var("x"), не используя несколько более длинный вариант new Var("x"): 
#scala> val v = Var("x") v: Var = Var(x) 
Особенно полезны фабричные методы благодаря их вложенности. Теперь код не загроможден ключевыми словами new, поэтому структуру выражения можно воспринять с одного взгляда: 
#scala> val op = BinOp("+", Number(1), v) 
#op: BinOp = BinOp(+,Number(1.0),Var(x)) 
* Второе синтаксическое удобство заключается в том, что __все аргументы в списке параметров__ case-класса автоматически получают префикс val, то есть __сохраняются в качестве полей__: 
#scala> v.name res0: String = x
* Третье удобство состоит в том, что компилятор __добавляет__ к вашему классу «естественную» реализацию методов __toString, hashCode и equals__. Они будут за­ ниматься подготовкой данных к выводу, их хешированием и сравнением всего дерева, состоящего из класса, и (рекурсивно) всех его аргументов. Поскольку метод == в Scala всегда передает полномочия методу equals, то это значит, что __элементы case-классов всегда сравниваются структурно__:
#scala> println(op) BinOp(+,Number(1.0),Var(x)) 
#scala> op.right == Var("x") 
#res3: Boolean = true
* И наконец, чтобы создать измененные копии, компилятор __добавляет__ к вашему классу метод __copy__. Он пригодится для создания нового экземпляра класса, анало­гичного другому экземпляру, за исключением того, что будет отличаться одним или двумя атрибутами. Метод работает за счет использования именованных па­ раметров и параметров по умолчанию. Применение именованных параметров позволяет указать требуемые изменения. А для любого неуказанного параметра используется значение из старого объекта. Посмотрим в качестве при­мера, как можно создать операцию, похожую на op во всем, кроме того, что будет изменен параметр operator: 
#scala> op.copy(operator = "-") 
#res4: BinOp = BinOp(-,Number(1.0),Var(x))
* Но самым большим преимуществом case-классов является то, что они поддерживают __сопоставления с образцом__.

##Сопоставление с образцом##
Пример:
#expr match { 
#	case BinOp(op, left, right) => println(s"$expr является бинарной операцией") 
#	case _ => // обработка общего варианта 
#}
* __Подстановочный паттерн (_)__ соответствует абсолютно любому объекту. Он может использоваться в качестве общего паттерна, выявляющего все остав­ шиеся альтернативы. Кроме того, подстановочные паттерны могут использоваться для __игнорирования__ тех частей объекта, которые не представляют для вас интереса.
* __Паттерн-константа__ соответствует только самому себе. В качестве константы может использоваться любой литерал. Например, паттернами-константами являются 5, true и "hello". В качестве константы может использоваться и любой val- или объект-одиночка. Так, объект-одиночка Nil является паттерном, соответствующим только пустому списку.
#def describe(x: Any) = x match { 
#	case 5 => "пять" 
#	case true => "правда" 
#	case "hello" => "привет!" 
#	case Nil => "пустой список" 
#	case _ => "что-то другое" 
#}
* __Паттерн-переменная__ соответствует любому объекту точно так же, как подстано­вочный паттерн, но в отличие от него Scala привязывает переменную к объекту. Затем с помощью этой переменной можно в дальнейшем воздействовать на объект.
#expr match { 
#	case 0 => "нуль" 
#	case somethingElse => "не нуль: " + somethingElse 
#}
* __Паттерн-конструктор__ выглядит как BinOp("+", e, Number(0)). Он со­ стоит из имени (BinOp), после которого в круглых скобках стоят несколько об­ разцов: "+", e и Number(0). При условии, что имя обозначает case-класс, такой паттерн показывает следующее: сначала проверяется принадлежность элемента к названному case-классу, а затем соответствие параметров конструктора объекта предоставленным дополнительным паттернам.
В паттернах Scala поддержива­ются __глубкие сопоставления (deep matches)__. Такие паттерны проверяют не только предоставленный объект верхнего уровня, но и его содержимое на соответствие следующим паттернам. Дополнительные паттерны сами по себе могут быть пат­тернами-конструкторами, поэтому их можно использовать для проверки объекта произвольной глубины. 
#expr match { 
#	case BinOp("+", e, Number(0)) => println("глубокое соответствие") 
#	case _ => 
#}
Паттерн, показанный в примере, проверяет, что объект верхнего уровня относится к типу BinOp, третьим параметром его кон­структора является число Number и значение поля этого числа — 0. Весь паттерн умещается в одну строку кода, хотя выполняет проверку на глубину в три уровня.
* По аналогии с сопоставлением с case-классами можно сопоставлять с такими ти­пами __последовательностей__, как List или Array. Допустимо воспользоваться тем же синтаксисом, но теперь в паттерне вы можете указать любое количество элементов. 
#expr match { 
#case List(0, _, _) => println("соответствие найдено") 
#case _ => 
#}
В примере показан паттерн для проверки того факта, что трехэлементный список начинается с нуля. 
Если нужно сопоставить с последовательностью, __не указывая ее длину__, то в качестве последнего элемента паттерна-последовательности можно указать образец _*. Он соответствует __любому количеству элементов__ внутри последовательности, включая нуль элементов. 
#expr match { 
#	case List(0, _*) => println("соответствие найдено ") 
#	case _ => }
Пример соответствует любому списку, который начинается с нуля, независимо от длины этого списка.
* Сопоставление с образцом с использованием __паттерна-кортежа__ 
#def tupleDemo(expr: Any) = expr match { 
#	case (a, b, c) => println("соответствует " + a + b + c) 
#	case _ => 
#}
* __Типизированный паттерн__ (typed pattern) можно использовать в качестве удобного заменителя для проверок типов и приведения типов. 
#def generalSize(x: Any) = x match { 
#	case s: String => s.length 
#	case m: Map[_, _] => m.size 
#	case _ => -1 
#}
Кроме использования отдельно взятого паттерна-переменной можно также до­ бавить переменную к любому другому паттерну. Нужно просто указать имя пере­ менной, знак «собачка» (@), а затем паттерн. Это даст вам паттерн с привязанной переменной, то есть паттерн для выполнения обычного сопоставления с образцом с возможностью в случае совпадения присвоить переменной соответствующий объект, как и при использовании обычного паттерна-переменной. В качестве примера в листинге 15.13 показано сопоставление с образцом — по­ иск операции получения абсолютного значения, применяемой в строке дважды. Такое выражение можно упростить, однократно получив абсолютное значение. 
#expr match { 
#	case UnOp("abs", e @ UnOp("abs", _)) => e 
#	case _ => 
#} 
Пример, показанный в данном листинге, включает паттерн с привязкой перемен­ ной, где в качестве переменной выступает e, а в качестве паттерна — UnOp("abs", _). Если будет найдено соответствие всему паттерну, то часть, которая соответствует UnOp("abs", _), станет доступна как значение переменной e. Результатом вариан­ та будет просто e, поскольку у e такое же значение, что и у expr, но с меньшим на единицу количеством операций получения абсолютного значения.
* __Ограждение паттерна__ указывается после образца и начинается с ключевого слова if. В качестве ограждения может использоваться произвольное булево выражение, которое обычно ссылается на переменные в образце. При наличии ограждения паттернов соответствие считается найденным, только если огражде­ ние вычисляется в true. Таким образом, первый вариант показанного ранее кода соответствует только бинарным операциям, имеющим два одинаковых операнда.
// соответствует только положительным целым числам 
#	case n: Int if 0 < n => ... 
// соответствует только строкам, начинающимся с буквы 'a' 
#	case s: String if s(0) == 'a' => ...
__Паттерны применяются в порядке их указания.__
__Варианты «поймать все» следуют после более конкретизированных правил упрощения.__ Если располо­жить их в другом порядке, то вариант «поймать все» будет запущен вместо более конкретизированных правил. Во многих случаях компилятор будет жаловаться на такие попытки.
Если создается иерархия классов, предназначенная для сопоставления с об­разцом, то нужно предусмотреть ее __запечатанность__.
Если матчится лямбда с __единственным__ параметром, выражение x => x match можно опустить, сразу записав __первым__ оператором в фигурных скобках __case__ т.е.
#for (x <- lst) { x => 
#	x match {
# case...
эквивалентно
#for (x <- lst) {
#case...

##Запечатанные классы
У __запечатанного__ класса не может быть никаких до­ полнительных подклассов, кроме тех, которые определены в том же самом файле. Особую пользу из этого можно извлечь при сопоставлении с образцом, поскольку запечатанность класса будет означать, что беспокоиться придется только по по­ воду тех подклассов, о которых вам уже известно. Более того, будет улучшена поддержка со стороны компилятора. При сопоставлении с образцом case-классам, являющимся наследниками запечатанного класса, компилятор в предупреждении отметит пропущенные комбинации паттернов. Если создается иерархия классов, предназначенная __для сопоставления с образцом__, то __нужно__ предусмотреть ее запечатанность. Чтобы это сделать, просто поставьте перед классом на вершине иерархии ключевое слово __sealed__.
__Запечатанные трейты__ - аналогично.

###Параметризация типов
Параметризация типов позволяет создавать обобщенные классы и трейты. Например, множества имеют обобщенный характер и получают параметр типа: они определяются как Set[T]. В результате любой отдельно взятый экземпляр множе­ства может иметь тип Set[String], Set[Int] и т. д., но должен быть множеством чего-либо. В отличие от языка __Java__, в котором __разрешено использовать сырые типы__ (raw types), __Scala требует указывать параметры типа__. Вариантность определяет взаимоотношения наследования параметризованных типов, к примеру таких, при которых Set[String] является подтипом Set[AnyRef].
__T*__ — форма записи для повторяющихся параметров.

Если S — подтип T и Constructor[S] рассматривается как подтип Constructor[T], можно сказать, что трейт Constructor __ковариантный__ в своем параметре типа T, то есть можно передать, например, Constructor[String] методу, который принимает параметр значения типа Constructor[AnyRef].
Полу­чить __ковариантность__ подтипизации можно следующим определением Constructor: 
#trait Constructor[+T] { ... }
Помимо префикса +, существует префикс -, который показывает __контравариантность__ подтипизации. Если определение Constructor имеет вид: 
#trait Constructor[-T] { ... } 
и если тип T — подтип типа S, то это будет означать, что Constructor[S] — подтип Constructor[T]
По умолчанию в Scala у обобщенных типов изначально имеется __нонвариантная__ (или жесткая) подтипизация, то есть если тип T — подтип типа S, то тип
Constructor[S] __не связан отношением типизации__ с Constructor[T].
__Ограничение типизации__:  с помощью синтаксиса __U >: T__ тип T определяется как __нижний ограничитель__ для U. В результате от типа U требуется, чтобы он был __супертипом__ для T.
Отношения супертипов и подтипов рефлексивны. Это значит, тип является одновремен­но супертипом и подтипом по отношению к себе. Даже притом, что T — нижняя граница для U, T все же можно передавать методу, принимающему U.

##ФУНКЦИИ##
Поскольку JVM не предусматривает штук из истинных функциональных языков (функции первого класса, функции высших типов, например) в Scala реализован особый механизм:
Группа классов Function1..Function22 позволяет определить функциональные объекты следующим образом:
# val myFunc = new Function1[String, String] {
#	override def apply(arg1: String): String = "Привет" + arg1
#}
или, используя синтаксический сахар,
# val myFunc: String => String = (arg1: String) => "Привет" + arg1
или, пользуясь выводом типов компилятора, еще короче
# val myFunc = (arg1: String) => "Привет" + arg1
Пример функции высших типов:
# valaMappedList = List(1,2,3).map(x => x + 1)
где x => x + 1 - анонимная функция (лямбда)

Тело функции можно вызывать как в () так и в {}.

#def add(b: Byte): Unit = { 
#	sum += b 
#}

__Вызов параметров по имени__ - это когда значение параметра вычисляется __только в момент вызова параметра__. Этот способ противоположен __вызову по значению__. Преимущество __вызова параметров по имени__ заключается в том, что они __не вычисляются если не используются__ в теле функции. С другой стороны плюсы вызова параметров по значению в том, что они вычисляются только один раз.
Т.е. в случае вызова по имени параметр вычисляется __лениво__. Механизм вызова по имени передает блок кода вызывающему и __каждый раз__, когда вызывающий __обращается к параметру__, блок кода исполняется и значение рассчитывается заново. 
A call-by-name mechanism passes a code block to the callee and __each time__ the callee __accesses the parameter__, the code block is executed and the __value is calculated__.
Синтаксис:
#def callByValue(x: Int) = {
#}
#def callByName(x: => Int) = {
#}
#def whileLoop(condition: => Boolean)(body: => Unit): Unit =
#  if (condition) {
#    body
#    whileLoop(condition)(body)
#  }
Метод whileLoop использует несколько списков параметров - условие и тело цикла. Если condition является верным, выполняется body, а затем выполняется рекурсивный вызов whileLoop. Если condition является ложным, то тело никогда не вычисляется, тк у нас стоит => перед типом body.
#var i = 2
#whileLoop (i > 0) {
#  println(i)
#  i -= 1
#}  // выведет 2 1
Теперь, когда мы передаем i > 0 как наше условие condition и println(i); i-= 1 как тело body, код ведет себя также как обычный цикл в большинстве языков программирования.

Lazy val - объявление переменной, значение которой будет вычислено в момент первого обращения к ней.
#import java.time.Instant
#lazy val lazyCurrent = Instant.now 
#Thread.sleep(1000)	
#println(s"Значение переменной  = $lazyCurrent ") 

В лямбда функциях можно заменить каждый параметр на подчеркивание __строго 1:1__:
# _ + 5  // x=>x+5
#_ + _ //(x,y) => x+y
каждое подчеркивание обозначает __разный__ параметр в порядке их передачи в лямбду.

__Частичное применение функции__ - замена при вызове одного или нескольких параметров символом "_".
# def foo (a: Int, b: Int) : Int = a + b
# val f = foo(4 , _) //Частичное применение		
# println(f(5) //Вернет 9 (4 + 5)
Можно заменять не только последние параметры

В случае возврата функции как результата происходит захват контекста __(замыкание)__- захватываются параметры и внутренние переменные. Если внутренняя переменная изменяет свой результат - это происходит в __общем__ контексте функции и поэтому ее изменение отражается __при каждом вызове функции__:
# def make_counter( init:Int): () => Int = {
#		var counter = init
#		() => { 
#						counter += 1
#						counter
#		}
# }
# var c1 = make_counter(init = 10)
# println(c1)
# println(c1)
# println(c1)
Результат:
11
12
13

Аннотация @tailrec говорит компилятору, что в следующей за ним рекурсивной функции следует заменить хвостовую рекурсию на цикл. Если эта оптимизаця невозможна компилятор выдаст ошибку.

Важные функции высших типов:
__map__
__flatMap__ (принимает в качестве аргумента функцию из простого типа в параметризированный тип)
__filter__
Можно chaining. Для более читабельного чейнинга используется __for compehensions__.

##КОЛЛЕКЦИИ##
__Все__ простые коллекции по умолчанию __иммутабельны__. Все операции над коллекцией возвращают новый экземпляр коллекции.

* Класс __Seq__ - упорядоченная коллекция - родитель для всех коллекций
# val aSeq = Seq(1,2,3)
Позволяет доступ к элементу по индексу
# val aElem = aSeq(1) // вернет элемент по индексу 1 т.е. 2 (коллекции индексируются с 0)
Метод updated возвращает новую коллекцию с измененным элементом по индексу:
# val aChangedSeq = aSeq.updated(1,5) // (1,5,3)
Другие методы (:
reverse
++ - добавляет Seq к Seq
sorted - сортирует коллекцию
foldLeft - свертка коллекции
mkString - преобразование в строку с разделителями
	Метод __flatMap__ для коллекций в качестве правого операнда получает функ­цию, возвращающую список элементов. Он применяет функцию к каждому эле­менту коллекции и возвращает конкатенацию всех результатов выполнения функции. Разница между map и flatMap для коллекции показана в следующем примере: 
#scala> words map (_.toList) 
#res35: List[List[Char]] = List(List(t, h, e), List(q, u, i, c, k), List(b, r, o, w, n), List(f, o, x)) 
#scala> words flatMap (_.toList) 
#res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x) 
Там, где map возвращает список списков, flatMap возвращает единый список, в котором все элементы списков сконкатенированы.
__Фильтрация коллекций: filter, partition, find, takeWhile, dropWhile и span__
	Метод xs filter p получает в качестве операндов коллекцию xs типа Seq[T] и функцию-предикат p типа T => Boolean. Эта операция выдает список всех элемен­тов x из коллекции xs, для которых p(x) вычисляется в true.
__Применение предикатов к коллекциям: forall и exists__ 
	Метод xs __forall__ p получает в качестве аргументов коллекцию xs и предикат p. Она возвращает результат true, если __все__ элементы списка удовлетворяют условию пре­диката p. Напротив, операция xs __exists__ p возвращает true, если в xs есть __хотя бы один__ элемент, удовлетворяющий условию предиката p.
	Метод __fill__ заполняет коллекцию указанными значениями (во втором списке аргументов принимает лямбду)
# val aSeq = Seq.fill(5)(5)
Метод __collect__ объединяет методы map и filter. На вход - коллекция и операция, далее паттернматчинг.

* Класс __List__ - реализация __Seq__
# val aList = List(1,2,3)
	Инфиксный оператор конструирования :: обозначает расширение списка __с начала__. То есть запись x :: xs представляет собой список, первым элементом ко­ торого является x, за которым следует список xs (его элементы).
# val aNewList = 0 :: aList // List(0,1,2,3)
	Операцией, похожей на ::, является конкатенация списков, записываемая в виде :::. В отличие от операции :: операция ::: получает в качестве опе­рандов два списка. Результатом выполнения кода xs ::: ys выступает новый список, содержащий все элементы списка xs, за которыми следуют все элементы списка ys.
	Функции +: и :+ добавляют элемент к коллекции и коллекцию к элементу соответственно.
# val aNewList2 = 0 +: aList :+ 4 // List(0,1,2,3,4)

* Класс __Array__ - классический массив Java
# val anArray = Array(1,2,3,4,5,6) // аналогично int[] в Java
имеет доступ к большинству методов Seq, хотя сам Seq не является и не наследует. Можно сконвертировать в Seq:
# val aSeq: Seq[Int] = anArray.toIndexedSeq
Массивы __мутабельны__!
# anArray.update(2,30) //замена 2-го элемента на значение 30 В САМОМ МАССИВЕ! 

* Класс __Vector__ - быстрый Seq для больших объемов данных (гораздо быстрее индексный поиск, чем в Seq или List)
# val aVector = Vector(1,2,3)

* Класс __Set__ - отсутствие дубликатов в коллекции
# val aSet = Set(1,2,3,3,4,2) // Set(1,2,3,4)
Порядок элементов не имеет значения
Самый важный метод - проверка наличия элемента:
# val aSetHas = aSet.contains(5) // false
Можно добавлять и удалять элементы:
# val anAddedSet = aSet + 5 // Set(1,2,3,4,5)
# val aRemovedSet = aSet - 3 // Set(1,2,4)
Можно объединять коллекции:
# val aPlusSet = aSet.union(aRemovedSet)
# val aPlusSet = aSet ++ aRemovedSet /то же
# val aPlusSet = aSet | aRemovedSet /то же
Можно находить различия в 2 коллекциях
# val aDiffSet = aSet.diff(aRemovedSet)
# val aDiffSet = aSet -- aRemovedSet /то же
Можно находить пересечения
# val aIntersectSet = aSet.intersect(aRemovedSet)
# val aIntersectSet = aSet.& aRemovedSet

* Диапазоны (__ranges__)
# val aRange = 1 to 1000 - включает последний элемент
# val aNonInclusiveRange = 1 until 1000 - не включает последний элемент
Могут быть не заполненными элементами, но позволяют работать с ними 
# val twoByTwo = aRange.map(x => 2 * x).toList // List(2,4,6,8,...,2000) 
Можно приводить к разным коллекциям: toList, toSeq, toVector, toSet ...

* Кортежи (__tuples__)
# val aTuple = (1,true,"Do")

* Класс __Map__ - ассоциативные массивы (maps)
# val aPhoneBook: Map[String, Int] {
# ("John", 124456) 
# Sara -> 876543 // эквивалентно предыдущей строке
#}
