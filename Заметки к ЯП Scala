Модификаторы доступа в Scala могут дополняться __спецификаторами__. Модифика­тор вида private[X] или protected[X] означает, что доступ закрыт или защищен вплоть до X, где X определяет некий внешний пакет, класс или объект-одиночку.

??? — это метод, который генерирует ошибку scala.NotImplementedError и имеет результирующий тип Nothing. Он может применяться в качестве временной реализации в процессе разработки приложения.

Чтобы создать переменную со значением по умолчанию можно воспользоваться символом "_":
# var myString: String = _

Если object __extends App__ - код внутри такого объекта будет непосредствнно исполняемым (типа main в С).
Конкатенация строк - оператор +.
Строки со вставкой значений - s"Строка $значение"
Почти вcе языковые конструкции являются __выражениями__, то есть вычисляются и имеют результат. 
Блок кода - выражение, ограниченное {}. Результат последнего выражения в блоке кода - результат этого блока. 
Отсутствие возвращаемого значения обозначается типом Unit и обозначает наличие __побочных эффектов__. Пример - println. Конструктор для значения Unit  __()__.
Операторы в Scala являются методами классов.

#Все четыре формы составления идентификаторов в Scala:
__Буквенно-цифровые идентификаторы__ начинаются с буквы или знака подчерки­вания, за которыми могут следовать другие буквы, цифры или знаки подчеркива­ ния. Символ $ также считается буквой, но зарезервирован для идентификаторов, создаваемых компилятором Scala. Идентификаторы в пользовательских програм­ мах не должны содержать символы $, несмотря на возможность успешно пройти компиляцию: если это произойдет, то могут возникнуть конфликты имен с теми идентификаторами, которые будут созданы компилятором Scala. __Следует избегать подчеркивания__. Используется __смешанный регистр__.
* Имена полей, параметры методов, имена локальных переменных и имена функций в смешанном регистре должны начинаться с буквы в нижнем регистре`, например: length, flatMap и s. 
* Имена классов, трейтов и констант в смешанном регистре должны начинаться с буквы в верхнем регистре`, 
например: BigInt, List и UnbalancedTreeMap2.

__Идентификатор оператора__ состоит из одного или нескольких символов опе­раторов. Таковыми являются выводимые на печать ASCII-символы, такие как +, :, ?, ~ или #1. Примеры идентификаторов операторов: 
+ ++ ::: <?> :–> 
Компилятор Scala на внутреннем уровне перерабатывает идентификаторы операторов, чтобы превратить их в допустимые Java-идентификаторы со встро­енными символами $ . Например, идентификатор :-> будет представлен как $colon$minus$greater.

__Смешанный идентификатор__ состоит из буквенно-цифрового идентификато­ра, за которым стоят знак подчеркивания и идентификатор оператора. Напри­мер, unary_+, использованный как имя метода, определяет унарный оператор +. А myvar_=, использованный как имя метода, определяет оператор присваивания.

__Литеральный идентификатор__ представляет собой произвольную строку, за­ ключенную в обратные кавычки - `...`. Примеры литеральных идентификаторов выглядят следующим образом: 
`x` `<clinit>` `yield` 
Замысел состоит в том, что между обратными кавычками можно поместить любую строку, которую среда выполнения станет воспринимать в качестве идентифи­ катора. В результате всегда будет получаться идентификатор Scala. Это сработает даже в том случае, если имя, заключенное в обратные кавычки, является в Scala зарезервированным словом. Обычно такие идентификаторы используются при обращении к статическому методу yield в Java-классе Thread.

###КЛАССЫ###
Класс оъявляется с ключевым словом __class__ и инстациируется с ключевым словом __new__.
Наследование описывется ключевым словом __extends__ (если больше одного родителя - то __with__) :
#class Dog extends Animal
Объявление класса с указанными параметрами описывает __конструктор объектов класса__. Если перед аргументом __не указать спецификатор (например val)__ значение аргумента __не становится атрибутом экземпляра__, если указать - становится.
В наличии полимофизм подтипов: экземпляр типа наследника может быть присвоен переменной типа родителя
Атрибуты и методы классов по умолчанию __public__.

Базовый класс по умолчанию для классов и трейтов - __AnyRef__
В Scala каждый __вспомогательный конструктор__ в качестве первого действия __должен вызывать еще один конструктор того же класса__. Иными словами, первой инструкции в каждом вспомогательном конструкторе каждого класса Scala следует иметь вид this(...). Вызываемым должен быть либо первичный конструктор, либо другой вспомогательный конструктор, который появляет­ся в тексте программы перед вызывающим его конструктором. Конечный __результат__ применения данного правила заключается в том, что __каждый__ вызов конструктора в Scala __должен в конце концов завершаться вызовом первичного конструктора класса__. Первичный конструктор, таким образом, — __единственная__ точка входа в класс.

Если в классе есть метод, имеющий __ровно один параметр__ - этот метод может быть вызван в __инфиксной форме__.
Пример:
#point1.move(point2) эквивалентно point1 move point2
Если имя метода не заканчивается на ":" - метод имеет левую ассоциативность, иначе - правую. Возможно придется заключить название такого метода в ``.

__Анонимные классы__ объявляются как val smth = new <trait> { }. 
 
Любое __использование__ объекта в от­ношении каких-либо аргументов в круглых скобках будет преобразовано в вызов метода __apply__. Разумеется, данный код будет скомпилирован, только если в этом типе объекта определен метод apply. Иначе говоря, если в классе есть метод __apply__, при вызове этого метода слово "apply" можно опустить. Пример:
#greetStrings(i) преобразуется в greetStrings.apply(i).
По аналогии с этим, когда __присваивание__ выполняется в отношении переменной, к которой применены круглые скобки с одним или несколькими аргументами вну­три, компилятор выполнит преобразование в вызов метода __update__, получающего не только аргументы в круглых скобках, но и объект, расположенный справа от знака равенства. Пример:
#greetStrings(0) = "Hello" будет преобразован в greetStrings.update(0, "Hello")
Справа от = будет __последний__ аргумент update
Специальный метод __unapply__ позволяет провести операцию, обратную apply - деконструировать объект. Извлекает и возвращает атрибуты объекта. Позволяет использовать патернматчинг даже на объектах, не приспособленных для этого (включая классы Java). Обычно помещается в __объект-компаньон__. Пример:
# class User(val name: String, val age: Int)
# object User {
#  def apply(name: String, age: Int) = new User(name, age)
#  def unapply(u: User) = Some(u.name, u.age)
# }
# val user = User("John", 25) // apply
# User.unapply(user) // Option[(String, Int)] = Some(("John",25))
 
__В классах Scala не могут содержаться статические элементы__. Вместо этого в Scala есть __объекты-одиночки, или синглтоны__. Объект-одиночка имеет __то же имя__, что и соответвующий ему __класс__. Определение объекта-одиночки выглядит так же, как определение класса, за исключением того, что вместо ключевого слова class используется __ключевое слово object__. Пример:
#object ChecksumAccumulator { 
#	private val cache = mutable.Map.empty[String, Int] 
#	def calculate(s: String): Int = 
#		if (cache.contains(s)) cache(s) 
#		else { val acc = new ChecksumAccumulator for (c <- s) acc.add(c.toByte) val cs = acc.checksum() cache += (s -> cs) cs } 
#}
Если объект-одиночка использует __общее с классом имя__, то для класса он называется __объектом-компаньоном__. И класс, и его объект-компаньон нужно определять в одном и том же исходном файле. Класс по отношению к объекту-одиночке называется __классом-компаньоном__. Класс __делится всеми__ своими __правами доступа__ со своим объектом-компаньоном, и наоборот. В частности, объект может обращаться ко всем приватным членам своего класса-компаньона точно так же, как класс может обращаться ко всем при­ватным членам своего объекта-компаньона.

__Имплиситы__ (применять с большой осторожностью!):
* для неявного преобразования типов
Ключевое слово implicit используется в целях маркировки того объявления, которое компилятор может применять в качестве неявного. Им можно помечать любое объявление переменной, функции или объекта. Пример объявления:
#implicit def intToRational(x: Int) = new Rational(x) 
Определяется метод преобразования из типа Int в тип Rational. Модификатор implicit перед определением метода сообщает компилятору о том, что в ряде ситуа­ций данный метод следует применять автоматически.
Важные замечания:
 Чтобы неявное преобразование заработало, оно должно находиться в области видимости в качестве простого идентификатора или быть связанным с исходным или целевым типом преобразования.
 Может быть вставлено только одно неявное преобразование. 
 Когда код в том виде, в котором он записан, проходит проверку типов, не делаются попытки применения неявных преобразований. Компилятор не станет изменять уже работающий код.
__Внимание!!!__Выполнение компилятором неявного преобразования никак внешне не проявляет­ся и не записывается в явном виде в исходный код.

* для использования в тайплассах
#trait Searchable[T] {
#  def uri(obj: T): String
#}
The example above defines a type class, allowing a type T to be searchable — that is, having an associated URI. Every class that wants to participate in the Searchable type class must implement its abstract method uri.

__Вариант 1__
Imagine we have two types, Customer and Policy, that we want to make searchable:
#case class Customer(taxCode: String, name: String, surname: String)
#case class Policy(policyId: String, description: String)
The first thing we need to do is to implement the uri method for the above two types. So, let’s implement the Searchable trait using anonymous classes:
#implicit val searchableCustomer: Searchable[Customer] = new Searchable[Customer] {
#  override def uri(customer: Customer): String = s"/customers/${customer.taxCode}"
#}
#implicit val searchablePolicy: Searchable[Policy] = new Searchable[Policy] {
#  override def uri(policy: Policy): String = s"/policies/${policy.policyId}"
#}

#def searchWithImplicit[S](obj: S)(implicit searchable: Searchable[S]): String = searchable.uri(obj)
Due to the compiler’s implicit resolution, the searchWithImplicit method’s behavior will be polymorphic because it will change according to the resolved instance of the type class.
If we invoke the method using a Customer, the compiler resolves the type class using the variable searchableCustomer, using the variable searchablePolicy otherwise.

__Вариант 2__
Scala introduces the so-called “context-bound” on types from version 2.8. Basically, it’s a constraint that must be true on a type T, and we can view its syntax in a variant of our searchWithImplicit function:
#def searchWithContextBound[S: Searchable](obj: S): String

As we can notice, the context-bound is on type S and tells the compiler that a type Searchable[S] must exist.
Since, due to the context-bound, we know for sure that a type Searchable[S] is available in the body of the parametric function, we can now use the implicitly function to retrieve it:
#def searchWithContextBound[S: Searchable](obj: S): String = {
#  val searchable = implicitly[Searchable[S]]
#  searchable.uri(obj)
#}
As we can see, the signature of the searchWithContextBound function is now cleaner than the signature of the searchWithImplicit function since it exposes only the business parameters, completely hiding the type class and the implicit resolution mechanism.

Summing up, the type classes pattern allows us to have two different implementations of the searchWithContextBound function, one for the Customer type and one for the Policy type:
#val customer = Customer("123456", "Will", "Smith")
#val uri = searchWithContextBound(customer)
#assert(uri == "/customers/123456")

#val policy = Policy("09876", "A policy")
#val uri = searchWithContextBound(policy)
#assert(uri == "/policies/09876")

* для неявных классов
Неявные классы были добавлены в Scala 2.10 с целью облегчить создание обо­гащающих классов-оболочек. Неявным называется класс, перед определением которого ставится ключевое слово implicit. Для любого такого класса компилятор создает неявное преобразование из параметра конструктора класса в сам класс.
В качестве неявного нельзя использовать case-класс, и его конструк­тор может иметь только один параметр. Кроме того, неявный класс должен раз­мещаться внутри какого-либо другого объекта — класса или трейта.
Пример:
Предположим, к примеру, что имеется класс по имени Rectangle для представ­ления ширины и высоты прямоугольника на экране: 
#case class Rectangle(width: Int, height: Int) 
Может возникнуть желание прибегнуть к паттерну обогащающей оболочки, чтобы упростить представление при весьма частом использовании этого класса. Один из способов решения данной задачи выглядит так: 
#implicit class RectangleMaker(width: Int) { def x(height: Int) = Rectangle(width, height) } 
Этот код дополнительно вызывает автоматическое создание следующего преоб­разования (см. выше неявное преобразование типов): 
#implicit def RectangleMaker(width: Int) = new RectangleMaker(width)  // Создается автоматически 
В результате можно создавать точки, помещая x между двумя целочисленными значениями: 
#scala> val myRectangle = 3 x 4 
#	myRectangle: Rectangle = Rectangle(3,4)

* для неявных параметров
__Все__ параметры, объявленные __после__ ключевого слова implicit, являются имплиситными. 


##Синтаксис заместителя
#scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
_ > 0 — очень краткая форма записи для функции, про­веряющей, что значение больше нуля: 
#scala> someNumbers.filter(_ > 0) 
#res7: List[Int] = List(5, 10). 
Знак подчеркивания можно рассматривать как бланк, который следует запол­нить. Он будет заполнен аргументом функции при каждом ее вызове. Например, при условии, что переменная someNumbers была здесь инициализирована значением List(-11, -10, -5, 0, 5, 10), метод filter заменит бланк в _ > 0 сначала значени­ем -11, получив -11 > 0, затем значением -10, получив -10 > 0, затем значением -5, получив -5 > 0, и так далее до конца списка List. Таким образом, функциональный литерал _ > 0 является, как здесь показано, эквивалентом немного более простран­ного литерала x => x > 0: 
#scala> someNumbers.filter(x => x > 0)

##ТРЕЙТЫ##
__Трейты__в Scala являются фундаментальными повторно используемыми блоками кода. В трейте инкапсулируются определения тех методов и полей, которые затем могут повторно использоваться путем их примешивания в классы. В отличие от наследования классов, в котором каждый класс должен быть наследником только одного суперкласса, __в класс может примешиваться любое количество трейтов__.
#trait Philosophical { 
#	def philosophize() = { println("На меня тратится память, следовательно, я существую!") } 
#}
После того как трейт определен, он может быть __примешан__ в класс с помощью ключевого слова: __либо extends, либо with__.
Если нужно примешать трейт в класс, который явно расширяет суперкласс, то ключевое слово extends используется для указания суперкласса, а для примеши­ вания трейта — ключевое слово with. Если нужно примешать сразу __несколько трейтов__, то дополнительные трейты указываются с помощью ключевого слова with.
#class Frog extends Animal with Philosophical with HasLegs { override def toString = "зеленая" }

В трейтах можно объявлять поля и сохранять состояние. Фактически в определении трейта можно делать то же самое, что и в определении класса, и син­таксис выглядит почти так же, но с двумя __исключениями__:
1. В трейте __не может быть__ никаких присущих классу __параме­тров__ (то есть параметров, передаваемых __первичному конструктору__ класса). Иными словами, хотя у вас есть возможность определить класс таким вот образом: 
#class Point(x: Int, y: Int) 
следующая попытка определить трейт окажется неудачной: 
#trait NoPoint(x: Int, y: Int) // Не пройдет компиляцию 
2. В __классах__ вызовы __super__ имеют __статическую__ привязку, а в __трейтах — динамическую__. Если в __классе__ воспользоваться кодом super.toString, то вы будете __точно знать__, какая именно реа­лизация метода будет вызвана. Но когда точно такой же код применяется в __трейте__, то вызываемая с помощью super реализация метода при определении трейта __еще не определена__. Вызываемая реализация станет определяться __заново при каждом примешивании__ трейта в конкретный класс. Такое своеобразное поведение super является ключевым фактором, позволяющим трейтам работать в качестве наращиваемых модификаций.

При примешивании трейт может требовать указания __параметра типа__.
#class Rational(n: Int, d: Int) extends Ordered[Rational]

Трейты используются также для __наращиваемых модификаций__
#trait Doubling extends IntQueue { // Можно примешивать только к классам extends IntQueue
#	abstract override def put(x: Int) = { super.put(2 * x) } 
#}

Если трейт должен быть __обязательно примешан к классу с другим трейтом__ и это нужно проверить во время компиляции используется конструкция __self type__:
# trait Person
# trait Diet { this: Person => // вместо this может быть какой-нибудь другой идентификатор
# // какая-то имплементация, включающая this, если this не будет использоваться - можно использовать "_"
#}
Теперь нельзя примешать трейт Diet к какому либо классу без примешивания трейта Person

Ключевые особенности примешивания трейтов:
1. Объявлен суперкласс
Если в трейте объявлен __суперкласс__ - этот трейт может быть примешан __только в класс, расширяющий__ этот суперкласс.

2. Имеется __вызов super__ в отношении метода, который объявлен __абстрактным__
В трейте вызовы super динамически связаны, поэтому вызов super в трейте Doubling будет работать при условии, что трейт примешан __после другого трейта__ или класса, в котором дается __конкретное определение метода.__Чтобы сообщить компилятору, что это делается намеренно, подобные методы следует помечать модификаторами __abstract override__. Это со­четание модификаторов позволительно __только для членов трейтов__, но не классов, и означает, что трейт должен быть примешан в некий __класс, имеющий конкретное определение рассматриваемого метода__.
Располагая __несколькими__ модифицирующими трейтами, можно выбрать, какой из них вам понадобится для той или иной очереди. 
__Порядок примешивания играет существенную роль__. Грубо говоря, трейт, находящийся __правее__, вступает в силу __первым__. Когда метод вызывается в отношении экземпляра класса с примешанными трейтами, первым вызывается тот метод, который определен в самом правом трейте. Если этот метод выполняет вызов __super__, то вызывается метод, который определен __в следующем трейте левее данного трейта__, и т.д.

При реализации набора __повторно используемого поведения__ придется решать, к чему прибегнуть: трейту или абстрактному классу. Золотого правила не суще­ ствует, но в этом разделе содержатся несколько __полезных рекомендаций__, к которым стоит прислушаться:
* Если поведение __не будет повторно__ использовано, то создавайте __конкретный класс__, поскольку в нем вообще нет повторно используемого поведения. 
* Если поведение может быть __повторно__ использовано различными __неродственными__ классами, то создайте __трейт__. Только трейты могут примешиваться в раз­личные части иерархии классов. 
* Если хотите __наследовать__ поведение в коде __Java__, то задействуйте __абстрактный класс__.
* Если планируется __распространение кода в скомпилированном виде__ и ожида­ется, что сторонние группы разработчиков станут создавать классы, что-либо __наследующие__ из него, то следует предпочесть __абстрактные классы__. Проблема в том, что при появлении в трейте нового элемента или удалении из него старого элемента все классы, являющиеся его наследниками, должны быть перекомпи­лированы, даже если в них не было никаких изменений. Если сторонние клиен­ты будут только вызывать поведение, а не наследовать его, то с использованием трейта не будет никаких проблем. 
* Если вы __не пришли к решению__ даже после того, как взвесили все ранее предоставленные рекомендации, то __начните с создания трейта__. Позже вы всегда сможете его изменить, а в целом использование трейта предоставляет вам больше возможностей.

##CASE-классы##
Классы c модификатором case называются case-классами. Все данные сase-классов являются __неизменяемыми__.
Использование этого модификатора заставляет компилятор Scala добавлять к вашему классу некоторые синтаксиче­ские удобства. 
* Первое синтаксическое удобство заключается в том, что к классу __добавляется фабричный метод с именем данного класса__. Это означает, к примеру, что для соз­дания объекта класса Var можно применить код Var("x"), не используя несколько более длинный вариант new Var("x"): 
#scala> val v = Var("x") v: Var = Var(x) 
Особенно полезны фабричные методы благодаря их вложенности. Теперь код не загроможден ключевыми словами new, поэтому структуру выражения можно воспринять с одного взгляда: 
#scala> val op = BinOp("+", Number(1), v) 
#op: BinOp = BinOp(+,Number(1.0),Var(x)) 
* Второе синтаксическое удобство заключается в том, что __все аргументы в списке параметров__ case-класса автоматически получают префикс val, то есть __сохраняются в качестве полей__: 
#scala> v.name res0: String = x
* Третье удобство состоит в том, что компилятор __добавляет__ к вашему классу «естественную» реализацию методов __toString, hashCode и equals__. Они будут за­ниматься подготовкой данных к выводу, их хешированием и сравнением всего дерева, состоящего из класса, и (рекурсивно) всех его аргументов. Поскольку метод == в Scala всегда передает полномочия методу equals, то это значит, что __элементы case-классов всегда сравниваются структурно__:
#scala> println(op) BinOp(+,Number(1.0),Var(x)) 
#scala> op.right == Var("x") 
#res3: Boolean = true
* И наконец, чтобы создать измененные копии, компилятор __добавляет__ к вашему классу метод __copy__. Он пригодится для создания нового экземпляра класса, анало­гичного другому экземпляру, за исключением того, что будет отличаться одним или двумя атрибутами. Метод работает за счет использования именованных па­ раметров и параметров по умолчанию. Применение именованных параметров позволяет указать требуемые изменения. А для любого неуказанного параметра используется значение из старого объекта. Посмотрим в качестве при­мера, как можно создать операцию, похожую на op во всем, кроме того, что будет изменен параметр operator: 
#scala> op.copy(operator = "-") 
#res4: BinOp = BinOp(-,Number(1.0),Var(x))
* Но самым большим преимуществом case-классов является то, что они поддерживают __сопоставления с образцом__.

##Сопоставление с образцом##
Пример:
#expr match { 
#	case BinOp(op, left, right) => println(s"$expr является бинарной операцией") 
#	case _ => // обработка общего варианта 
#}
* __Подстановочный паттерн (_)__ соответствует абсолютно любому объекту. Он может использоваться в качестве общего паттерна, выявляющего все остав­ шиеся альтернативы. Кроме того, подстановочные паттерны могут использоваться для __игнорирования__ тех частей объекта, которые не представляют для вас интереса.
* __Паттерн-константа__ соответствует только самому себе. В качестве константы может использоваться любой литерал. Например, паттернами-константами являются 5, true и "hello". В качестве константы может использоваться и любой val- или объект-одиночка. Так, объект-одиночка Nil является паттерном, соответствующим только пустому списку.
#def describe(x: Any) = x match { 
#	case 5 => "пять" 
#	case true => "правда" 
#	case "hello" => "привет!" 
#	case Nil => "пустой список" 
#	case _ => "что-то другое" 
#}
* __Паттерн-переменная__ соответствует любому объекту точно так же, как подстано­вочный паттерн, но в отличие от него Scala привязывает переменную к объекту. Затем с помощью этой переменной можно в дальнейшем воздействовать на объект.
#expr match { 
#	case 0 => "нуль" 
#	case somethingElse => "не нуль: " + somethingElse 
#}
* __Паттерн-конструктор__ выглядит как BinOp("+", e, Number(0)). Он со­ стоит из имени (BinOp), после которого в круглых скобках стоят несколько об­ разцов: "+", e и Number(0). При условии, что имя обозначает case-класс, такой паттерн показывает следующее: сначала проверяется принадлежность элемента к названному case-классу, а затем соответствие параметров конструктора объекта предоставленным дополнительным паттернам.
В паттернах Scala поддержива­ются __глубкие сопоставления (deep matches)__. Такие паттерны проверяют не только предоставленный объект верхнего уровня, но и его содержимое на соответствие следующим паттернам. Дополнительные паттерны сами по себе могут быть пат­тернами-конструкторами, поэтому их можно использовать для проверки объекта произвольной глубины. 
#expr match { 
#	case BinOp("+", e, Number(0)) => println("глубокое соответствие") 
#	case _ => 
#}
Паттерн, показанный в примере, проверяет, что объект верхнего уровня относится к типу BinOp, третьим параметром его кон­структора является число Number и значение поля этого числа — 0. Весь паттерн умещается в одну строку кода, хотя выполняет проверку на глубину в три уровня.
* По аналогии с сопоставлением с case-классами можно сопоставлять с такими ти­пами __последовательностей__, как List или Array. Допустимо воспользоваться тем же синтаксисом, но теперь в паттерне вы можете указать любое количество элементов. 
#expr match { 
#case List(0, _, _) => println("соответствие найдено") 
#case _ => 
#}
В примере показан паттерн для проверки того факта, что трехэлементный список начинается с нуля. 
Если нужно сопоставить с последовательностью, __не указывая ее длину__, то в качестве последнего элемента паттерна-последовательности можно указать образец __*. Он соответствует __любому количеству элементов__ внутри последовательности, включая нуль элементов. 
#expr match { 
#	case List(0, _*) => println("соответствие найдено ") 
#	case _ => }
Пример соответствует любому списку, который начинается с нуля, независимо от длины этого списка.
* Сопоставление с образцом с использованием __паттерна-кортежа__ 
#def tupleDemo(expr: Any) = expr match { 
#	case (a, b, c) => println("соответствует " + a + b + c) 
#	case _ => 
#}
* __Типизированный паттерн__ (typed pattern) можно использовать в качестве удобного заменителя для проверок типов и приведения типов. 
#def generalSize(x: Any) = x match { 
#	case s: String => s.length 
#	case m: Map[_, _] => m.size 
#	case _ => -1 
#}
Кроме использования отдельно взятого паттерна-переменной можно также до­бавить переменную к любому другому паттерну. Нужно просто указать имя пере­ менной, знак «собачка» (@), а затем паттерн. Это даст вам паттерн с привязанной переменной, то есть паттерн для выполнения обычного сопоставления с образцом с возможностью в случае совпадения присвоить переменной соответствующий объект, как и при использовании обычного паттерна-переменной.
#expr match { 
#	case UnOp("abs", e @ UnOp("abs", _)) => e 
#	case _ => 
#} 
Пример, показанный в данном листинге, включает паттерн с привязкой перемен­ной, где в качестве переменной выступает e, а в качестве паттерна — UnOp("abs", _). Если будет найдено соответствие всему паттерну, то часть, которая соответствует UnOp("abs", _), станет доступна как значение переменной e. Результатом вариан­ та будет просто e, поскольку у e такое же значение, что и у expr, но с меньшим на единицу количеством операций получения абсолютного значения.
* __Ограждение паттерна__ указывается после образца и начинается с ключевого слова if. В качестве ограждения может использоваться произвольное булево выражение, которое обычно ссылается на переменные в образце. При наличии ограждения паттернов соответствие считается найденным, только если огражде­ние вычисляется в true. Таким образом, первый вариант показанного ранее кода соответствует только бинарным операциям, имеющим два одинаковых операнда.
// соответствует только положительным целым числам 
#	case n: Int if 0 < n => ... 
// соответствует только строкам, начинающимся с буквы 'a' 
#	case s: String if s(0) == 'a' => ...
__Паттерны применяются в порядке их указания.__
__Варианты «поймать все» следуют после более конкретизированных правил упрощения.__ Если располо­жить их в другом порядке, то вариант «поймать все» будет запущен вместо более конкретизированных правил. Во многих случаях компилятор будет жаловаться на такие попытки.
Если создается иерархия классов, предназначенная для сопоставления с об­разцом, то нужно предусмотреть ее __запечатанность__.
Если матчится лямбда с __единственным__ параметром, выражение x => x match можно опустить, сразу записав __первым__ оператором в фигурных скобках __case__ т.е.
#for (x <- lst) { x => 
#	x match {
# case...
эквивалентно
#for (x <- lst) {
#case...

##Запечатанные классы
У __запечатанного__ класса не может быть никаких до­ полнительных подклассов, кроме тех, которые определены в том же самом файле. Особую пользу из этого можно извлечь при сопоставлении с образцом, поскольку запечатанность класса будет означать, что беспокоиться придется только по по­ воду тех подклассов, о которых вам уже известно. Более того, будет улучшена поддержка со стороны компилятора. При сопоставлении с образцом case-классам, являющимся наследниками запечатанного класса, компилятор в предупреждении отметит пропущенные комбинации паттернов. Если создается иерархия классов, предназначенная __для сопоставления с образцом__, то __нужно__ предусмотреть ее запечатанность. Чтобы это сделать, просто поставьте перед классом на вершине иерархии ключевое слово __sealed__.
__Запечатанные трейты__ - аналогично.

###Параметризация типов
Параметризация типов позволяет создавать обобщенные классы и трейты. Например, множества имеют обобщенный характер и получают параметр типа: они определяются как Set[T]. В результате любой отдельно взятый экземпляр множе­ства может иметь тип Set[String], Set[Int] и т. д., но должен быть множеством чего-либо. В отличие от языка __Java__, в котором __разрешено использовать сырые типы__ (raw types), __Scala требует указывать параметры типа__. Вариантность определяет взаимоотношения наследования параметризованных типов, к примеру таких, при которых Set[String] является подтипом Set[AnyRef].
__T*__ — форма записи для повторяющихся параметров.

Если S — подтип T и Constructor[S] рассматривается как подтип Constructor[T], можно сказать, что трейт Constructor __ковариантный__ в своем параметре типа T, то есть можно передать, например, Constructor[String] методу, который принимает параметр значения типа Constructor[AnyRef].
Полу­чить __ковариантность__ подтипизации можно следующим определением Constructor: 
#trait Constructor[+T] { ... }
Помимо префикса +, существует префикс -, который показывает __контравариантность__ подтипизации. Если определение Constructor имеет вид: 
#trait Constructor[-T] { ... } 
и если тип T — подтип типа S, то это будет означать, что Constructor[S] — подтип Constructor[T]
По умолчанию в Scala у обобщенных типов изначально имеется __нонвариантная__ (или жесткая) подтипизация, то есть если тип T — подтип типа S, то тип
Constructor[S] __не связан отношением типизации__ с Constructor[T].
__Ограничение типизации__:  с помощью синтаксиса __U >: T__ тип T определяется как __нижний ограничитель__ для U. В результате от типа U требуется, чтобы он был __супертипом__ для T.
Отношения супертипов и подтипов рефлексивны. Это значит, тип является одновремен­но супертипом и подтипом по отношению к себе. Даже притом, что T — нижняя граница для U, T все же можно передавать методу, принимающему U.

##ФУНКЦИИ##
Поскольку JVM не предусматривает штук из истинных функциональных языков (функции первого класса, функции высших типов, например) в Scala реализован особый механизм:
Группа классов Function1..Function22 позволяет определить функциональные объекты следующим образом:
# val myFunc = new Function1[String, String] {
#	override def apply(arg1: String): String = "Привет" + arg1
#}
или, используя синтаксический сахар,
# val myFunc: String => String = (arg1: String) => "Привет" + arg1
или, пользуясь выводом типов компилятора, еще короче
# val myFunc = (arg1: String) => "Привет" + arg1
Пример функции высших типов:
# valaMappedList = List(1,2,3).map(x => x + 1)
где x => x + 1 - анонимная функция (лямбда)

Тело функции можно вызывать как в () так и в {}.
#def add(b: Byte): Unit = { 
#	sum += b 
#}

В Scala при вызове метода пустые круглые скобки можно не ставить. Соглашение гласит, что __круглые скобки__ ставятся в том случае, если метод __имеет побочные эффекты__, как в случае с методом println(). Но их можно не ставить, если метод не имеет побочных эффектов, напримр как в случае с методом toLowerCase.
__Вызов параметров по имени__ - это когда значение параметра вычисляется __только в момент вызова параметра__. Этот способ противоположен __вызову по значению__. Преимущество __вызова параметров по имени__ заключается в том, что они __не вычисляются если не используются__ в теле функции. С другой стороны плюсы вызова параметров по значению в том, что они вычисляются только один раз.
Т.е. в случае вызова по имени параметр вычисляется __лениво__. Механизм вызова по имени передает блок кода вызывающему и __каждый раз__, когда вызывающий __обращается к параметру__, блок кода исполняется и значение __рассчитывается заново.__
Синтаксис:
#def callByValue(x: Int) = {
#}
#def callByName(x: => Int) = {
#}
#def whileLoop(condition: => Boolean)(body: => Unit): Unit =
#  if (condition) {
#    body
#    whileLoop(condition)(body)
#  }
Метод whileLoop использует несколько списков параметров - условие и тело цикла. Если condition является верным, выполняется body, а затем выполняется рекурсивный вызов whileLoop. Если condition является ложным, то body никогда не вычисляется, тк у нас стоит => перед типом body.
#var i = 2
#whileLoop (i > 0) {
#  println(i)
#  i -= 1
#}  // выведет 2 1
Теперь, когда мы передаем i > 0 как наше условие condition и println(i); i-= 1 как тело body, код ведет себя также как обычный цикл в большинстве языков программирования.

Lazy val - объявление переменной, значение которой будет вычислено __в момент первого обращения__ к ней.
#import java.time.Instant
#lazy val lazyCurrent = Instant.now 
#Thread.sleep(1000)	
#println(s"Значение переменной  = $lazyCurrent ") 

В лямбда функциях можно заменить каждый параметр на подчеркивание __строго 1:1__:
# _ + 5  // x=>x+5
#_ + _ //(x,y) => x+y
каждое подчеркивание обозначает __разный__ параметр в порядке их передачи в лямбду.

__Частичное применение функции__ - замена при вызове одного или нескольких параметров символом "_".
# def foo (a: Int, b: Int) : Int = a + b
# val f = foo(4 , _) //Частичное применение		
# println(f(5) //Вернет 9 (4 + 5)
Можно заменять не только последние параметры

В случае возврата функции как результата происходит захват контекста __(замыкание)__- захватываются параметры и внутренние переменные. Если внутренняя переменная изменяет свой результат - это происходит в __общем__ контексте функции и поэтому ее изменение отражается __при каждом вызове функции__:
# def make_counter( init:Int): () => Int = {
#		var counter = init
#		() => { 
#						counter += 1
#						counter
#		}
# }
# var c1 = make_counter(init = 10)
# println(c1)
# println(c1)
# println(c1)
Результат:
11
12
13

Аннотация @tailrec говорит компилятору, что в следующей за ним рекурсивной функции следует заменить хвостовую рекурсию на цикл. Если эта оптимизация невозможна компилятор выдаст ошибку.

__Каррирование__ в Scala выражается как несколько списков аргументов функции, содержащих по одному аргументу каждый.
Например:
#scala> def curriedSum(x: Int)(y: Int) = x + y 
#curriedSum: (x: Int)(y: Int)Int 
#scala> curriedSum(1)(2) 
#res5: Int = 3 
Здесь при вызове curriedSum вы фактически получаете два обычных вызова функции, следующие непосредственно друг за другом. Первый получает единствен­ный параметр Int по имени x и возвращает функциональное значение для второй функции. А та получает Int-параметр y. 

Если в Scala при каждом вызове метода ему передается __строго один аргумент__, то можно заключить его не в круглые, а __в фигурные скобки__. Это, например, используется для передачи функционального аргумента вторым параметром в каррированную функцию. 
Пример. Применение шаблона временного пользования для записи в файл 
#def withPrintWriter(file: File)(op: PrintWriter => Unit) = { 
#	val writer = new PrintWriter(file) 
#	try { 
#		op(writer) 
#	} finally { 
#		writer.close() 
#	} 
#}

Таким образом, метод можно вызвать с по­мощью более привлекательного синтаксиса: 
#val file = new File("date.txt") 
#withPrintWriter(file) { writer => 
#	writer.println(new java.util.Date) 
#} 
В этом примере первый список аргументов, в котором содержится один аргу­мент типа File, заключен в круглые скобки. А второй список аргументов, содержащий функциональный аргумент, заключен в фигурные скобки.


__Важные функции высших типов__:
__map__
__flatMap__ (принимает в качестве аргумента функцию из простого типа в параметризированный тип)
__filter__
Можно chaining. Для более читабельного чейнинга используется __for compehensions__.


##FOR COMPREHENSIONS
В общем выражение for выглядит так: __for ( seq ) yield expr__ где seq — последовательность из генераторов, определений и фильтров с точками с за­пятой между стоящими друг за другом элементами. В случае __наличия yield__ выражение транслируется в применение __flatmap__ (последняя стрелка заменяется на __map__). Выражение for показано в ниже:
#for { 
#	p <- persons // генератор 
#	n = p.name // определение 
#	if (n startsWith "To") // фильтр 
#} yield n

Если добавить несколько генераторов <-, то будут получены вложенные циклы. Последующие генераторы изменяются быстрее предыдущих. Это легко проверить с помощью следующего простого теста: 
#scala> for (x <- List(1, 2); y <- List("one", "two")) yield (x, y) 
#res3: List[(Int, String)] = List((1,one), (1,two), (2,one), (2,two))

Иногда перебирать коллекцию целиком не нужно, а требуется отфильтровать ее в некое подмножество. В выражении for это можно сделать путем добавления __фильтра в виде условия if__, указанного в выражении for внутри круглых скобок.

Привязка значения промежуточной переменной выполняется с помощью знака равенства (=). Связанная переменная вводится и используется точно так же, как и val-переменная, но ключевое слово val не ставится. Пример:
#for {
#	...
#	trimmed = line.trim 
#	if trimmed.matches(pattern)
#	...
#}

Для сохранения результата работы for используется __yield__
#def scalaFiles = for { 
#	file <- filesHere 
#	if file.getName.endsWith(".scala") 
#} yield file 
При каждом выполнении тела выражения for создается одно значение, в дан­ном случае это просто file. Когда выполнение выражения for завершится, резуль­тат будет включать все выданные значения, содержащиеся в единой коллекции. Тип получающейся коллекции задается на основе вида коллекции, обрабатываемой операторами итерации. В данном случае результат будет иметь тип Array[File], поскольку filesHere является массивом, а выдаваемые выражением значения от­ носятся к типу File.

В случае, если __yield__ отсутствует, выражение:
#for (x <- expr1) body 
транслируется в применение __foreach__: 
#expr1 foreach ( x => body)
Например, следующее выражение, суммирующее все элементы матрицы, представ­ленной в виде списка списков List[List[Int]]:
#var sum = 0 for (xs <- xss; x <- xs) sum += x
транслируется в:
#var sum = 0 xss 
#foreach (xs => 
#							xs foreach (x => 
#														sum += x))

Пример использования __for__ вместо __map, flatmap и filter__:
#object Demo { 
#	def map[A, B](xs: List[A], f: A => B): List[B] = 
#		for (x <- xs) yield f(x) 
#	def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] = 
#		for (x <- xs; y <- f(x)) yield y 
#	def filter[A](xs: List[A], p: A => Boolean): List[A] = 
#		for (x <- xs if p(x)) yield x 
#}


##КОЛЛЕКЦИИ##
__Все простые коллекции по умолчанию иммутабельны__. Все операции над коллекцией возвращают новый экземпляр коллекции.
На вершине иерархии коллекций находится трейт Iterable[A], где A — тип эле­ментов коллекции.

В иерархии наследования ниже Iterable находятся три трейта: Seq, Set и Map.

Для последовательностей apply — позиционное индексирование, в котором элементы всегда нумеруются с нуля. То есть 
#Seq(1, 2, 3)(1) == 2. 
Для множеств apply — проверка на принадлежность. Например, 
#Set('a', 'b', 'c')('b') == true
#Set()('a') == false. 
И наконец, для отображений apply — средство выбора. Например, 
#Map('a' ‑> 1, 'b' -> 10, 'c' -> 100)('b') == 10.

##ПОСЛЕДОВАТЕЛЬНОСТИ
* Класс __Seq__ - упорядоченная коллекция - родитель для всех коллекций
# val aSeq = Seq(1,2,3)
Позволяет доступ к элементу по индексу
# val aElem = aSeq(1) // вернет элемент по индексу 1 т.е. 2 (коллекции индексируются с 0)
Метод __updated__ возвращает новую коллекцию с измененным элементом по индексу:
# val aChangedSeq = aSeq.updated(1,5) // (1,5,3)
Другие методы (:
reverse
++ - добавляет Seq к Seq
sorted - сортирует коллекцию
foldLeft - свертка коллекции
mkString - преобразование в строку с разделителями
	Метод __flatMap__ для коллекций в качестве правого операнда получает функ­цию, возвращающую список элементов. Он применяет функцию к каждому эле­менту коллекции и возвращает конкатенацию всех результатов выполнения функции. Разница между map и flatMap для коллекции показана в следующем примере: 
#scala> words map (_.toList) 
#res35: List[List[Char]] = List(List(t, h, e), List(q, u, i, c, k), List(b, r, o, w, n), List(f, o, x)) 
#scala> words flatMap (_.toList) 
#res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x) 
Там, где map возвращает список списков, flatMap возвращает единый список, в котором все элементы списков сконкатенированы.
	Третья map-подобная операция — __foreach__. Но, в отличие от map и flatMap, она получает в качестве правого операнда процедуру (функцию, результирующим типом которой является Unit). Она просто применяет процедуру к каждому эле­менту списка. А сам результат операции также имеет тип Unit, то есть никакого результирующего списка не будет. В качестве примера рассмотрим краткий способ суммирования всех чисел списка: 
#scala> var sum = 0 sum: Int = 0 scala> List(1, 2, 3, 4, 5) foreach (sum += _)
#scala> sum 
#res39: Int = 15
__Фильтрация коллекций: filter, partition, find, takeWhile, dropWhile и span__
	Метод xs filter p получает в качестве операндов коллекцию xs типа Seq[T] и функцию-предикат p типа T => Boolean. Эта операция выдает список всех элемен­тов x из коллекции xs, для которых p(x) вычисляется в true.
__Применение предикатов к коллекциям: forall и exists__ 
	Метод xs __forall__ p получает в качестве аргументов коллекцию xs и предикат p. Она возвращает результат true, если __все__ элементы списка удовлетворяют условию пре­диката p. Напротив, операция xs __exists__ p возвращает true, если в xs есть __хотя бы один__ элемент, удовлетворяющий условию предиката p.
	Метод __fill__ заполняет коллекцию указанными значениями (во втором списке аргументов принимает лямбду)
# val aSeq = Seq.fill(5)(5)
Метод __collect__ объединяет методы map и filter. На вход - коллекция и операция, далее паттернматчинг.

* Класс __List__ - реализация __Seq__
# val aList = List(1,2,3)
	Инфиксный оператор конструирования :: обозначает расширение списка __с начала__. То есть запись x :: xs представляет собой список, первым элементом ко­ торого является x, за которым следует список xs (его элементы).
# val aNewList = 0 :: aList // List(0,1,2,3)
	Операцией, похожей на ::, является конкатенация списков, записываемая в виде :::. В отличие от операции :: операция ::: получает в качестве опе­рандов два списка. Результатом выполнения кода xs ::: ys выступает новый список, содержащий все элементы списка xs, за которыми следуют все элементы списка ys.
	Функции +: и :+  добавляют элемент к коллекции и коллекцию к элементу соответственно.
# val aNewList2 = 0 +: aList :+ 4 // List(0,1,2,3,4)

* Класс __Vector__ - быстрый Seq для больших объемов данных (гораздо быстрее индексный поиск, чем в Seq или List)
# val aVector = Vector(1,2,3)

##МНОЖЕСТВА
* Класс __Set__ - отсутствие дубликатов в коллекции
# val aSet = Set(1,2,3,3,4,2) // Set(1,2,3,4)
Порядок элементов не имеет значения
Самый важный метод - проверка наличия элемента:
# val aSetHas = aSet.contains(5) // false
Можно добавлять и удалять элементы:
# val anAddedSet = aSet + 5 // Set(1,2,3,4,5)
# val aRemovedSet = aSet - 3 // Set(1,2,4)
Можно объединять коллекции:
# val aPlusSet = aSet.union(aRemovedSet)
# val aPlusSet = aSet ++ aRemovedSet /то же
# val aPlusSet = aSet | aRemovedSet /то же
Можно находить различия в 2 коллекциях
# val aDiffSet = aSet.diff(aRemovedSet)
# val aDiffSet = aSet -- aRemovedSet /то же
Можно находить пересечения
# val aIntersectSet = aSet.intersect(aRemovedSet)
# val aIntersectSet = aSet.& aRemovedSet

* Диапазоны (__ranges__)
# val aRange = 1 to 1000 - включает последний элемент
# val aNonInclusiveRange = 1 until 1000 - не включает последний элемент
Могут быть не заполненными элементами, но позволяют работать с ними 
# val twoByTwo = aRange.map(x => 2 * x).toList // List(2,4,6,8,...,2000) 
Можно приводить к разным коллекциям: toList, toSeq, toVector, toSet ...

* Кортежи (__tuples__)
# val aTuple = (1,true,"Do")

##ОТОБРАЖЕНИЯ
* Класс __Map__ - ассоциативные массивы (maps)
# val aPhoneBook: Map[String, Int] {
# ("John", 124456) 
# Sara -> 876543 // эквивалентно предыдущей строке
#}

##МАССИВЫ
Массивы в Scala — особая разновидность коллекции. С одной стороны, массивы Scala в точности соответствуют массивам Java. То есть Scala-массив Array[Int] пред­ ставлен как Java-массив int[], Array[Double] — как double[], а Array[String] — как String[]. Но вместе с тем массивы Scala предоставляют гораздо больше, чем их Java-аналоги. Во-первых, массивы Scala могут быть обобщенными. То есть можно воспользоваться массивом Array[T], где T является параметром типа или абстракт­ным типом. Во-вторых, массивы Scala совместимы со Scala-последовательностями, то есть туда, где требуется Seq[T], можно передавать Array[T]. И наконец, массивы Scala также поддерживают все операции с последовательностями.

##СТРОКИ
Как и массивы, строки не являются последовательностями в прямом смысле сло­ ва, но могут быть в них преобразованы и вдобавок поддерживают все операции с последовательностями.

##ПРЕДСТАВЛЕНИЯ
По умолчанию коллекции в Scala — строгие во всех своих проявлениях, за ис­ключением LazyList, в котором все методы преобразования реализованы лениво. 
Представление — это особая разновидность коллекции, которая изображает какую-либо основную коллекцию, но реализует все ее преобразователи лениво. 
Для перехода от коллекции к ее представлению можно воспользоваться в от­ношении коллекции методом view. Если xs — некая коллекция, то __xs.view__ создает точно такую же коллекцию, но __с ленивой реализацией всех преобразователей__.
Перейти обратно от представления к строгой коллекции можно с помощью опера­ции приведения __to__ с фабрикой строгих коллекций в качестве параметра.
	В качестве примера рассмотрим задачу поиска первого палиндрома в списке слов. Палиндромом называется слово, которое читается в обратном порядке точно так же, как и в прямом. Необходимые для этого определения имеют следующий вид: 
#def isPalindrome(x: String) = x == x.reverse 
#def findPalindrome(s: Iterable[String]) = s find isPalindrome 
Теперь предположим, что имеется весьма длинная последовательность слов и нужно найти палиндром в первом ее миллионе слов. Можно ли повторно вос­ пользоваться определением findPalindrome? Разумеется, можно создать следу­ ющий код: 
#findPalindrome(words take 1000000) 
Он неплохо разделяет два аспекта, заключающихся в получении первого мил­лиона слов последовательности и поиска в них палиндрома. Но у этого решения есть недостаток: всегда будет создаваться промежуточная последовательность, со­cтоящая из миллиона слов, даже если первое ее слово уже является палиндромом. Следовательно, потенциально получается, что 999 999 слов копируется в про­межуточный результат, не подвергаясь последующей проверке. Многие програм­мисты откажутся от этого и напишут собственную специализированную версию поиска палиндрома в некоем заданном префиксе последовательности аргументов. Но с представлениями этого делать не придется. Нужно просто воспользоваться следующим кодом: 
#findPalindrome(words.view take 1000000)

Все коллекции начиная со Scala в версии 2.8, за исключением ленивых списков и представлений, являются __строгими__. 
Перейти от строгой коллекции к ленивой можно только через метод представления view. 
Единственный способ перейти обратно — применить метод to:
#res14.to(Vector)

##КЛАССЫ КАК ТИПЫ
Чтобы получить наибольшие преимущества от использования иерархии классов Scala, старайтесь для каждого понятия предметной области определять новый класс, несмотря на то что будет возможность повторно применять один и тот же класс для различных целей. Даже если он относится к так называемому крошечному (tiny) типу, не имеющему методов или полей, определение дополнительного класса поможет компилятору принести вам больше пользы.

В дополнение к встроенным __классам значений__ мож­но определять собственные. Как и экземпляры встроенных, экземпляры ваших классов значений будут, как правило, компилироваться в байт-код Java, который не задействует класс-оболочку. В том контексте, где нужна оболочка, например, при использовании обобщенного кода, значения будут упаковываться и распако­вываться автоматически. Классами значений можно сделать только вполне определенные классы. Чтобы класс стал классом значений, он должен иметь только один параметр и не должен иметь внутри ничего, кроме def-определений. Более того, класс значений не мо­жет расширяться никакими другими классами и в нем не могут переопределяться методы equals или hashCode. Чтобы определить класс значений, его нужно сделать подклассом класса AnyVal и поставить перед его единственным параметром префикс val . Пример класса значений выглядит так: 
# class Dollars(val amount: Int) extends AnyVal { 
#		override def toString() = "$" + amount 
# }

When you declare a class inside another class in Scala, you are saying that each instance of that class has such a subclass. In other words, there's no A.B class, but there are a1.B and a2.B classes, and they are __different__ classes.
If you did not understand that, look up path dependent types.
Now, # makes it possible for you to refer to such nested classes without restricting it to a particular instance. In other words, there's no A.B, but there's A#B, which means a B nested class of any instance of A.

__Развернуть__ значение экземпляра параметризированного класса __Option__ можно использовав метод __value__.

##Вариантности
Атрибуты класса __var__ всегда __инвариантны__, т.е. допускают только точный тип. Поэтому нельзя создавать класс с расширенной вариантностью и использовать переменные типа __var__.
Атрибуты класса __val__ - __ковариантны__.

Аргументы метода находятся в __контравариантной__ позиции, т.е. допускают только передачу аргумента типа, вышестоящего к типу класса. 
Пример:
#class Queue[+T] (private val leading: List[T], private val trailing: List[T] ) { 
#def enqueue[U >: T](x: U) = new Queue[U](leading, x :: trailing) // ... 
#} 
В определении enqueue дается параметр типа U, и с помощью синтаксиса U >: T тип T определяется как нижний ограничитель для U. В результате от типа U требуется, чтобы он был __супертипом__ для T. Теперь параметр для enqueue имеет тип U, а не T, а возвращаемое значение метода теперь не Queue[T], а Queue[U]. Предположим, есть класс Fruit , имеющий два подкласса: Apple и Orange . С новым определением класса Queue появилась возможность добавить Orange в Queue[Apple]. Результатом будет Queue[Fruit].

Типы возвращаемых значений методов всегда в __ковариантной__ позиции.

__Эта-расширение__ - преобразование метода в функцию
# def incrementMeth (x:Int): Int = x + 1 - метод, привязан к объекту, внутри которого создается
# val incrementFunc = (x:Int) => x + 1   - функция, не привязана ни к чему
Для метода не может быть использовано частичное применение
Чтобы преобразовать метод в функциональное значение нужно выполнить следующий вызов (добавить символ подчеркивания):
# val incrementF = incrementMeth _ //eta-expansion
Такая конструкция является синтаксическим сахаром для:
# val incrementFExplicit = (x: Int) => incrementMeth(x)
Другой вариант вызова для ета-преобразования:
# val incrementF2: Int => Int = incrementMeth
Например, в следующем случае происходит автоматическое применение ета-расширения к incrementMeth ввиду использования функционального контекста:
#List(1,2,3).map(incrementMeth) 

В случае ета-расширения для функции с 1 списком аргументов с несколькими аргументами получим __мультиаргументную__ функцию:
# def add(x:Int, y:Int) = x + y
# val addF = add _ // (x,y) => x+y
В случае ета-расширения для функции с несколькими списками аргументов с 1 аргументом в каждом списке получим __каррированную__ функцию: 
# def threeArgAdder(x:Int)(y:Int)(z:Int) = x + y + z
# val twoArgsRemaining  = threeArgAdder(2) _ // y => z => 2 + y + z
Таким образом для функции с несколькими списками аргументов символ _ заменяет не переданные аргументы - каррирование.

#ВЫСОКОУРОВНЕВЫЕ ТИПЫ
Scala types belong to kinds. Think of kinds as types of types.
Plain types like Int, String or your own non-generic classes belong to the value-level kind — the ones you can attach to values.
Generic types like List belong to what I called the level-1 kind — they take plain (level-0) types as type arguments.
Scala allows us to express higher-kinded types — generic types whose type arguments are also generic. I called this kind the level-2 kind.
Generic types can’t be attached to values on their own; they need the right type arguments (of inferior kinds) in place. For this reason, they’re called type constructors.

#TYPECLASSES
```
#trait Summable[T] {
#    def sumElements(list: List[T]): T
#}
#implicit object IntSummable extends Summable[Int] {
#    def sumElements(list: List[Int]): Int = list.sum
#}
#
#implicit object StringSummable extends Summable[String] {
#    def sumElements(list: List[String]): String = list.mkString("")
#}
#
#def processMyList[T](list: List[T])(implicit summable: Summable[T]): T =
#    summable.sumElements(list)

#processMyList(List(1,2,3)) // 6
#processMyList(List("Scala ", "is ", "awesome")) // "Scala is awesome"
#processMyList(List(true, true, false)) // COMPILE TIME ERROR
```

The behavior we’ve just implemented is called __“ad hoc polymorphism”__ because the sumElements ability is unlocked __only in the presence__ of an implicit instance of the trait which provides the method definition, right there when it’s called, hence the “ad hoc” name. “Polymorphism” because the implementations we can provide can obviously be __different for different types__, as we did with Int and String.
The trait Summable[T] itself is nothing special. However, when you __combine it__ with one/more __implicit instances__ of the trait - and in our case we IntSummable and StringSummable - we have a pattern, which we generally call a __“type class”__. This structure allows us to define specific implementations for certain types and not for others, in the “ad hoc polymorphic” style we did earlier.