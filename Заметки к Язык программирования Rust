у вас не может быть структуры, часть полей которой изменяется, а другая часть — нет:
Изменяемость структуры определяется при её связывании:
#struct Point {
#x: i32,
#y: i32,
#}
#let mut a = Point { x: 5, y: 6 };
#a.x = 10;
#let b = Point { x: 5, y: 6};
#b.x = 10; // error: cannot assign to immutable field `b.x`
Однако, используя Cell<T> , вы можете эмулировать изменяемость на уровне полей:
#use std::cell::Cell;
#Run
#struct Point {
#x: i32,
#y: Cell<i32>,
#}

Rust предоставляет возможность использовать синтаксис вызова метода с помощью ключевого слова impl:
#struct Circle {
#x: f64,
#y: f64,
#radius: f64,
#}

#impl Circle {
#fn area(&self) -> f64 {
#std::f64::consts::PI * (self.radius * self.radius)
#}
#}

#fn main() {
#let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
#println!("{}", c.area());
#}
По умолчанию следует использовать &self , также как следует предпочитать заимствование владению, а неизменные ссылки изменяемым.

__В Rust у вас или одно изменяемое заимствование, или несколько неизменяемых. Невозможно одновременно ввести изменяемое и неизменяемое заимствования (или несколько изменяемых).__ В безопасности памяти важно, чтобы должным образом освобождались ресурсы, а в потокобезопасности важно, чтобы в каждый момент времени только один поток имел право изменять переменную. Кроме того, в такой ситуации никакие другие потоки не будут ссылаться на устаревшее заимствование: для него возможна или запись, или совместный доступ, но не оба.
__Rust не поддерживает перегрузку методов, именованные аргументы или переменное количество аргументов.__

Обратите внимание, что статические методы вызываются с помощью синтаксиса: Struct::method() , а не
ref.method().

__Типаж (trait)__ - это набор методов, определённых для неизвестного типа: Self. Они могут получать доступ к другим методам, которые были объявлены в том же типаже.
Типажи могут быть реализованы для любых типов данных.
Типаж - это возможность объяснить компилятору, что __данный тип должен предоставлять определённую функциональность.__
#struct Circle {
#x: f64,
#y: f64,
#radius: f64,
#}

#trait HasArea {
#fn area(&self) -> f64;
#}

#impl HasArea for Circle {
#fn area(&self) -> f64 {
#std::f64::consts::PI * (self.radius * self.radius)
#}
#}
тело метода не определяется, а определяется только его сигнатура. Когда мы реализуем типаж, мы используем impl Trait for Item , а не просто impl Item. 
Можно добавить функциональность к стандартному типу.


Множественные ограничения по типажам:
fn foo<T: Clone + Debug>(x: T) {
x.clone();
println!("{:?}", x);
}

__Замыкания:__
let plus_two = |x| {
let mut result: i32 = x;
result += 1;
result += 1;
result
};
отличие от fn состоит в том, что для замыкания мы не должны указывать ни типы аргументов, которые оно принимает, ни тип возвращаемого им значения.

__Типажи-объекты__, такие как &Foo или Box<Foo> , это __обычные переменные, хранящие значения любого типа, реализующего данный типаж__. Конкретный тип
типажа-объекта может быть определен только на этапе выполнения. Типаж-объект может быть получен __из указателя на конкретный тип__, который реализует
этот типаж, путем его явного приведения (например, &x as &Foo ) или неявного приведения (например, используя &x в качестве аргумента функции, которая принимает &Foo ).
Примеры:
явное приведение типа:
#fn do_something(x: &Foo) {
#x.method();
#}
#fn main() {
#let x = 5u8;
#do_something(&x as &Foo);
#}
или неявного приведения типа:
#fn do_something(x: &Foo) {
#x.method();
#}
#fn main() {
#let x = "Hello".to_string();
#do_something(&x);
#}

Вызов метода с явным указанием типажа при конфликте имен в имплементированных типажах:
#trait Foo {
#fn clone(&self);
#}

##[derive(Clone)]
#struct Bar;

#impl Foo for Bar {
#fn clone(&self) {
#println!("Making a clone of Bar");
#<Bar as Clone>::clone(self);
#}
#}
Этот код вызывает метод clone() типажа Clone , а не типажа Foo.

Строки, начинающиеся с use , импортируют соответствующие модули в локальную область видимости, поэтому мы можем обратиться к функциям по гораздо более коротким именам. __По соглашению, при импорте функции, лучшей практикой считается импортировать модуль, а не функцию непосредственно.__

break в цикле может возвращать значение

метод .unwrap() даёт T из Some(T), или паникует если Option оказался None.

[T] - массив
&[T] - слайс (всегда знает длину, доступ по индексу проверяет выход за границы)

//это не ссылка, потому что правая часть ею не является.
let  _not_a_reference = 3;
// Rust предоставляет ключевое слово `ref` для изменения присваивание так, что создаётся ссылка для элемента. 
// Теперь ссылка присвоена.
let ref  _is_a_reference = 3;

// Соответственно, для определения двух значений без ссылок, 
// ссылки можно назначить с помощью `ref` и `ref mut`.
let value = 5;
let mut mut_value = 6;
match value {
  ref r => println!("Получили ссылку на значение: {:?}", r),
}
match mut_value {
  ref mut m => { ;},
}

