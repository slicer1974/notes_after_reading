Если не ставить после последней строки функции точку с запятой - это значение будет возвращено из функции.

Rust никогда не будет автоматически создавать «глубокие» копии данных, а работает через перемещение.
Если мы все-таки хотим сделать __глубокую копию__ данных String __из кучи__, а не только данных из стека, то можно использовать часто встречающийся метод __clone.__

В Rust имеется специальная аннотация, именуемая __типажом Copy__, которую можно размещать в типах, таких как целые числа, хранящихся в стеке . Если у типа есть типаж Copy, то более старая переменная по-прежнему пригодна для использования после ее присвоения дру­гой переменной. 
Язык Rust __не позволит__ нам аннотировать тип с помощью типажа __Copy__, если тип или любая из его частей реализовали типаж __Drop__.
Вот несколько типов, которые аннотируются типажом __Copy__: 
* Все целочисленные типы, такие как u32. 
* Булев тип bool со значениями true и false. 
* Символьный тип char. 
* Все типы с плавающей точкой, такие как f64. 
* Кортежи, если только они содержат типы, которые также аннотируются. На­пример, (i32, i32) аннотируются, а (i32, String) — нет.

У вас не может быть структуры, часть полей которой изменяется, а другая часть — нет:
Изменяемость структуры определяется при её связывании:
#struct Point {
#x: i32,
#y: i32,
#}
#let mut a = Point { x: 5, y: 6 };
#a.x = 10;
#let b = Point { x: 5, y: 6};
#b.x = 10; // error: cannot assign to immutable field `b.x`
Однако, используя Cell<T> , вы можете эмулировать изменяемость на уровне полей:
#use std::cell::Cell;
#Run
#struct Point {
#x: i32,
#y: Cell<i32>,
#}

__По умолчанию следует использовать &self , также как следует предпочитать заимствование владению, а неизменные ссылки изменяемым.__

__В Rust у вас или одно изменяемое заимствование, или несколько неизменяемых. Невозможно одновременно ввести изменяемое и неизменяемое заимствования (или несколько изменяемых).__ В безопасности памяти важно, чтобы должным образом освобождались ресурсы, а в потокобезопасности важно, чтобы в каждый момент времени только один поток имел право изменять переменную. Кроме того, в такой ситуации никакие другие потоки не будут ссылаться на устаревшее заимствование: для него возможна или запись, или совместный доступ, но не оба.

__Ссылка__ похожа на указатель в том смысле, что это адрес, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка __гарантированно__ указывает на __допустимое__ значение определённого типа __в течение всего срока__ существования этой ссылки.

__Аннотации__ позволяют использовать разные механизмы языка. Например, язык Rust предоставляет ряд типажей для использования с аннотацией __derive__, которые добавляют полезные свойства в настраиваемые типы:
##[derive(Debug)] 
#struct Rectangle { width: u32, height: u32, }
Типаж Debug дает возможность печатать структуру в полезном для разработчиков виде, благодаря которому видно ее зна­ чение во время отладки кода.

__Структура (struct)__ — это пользовательский тип данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую группу.
#struct Circle {
#x: f64,
#y: f64,
#radius: f64,
#}

__Методы__ похожи на функции: они объявляются с помощью ключевого слова __fn__ и имени, у них могут быть параметры и возвращаемое значение, они содержат код, который выполняется, когда их вызывают из другого места. Однако методы отли­чаются от функций тем, что они определяются __внутри контекста__ структуры (или перечисления, или типажа). Их первым параметром всегда является параметр __self__, представляющий эк­земпляр структуры, для которого метод вызывается.
Пример: Определение метода area для структуры Rectangle 
#struct Rectangle { width: u32, height: u32, }
#impl Rectangle { 
#	fn area(&self) -> u32 { 
#		self.width * self.height 
#	} 
#}
__Rust не поддерживает перегрузку методов, именованные аргументы или переменное количество аргументов.__
Статические методы вызываются с помощью синтаксиса: Struct::method().

__Типаж (trait)__ - это набор методов, определённых для неизвестного типа. Они могут получать доступ к другим методам, которые были объявлены в том же типаже.
Типажи могут быть реализованы для любых типов данных.
Типаж - это возможность объяснить компилятору, что __данный тип должен предоставлять определённую функциональность.__
#struct Circle {
#x: f64,
#y: f64,
#radius: f64,
#}

#trait HasArea {
#fn area(&self) -> f64;
#}

#impl HasArea for Circle {
#fn area(&self) -> f64 {
#std::f64::consts::PI * (self.radius * self.radius)
#}
#}
	__Тело метода не определяется, а определяется только его сигнатура__. Когда мы реализуем типаж, мы используем impl Trait for Item , а не просто impl Item. 
Можно добавить функциональность к стандартному типу - композиция.

__Множественные ограничения по типажам:__
#fn foo<T: Clone + Debug>(x: T) {
#x.clone();
#println!("{:?}", x);
#}
или
#fn foo<T>(x: T)
#where T: Clone + Debug
#{
#x.clone();
#println!("{:?}", x);
#}

__Возврат значения - типажа__. Используя impl Summary для возвращаемого типа, мы уточняем, что функция _returns_summarizable возвращает некий тип, который реализует типаж Summary, не называя конкретный тип. 
#fn returns_summarizable(switch: bool) -> impl Summary {
#...
#}

Есть возможность реализовать __поведение по умолчанию__ для типажа:
#pub trait Summary { 
#	fn summarize(&self) -> String { 
#		String::from("(Читать дальше...)") 
#	} 
#}

__Типажи-объекты__, такие как &Foo или Box<Foo> , это __обычные переменные, хранящие значения любого типа, реализующего данный типаж__. Конкретный тип
типажа-объекта может быть определен только __на этапе выполнения__. Типаж-объект может быть получен __из указателя на конкретный тип__, который реализует
этот типаж, путем его явного приведения (например, &x as &Foo ) или неявного приведения (например, используя &x в качестве аргумента функции, которая принимает &Foo ).
Примеры:
__явное__ приведение типа:
#fn do_something(x: &Foo) {
#x.method();
#}
#fn main() {
#let x = 5u8;
#do_something(&x as &Foo);
#}
__неявное__ приведения типа:
#fn do_something(x: &Foo) {
#x.method();
#}
#fn main() {
#let x = "Hello".to_string();
#do_something(&x);
#}

Вызов метода с явным указанием типажа при конфликте имен в имплементированных типажах:
#trait Foo {
#fn clone(&self);
#}

##[derive(Clone)]
#struct Bar;

#impl Foo for Bar {
#fn clone(&self) {
#println!("Making a clone of Bar");
#<Bar as Clone>::clone(self);
#}
#}
Этот код вызывает метод clone() типажа Clone , а не типажа Foo.
__Можно переделывать в типажные объекты только объектно-безопасные типа­жи__. Несколько сложных правил управляют всеми свойствами, которые делают типажный объект безопасным, но на практике важны только два правила. Типаж объектно-безопасен, если все методы, определенные в нем, имеют следующие свойства: 
* Возвращаемый тип не является Self. 
* Параметры обобщенных типов отсутствуют.
Примером типажа, методы которого не являются объектно-безопасными, являет­ся Clone стандартной библиотеки:
#pub trait Clone { 
#	fn clone(&self) -> Self; 
#}

__Замыкания:__
#let plus_two = |x| {
#	let mut result: i32 = x;
#	result += 1;
#	result += 1;
#	result
#};
Если вы хотите, чтобы замыкание брало во владение значения, которые оно ис­пользует в среде, вы можете применить ключевое слово __move__ перед списком па­раметров. Этот технический прием главным образом полезен при передаче замы­ кания нового потока, — он позволяет перемещать данные так, чтобы ими владел новый поток.
#use std::thread; 
#fn main() { 
#	let v = vec![1, 2, 3]; 
#	let handle = thread::spawn(move || { 
#		println!("Вот вектор: {:?}", v); 
#	}); 
#	handle.join().unwrap(); 
#}

__Жизненные циклы:__
Главная цель __жизненного цикла__ — предотвращать висячие ссылки, из-за которых программа ссылается на данные, отличные от тех, на которые она должна ссылать­ся. 
__Аннотации жизненных циклов__ (кавычка и буква в нижнем регистре) используются __со ссылками__:
#&i32 // ссылка 
#&'a i32 // ссылка с явно выраженным жизненным циклом 
#&'a mut i32 // изменяемая ссылка с явно выраженным жизненным циклом
Пример:
#fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { 
#	if x.len() > y.len() { 
#		x 
#	} else {
#	 	y 
#	} 
#}
Сигнатура функции теперь сообщает Rust о том, что для некоторого жизненного цикла 'a функция берет два параметра, оба они являются строковыми срезами, живущими, по крайней мере, в течение жизненного цикла 'a. Сигнатура функции также говорит о том, что возвращаемый из функции строковый срез будет жить, по крайней мере, в течение жизненного цикла 'a.
Во время аннотирования жизненных циклов __в функциях__ аннотации находятся __в сигнатуре__ функции, __а не в теле__ функции.
Жизненный цикл для параметров функций или методов называется __входным__ жизненным циклом, а жизненный цикл для возвращаемых значений — __выходным__ жизненным циклом.

Чтобы выяснить, какие жизненные циклы есть у ссылок, когда __нет явно заданных аннотаций__, компилятор использует __три правила.__
Первое правило применяется к входным жизненным циклам, а второе и третье — к выходным. Если компиля­тор дойдет до конца этих трех правил и все еще останутся ссылки, для которых он не может выяснить жизненный цикл, то компилятор остановится с ошибкой. Эти правила применимы к определениям fn, а также к блокам impl. 
* Первое правило состоит в том, что каждый параметр, являющийся ссылкой, полу­чает собственный параметр жизненного цикла. Другими словами, функция с од­ ним параметром получает один параметр жизненного цикла: fn foo<'a>(x: &'a i32); функция с двумя параметрами получает два отдельных параметра жизнен­ ного цикла: fn foo<'a, 'b>(x: &'a i32, y: &'b i32) и так далее. 
* Второе правило состоит в том, что, если имеется __ровно один параметр входного__ жизненного цикла, то этот параметр жизненного цикла назначается __всем параме­трам выходных__ жизненных циклов: 
#fn foo<'a>(x: &'a i32) -> &'a i32. 
* Третье правило заключается в том, что, если имеется несколько параметров вход­ ных жизненных циклов, но один из них является __&self или &mut self__, так как это метод, то жизненный цикл параметра self назначается __всем параметрам выходных жизненных циклов__. Это третье правило делает методы гораздо удобнее для чтения и записи, поскольку требуется меньше символов.

Жизненный цикл __'static__ обозначает всю продолжительность программы. Все строковые литералы имеют жизнен­ ный цикл 'static.

__Параметры командной строки:__
Для того чтобы позволить программе читать значения аргумен­тов командной строки, которые мы ей передаем, нам понадобится функция std::env::args из стандартной библиотеки. Эта функция возвращает итератор аргументов командной строки.
#use std::env; 
#fn main() { 
#	let args: Vec<String> = env::args().collect(); 
#	println!("{:?}", args); 
#}

__Умные указатели:__
Умные указатели (Smart pointers) — это структуры данных, ко­торые не только действуют как указатель, но и обладают дополнительными мета­ данными и способностями. 
Пример: String и Vec<T>.  Оба типа считаются умными указателями, потому что они владеют не­ которой памятью и позволяют ею манипулировать. Они также имеют метаданные (например, емкость) и дополнительные способности или гарантии (например, в случае с типом String они обеспечивает, чтобы его данные всегда были действи­тельными и кодировались в UTF-8).
Умные указатели обычно реализуются с помощью структур. 
Особенность, отли­чающая умный указатель от обычной структуры, заключается в том, что умные указатели реализуют типажи __Deref__ и __Drop__. 
Типаж __Deref__ позволяет экземпляру структуры умного указателя вести себя как ссылка, поэтому вы можете писать код, который работает либо со ссылками, либо с умными указателями. 
Типаж __Drop__ позволяет настраивать код, который выполняется, когда экземпляр умного указа­теля выходит из области видимости. 

Наиболее часто встречаются в стандартной библиотеке:
* Умный указатель __Box<T>__ для размещения значений в __куче__.  Используется в случае:
-	У вас есть тип, размер которого __нельзя узнать во время компиляции__, и вы хоти­те использовать значение этого типа в контексте, требующем точного размера. 
-	У вас крупный объем данных, и вы хотите передать владение так, чтобы при этом данные не были скопированы.
-	Вы хотите владеть значением, и нужно, чтобы оно имело __не конкретный тип, а тип, который реализует некоторый типаж.__
Пример:
#fn main() { 
#	let b = Box::new(5); 
#	println!("b = {}", b); 
#}

* Умный указатель __Rc<T>__ — тип подсчета числа ссылок, который обеспечивает __множественное владение__. 
Обратите внимание, что тип Rc<T> предназначен только для использования в од­нопоточных сценариях. 
Реализация функции Rc::clone __не делает глубокую копию__ всех данных, как это делают реализации метода clone в большинстве типов. Вызов функции Rc::clone только наращивает число ссылок, это недолгий процесс. Глубокое копирование данных занимает много времени. Посредством неизменяемых ссылок умный указатель Rc<T> позволяет делиться данными __только для чтения__ между несколькими частями программы. 
Пример:
#struct User { name: String}
#pub fn main( ) 	{
#	let user = Rc::new( User {name : String::from("Igor") } );
#	println!("число ссылок на user", Rc::strong_count(&a));
#	let user2 = user.clone( ); //клонируем умный указатель
#	println!("число ссылок на user после создания user2", Rc::strong_count(&a));
#}
_Rc :: strong_count - подсчет __сильных ссылок__, вызов функции Rc::clone увеличивает число strong_count.
Путем вызова функции Rc::downgrade и передачи ссылки можно получить умный указатель типа а Weak<T> - __слабую ссылку__. Rc::downgrade увеличивает на 1 число Rc :: weak_count.

* Умные указатели __Ref<T> и RefMut<T> с доступом через RefCell<Т>__ — тип, ко­торый обеспечивает соблюдение правил заимствования __во время выполнения__, а не во время компиляции. Соответственно можно __не обеспечивать правила заимствования во время компиляции__.
При создании неизменяемых и изменяемых ссылок мы используем синтаксис & и &mut соответственно. С умным указателем RefCell<Т> мы используем методы за­ имствования __borrow и borrow_mut__, являющиеся частью безопасного API, который принадлежит умному указателю RefCell<Т>. Метод __borrow__ возвращает тип умного указателя __Ref<T>__, а __borrow_mut__ возвращает тип умного указателя __RefMut<Т>__. Оба типа реализуют типаж Deref, поэтому мы можем рассматривать их как регуляр­ ные ссылки. Умный указатель RefCell<Т> отслеживает, сколько умных указателей Ref<T> и RefMut<Т> активны в настоящий момент. Всякий раз, когда мы вызываем ме­ тод borrow, умный указатель RefCell<T> увеличивает число активных неизменяе­ мых заимствований. Когда значение умного указателя Ref<T> выходит из области видимости, число неизменяемых заимствований уменьшается на единицу. Как и правила заимствования времени компиляции, умный указатель RefCell<T> по­ зволяет в любой момент иметь много неизменяемых заимствований либо одно из­ меняемое заимствование.
Если мы попытаемся эти правила нарушить, то вместо ошибки компилятора, как это было бы со ссылками, реализация умного указателя RefCell<T> поднимет па­ нику во время выполнения. 


Реализация типажа __Deref__ позволяет настроить поведение оператора разыменования __*__ индивидуально. 
Для __пользовательских типов__, использующих разыменование, реализация типажа __Deref__ обязательна.


__Конкурентность:__
	В Раст из-за отсутствия среды рантайма потоки 1:1 с процессами. Зеленые потоки реализуются с помощью отдельных библиотек.

	Для того чтобы создать новый поток, мы вызываем функцию thread::spawn и пере­даем ей замыкание, содержащее код, кото­рый мы хотим выполнить в новом потоке исполнения. 
#thread::spawn(|| { 
#	for i in 1..10 { 
#		println!("привет, число {} из порожденного потока!", i); 
#		thread::sleep(Duration::from_millis(1)); 
#	} 
#});

	Главный поток после своего исполнения без специального указания остановит порожденные потоки. Чтобы этого не произошло используется специальная техника:
*	Дескриптор созданного потока (функция thread::spawn возвращает тип JoinHandle) присваивается в переменную:
#let handle = thread::spawn(|| { for i in 1..10 { println!("привет, число {} из порожденного потока!", i); thread::sleep(Duration::from_millis(1)); } }); 
*	В основном потоке через переменную дескриптора вызывается конструкция присоединения порожденного потока - __join__:
#handle.join().unwrap();
В результате сновной поток будет всегда ждать окончания присоединенного потока для окончания своего исполнения. 

	Замыкание __move__ часто используется вместе с функцией thread::spawn, поскольку позволяет применять данные из одного потока в другой.

	Для безопасной конкурентности все популярнее становится __передача сообще­ний__, когда потоки или акторы общаются, отправляя друг другу сообщения, со­ держащие данные. Один из основных инструментов языка Rust, предназначенный для достижения параллелизма отправки сообщений, — это понятие под названием «канал», реа­ лизация которого предусматривается стандартной библиотекой. 
Канал в программировании состоит из двух элементов: передатчика и приемника. нию. Одна часть кода вызывает методы для передатчика с данными, которые вы хотите отправить, а другая — проверяет принимающий конец на наличие посту­пающих сообщений.
Стандартная библиотека языка Rust реали­ зует каналы так, что канал может иметь несколько отправляющих концов, которые производят значения, и только один принимающий конец, который по­ требляет эти значения. 
#use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); }
	Другой вариант работы с данными в конкурентной среде  - __мьютексы__.
Тип Mutex<T> представляет собой умный указатель.
Вместо типа  Rc<T> при работе с множественным владением в конкурентной среде нужно использовать атомарный тип  Arc<T>. 
Пример работы с Mutex<T> /Arc<T>:
#use std::sync::{Mutex, Arc}; use std::thread; fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(&counter); 
#let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); }

__Разное:__
	Строки, начинающиеся с use , импортируют соответствующие модули в локальную область видимости, поэтому мы можем обратиться к функциям по гораздо более коротким именам. __По соглашению, при импорте функции, лучшей практикой считается импортировать модуль, а не функцию непосредственно.__

Break в цикле может возвращать значение

Метод .unwrap() применяется с Option. Возвращает T из Some(T), или паникует если Option оказался None.

[T] - массив
&[T] - слайс (всегда знает длину, доступ по индексу проверяет выход за границы)

//это не ссылка, потому что правая часть ею не является.
#let  _not_a_reference = 3;
// Rust предоставляет ключевое слово `ref` для изменения присваивание так, что создаётся ссылка для элемента. 
// Теперь ссылка присвоена.
#let ref  _is_a_reference = 3;

// Соответственно, для определения двух значений без ссылок, 
// ссылки можно назначить с помощью `ref` и `ref mut`.
#let value = 5;
#let mut mut_value = 6;
#match value {
#  ref r => println!("Получили ссылку на значение: {:?}", r),
#}
#match mut_value {
#  ref mut m => { ;},
#}

#####
__МАКРОКОМАНДЫ__
#####
Макрокоманды - основа метапрограмирования на Rust.
Наиболее широко используемой формой макрокоманд в Rust являются __деклара­тивные макрокоманды__. Их также иногда называют «макрокомандами на приме­рах», «макрокомандами macro_rules!» или просто «макросами».
Для того чтобы определить макрокоманду, вы используете конструкцию macro_ rules!. 
Пример:
##[macro_export] 
#macro_rules! vec { 
# 	( $( $x:expr ),* ) => { 
#		{ 
#			let mut temp_vec = Vec::new(); 
#			$( temp_vec.push($x); )* 
#			temp_vec 
#		} 
#	}; 
#}
Аннотация __#[macro_export]__ указывает, что эта макрокоманда должна быть до­ступна всякий раз, когда упаковка, в которой макрокоманда определена, вводится в область видимости. Без этой аннотации макрокоманда не может быть введена в область видимости.
$( $x:expr ),* - паттерн, используется для множественного __повторения__ выражения внутри (), в примере - $x:expr.  Варианты: $( )*, $( )?, $( )+ (0 и более, 0 или 1, 1 и более повторений).
После $( ) можно указать сепаратор (например ,). Выражение ( $( $x:expr ),* ) будет замещаться на параметры, переданные в макрокоманду __vec!__. Таким образом, в макрокоманде __vec![1,2,3]__ $x будет заменяться последовательно на 1, 2 и 3. __vec!__ параметров просто вернет пустой вектор.

__Вторая форма макрокоманд — это процедурные макрокоманды__, которые действу­ ют больше как функции (и являются типом процедуры). Процедурные макроко­ манды принимают некий код на входе, работают с этим кодом и производят некий код на выходе вместо сопоставления с паттернами и замены одного кода другим, как это делают декларативные макрокоманды. Таким образом, например, можно создавать трейты с реализацией через аннотацию __#[derive()]__.
При создании процедурных макрокоманд их определения должны находиться в собственной упаковке со специальным типом.

Пример: Код, который потребуется для обработки кода Rust большинству упаковок для процедурных макрокоманд 
hello_macro_derive/src/lib.rs 
#extern crate proc_macro; 
#use crate::proc_macro::TokenStream; 
#use quote::quote; 
#use syn; 
#	#[proc_macro_derive(HelloMacro)] 
#	pub fn hello_macro_derive(input: TokenStream) -> TokenStream { 
#		// Сконструировать представление кода Rust в виде синтаксического дерева, 
#		// которым можно манипулировать 
#		let ast = syn::parse(input).unwrap(); 
#
#		// Создать реализацию типажа 
#		impl_hello_macro(&ast) 
#	}
Упаковка __proc_macro__ постав­ляется в комплекте, поэтому нам не нужно было добавлять ее к зависимостям в Cargo.toml. Упаковка proc_macro представляет собой API компилятора, который позволяет читать код Rust и манипулировать им из нашего кода.
Упаковка __syn__ проводит разбор кода Rust из строкового значения в структуру данных, с которой мы можем выполнять операции. Упаковка __quote__ превращает структуры данных syn обратно в код Rust. Эти упаковки значительно упроща­ ют выполнение разбора любого вида кода Rust, который мы, возможно, захо­ тели бы обработать: написание полного анализатора кода Rust — задача не из простых.
Функция __hello_macro_derive__ вызывается, когда пользователь библиотеки ука­ зывает для типа #[derive (HelloMacro)]. Это возможно, потому что здесь мы __аннотировали__ функцию hello_macro_derive с proc_macro_derive и указали имя HelloMacro, которое соответствует имени нашего типажа. Этому соглашению сле­ дует большинство процедурных макрокоманд.

**Реализация функции impl_hello_macro**
#fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream { 
#	let name = &ast.ident; 
#	let gen = quote! { 
#		impl HelloMacro for #name { 
#			fn hello_macro() { 
#				println!("Здравствуй, Макро! Меня зовут {}", stringify!(#name)); 
#			} 
#		} 
#	}; 
#	gen.into() 
#}
Мы получаем экземпляр структуры Ident, содержащий имя (идентификатор) аннотированного типа с ast.ident.
Макрокоманда __quote!__ позволяет определять код Rust, который мы хотим возвращать. Компилятор ожидает чего-то отличного от прямого результата исполнения ма­ крокоманды quote!, поэтому нужно преобразовать его в TokenStream. Мы дела­ ем это, вызывая метод into, который использует промежуточное представление и возвращает значение требуемого типа TokenStream. Макрокоманда quote! также предоставляет очень интересную механику паттер­ нов: мы можем ввести #name, и quote! заменит его значением в имени переменной. Вы даже можете выполнять повторение, подобно тому, как работают обычные макрокоманды. 

__Макрокоманды, подобные атрибутам__, похожи на настраиваемые макрокоманды с атрибутом derive, но вместо того, чтобы генерировать код для derive, они позво­ляют создавать новые атрибуты.

__Макрокоманды, подобные функциям__, определяют макрокоманды, которые вы­ глядят как вызовы функций. Аналогично макрокомандам macro_rules! они более гибкие, чем функции: например, они могут брать неизвестное число аргументов.
Пример макрокоманды, подоб­ной функциям, — макрокоманда sql!, которую можно вызвать так: 
#let sql = sql!(SELECT * FROM posts WHERE id=1); 
Эта макрокоманда выполнит разбор инструкции SQL внутри себя и проверит ее на синтаксическую правильность, что представляет собой намного более сложную обработку, чем способна сделать макрокоманда macro_rules!. 
Макрокоманда sql! будет определена следующим образом: 
##[proc_macro] 
#pub fn sql(input: TokenStream) -> TokenStream {