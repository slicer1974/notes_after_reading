• Функции, аргументы и привязки должны начинаться со __строчной__ буквы. При использовании строчных букв в имени оператора оно __не должно начинаться с символа двоеточия (:)__.
• Типы, конструкторы, классы типов и виды (kind) должны начинаться с ___прописной__ буквы. При использовании прописных букв в имени оператора оно __должно начинаться с символа двоеточия (:)__

Существует три способа, с помощью которых вы можете создать новый тип данных:
• Определение __type__, такое как 
#type GearCount = Int 
, просто создаёт синоним существующего типа. Система типов не станет препятствовать вам использовать Int везде, где требуется GearCount . Использование такого типа может сделать ваш код более самодокументируемым.
• Определение __newtype__, например, 
#newtype Make = Make Text .
В этом случае вы не можете случайно использовать Text вместо Make , компилятор не даст вам этого сделать. Обёртка, создаваемая посредством newtype, всегда удаляется во время компиляции и не создаёт накладных расходов.
• Определение __data__: 
#data Either a b = Left a | Right b . 
Вы можете также создавать алгебраические типы данных (АТД), такие как 
#data Vehicle = Bycicle GearCount | Car Make Model.
Vehicle — это конструктор типа.
Bicycle и Car — конструкторы данных. __Конструктор данных работает, в том числе, как функция, принимающая соответствующее количество аргументов__
Внутри модуля все конструкторы должны иметь разные имена.
Пространство имён типов не пересекается с пространством конструкторов типа, поэтому компилятор отлично понимает где есть рекурсия, а где нет.

Любой конструктор можно сделать инфиксным, использовав его в обратных одинарных кавычках в инфиксной нотации. И любой инфиксный оператор можно использовать в префиксной нотации, заключив его в скобки.

__Двоеточие__ в качестве первого символа конструктора нужно использовать, когда сам конструктор состоит из специальных символов (например, @@, +++, @!* и т.д.), исключением является конструктор пустого списка [ ], который состоит из спецсимволов, но не имеет двоеточия в качестве первого символа. И да — конструкторы, состоящие из спецсимволов, используются обычно в инфиксной нотации

Синтаксис записей часто используется при конструировании сложных параметризированных значений. Часто в таких случаях указывается функция "разворачивания" параметризированного значения.
#newtype Parser s a = Parser { runParser :: [s] -> Maybe (a, [s]) }
обозначает, что функция runParser принимает на вход переменную типа Parser s a и переменную типа список s и возвращает переменную типа Maybe (a, [s])
т.е 
#//runParser :: Parser s a -> [s] -> Maybe (a, [s]) 

Обычные объявления data не позволяют возвращать разные типы в зависимости от конструктора данных. Все конструкторы __единообразно__ создают значения типа, указанного после ключевого слова data. Обойти это ограничение позволяет GHC-расширение, называемое __обобщенными алгебраическими типами данных (GADT):__ каждый из конструкторов данных может возвращать для определяемого типа разное множество параметров типа (то есть в определении Expr a t можно возвращать Expr a Bool, Expr Int Int и т.д.) Синтаксис начинается с ключевого слова data, за которым следует имя и тип переменных определяемого типа. Но вместо знаков равенства нужно указать ключевое слово where и перечислить конструкторы посредством их сигнатур. Пример:

data Expr a r where
	AmountOf			:: a -> Expr a Integer
	TotalPrice			:: Expr a Float и.т.д

r в аргументах обозначает случайный тип (random)	

Для неспешной работы можно использовать тип String, если важна производительность и/или строгость лучше использовать тип Text (модуль Data.Text)

===
Анонимные функции
===
Синтаксис тела функции имеет следующий вид:
\аргумент1 аргумент2 ... -> тело
Например:
#map (\x -> x + 2) [1,2,3]
Чтобы вернуть лямбда функцию целиком - заключаем ее в скобки:
#genIfEven f = (\x -> ifEven f x)

Хранение значения в замыкании:
#cup ml = \message -> message ml
В связи с тем, что мы можем использовать функции как значения первого класса, вы можете обращаться со значением, хранящимся внутри замыкания, как с обычными данными. Теперь вы можете передавать эту информацию как объект.  Функция cup ожидает на вход функцию, которую она применит к хранимому в замыкании значению ml.
Например:
#getMl aCup = aCup (\ml -> ml)
Мы передаем в функцию лямбда-функцию, которая принимает первый переданный ей аргумент и возвращает его
Теперь если вызвать функции:
#aCup = cup 180  #создание "экземпляра" cup
#getMl aCup  #(\ml -> ml) 180   = \180 -> 180
результатом будет 180.

Если мы даем частичное определение функции без __последних__ аргументов, то получается естественное частичное применение. Если мы хотим оставить в «свободном плавании» __не последниe__ аргументы, то мы вынуждены использовать лямбда-абстракцию. Например:
#foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
#myfold = foldr (+) 0
#myfold [1,2,3,4,5] 	//15
и
#myfold2 = (\c -> foldr c 0 [1,2,3,4])
#myfold2 (+)		//10

Отбрасывание аргументов в бесточечном стиле допустимо, только если самый правый аргумент в левой части является самым правым и в правой части (и при этом больше нигде в правой не используется). 

===
Каррирование
===
#curry :: ((a, b) -> c) -> a -> b -> c
#curry = \f -> \a -> \b -> f (a, b) 
#uncurry :: (a -> b -> c) -> ((a, b) -> c)
#uncurry = \f -> \(a, b) -> f a b

Функция __curry__ принимает функцию двух аргументов для которой частичное применение невозможно (т.е функция принимает кортеж аргументов). Далее __curry__ принимает аргументы по одному, позволяя частичное применение и возвращает результат применения функции к кортежу из этих аргументов.
__Uncurry__ принимает обычную функцию с возможностью частичного применения, далее принимает кортеж аргументов и возвращает результат применения функции к этим аргументам.

===
Работа со списками: 
	оператор __:__ - конструирование списка, т.е. соединение элемента с существующим списком
	оператор __++__ - соединение списков, применяется если оба аргумента это списки

в Haskell нет встроенных циклических конструкций. Вместо этого используется рекурсия

===
Принудительное вычисление (отмена ленивости)
Сделать это позволяет функция __seq__ из модуля Prelude . В наиболее общей форме принудительное выражение записывается как __`seq` b__ . В результате
Haskell гарантирует вычисление выражения, находящегося перед b. Идиома __x `seq` f x__ встречается настолько часто, что для нее есть
специальный оператор соблюдения строгости (strict application) __$!__, решающий данную задачу. 
Например:
#y $! (z+x)
Кроме того по соглашению функции, заканчивающиеся на __'__, являются строгими.
 
===
Тип __bottom__ обозначает незавершенное вычисление. Заменяет собой любой тип. Функции, которые могут возвращать bottom, называются частичными.

*
Поскольку существует так много структур данных, которые хорошо работают со свёртками, был введён класс типов __Foldable__. Подобно тому как класс Functor предназначен для сущностей, которые можно отображать, класс Foldable предназначен для вещей, которые могут быть свёрнуты

*
Вместо использования обобщенных пар или кортежей, можно ввести отдельное имя для произведения конкретных типов. Например,
# data Stmt = Stmt String Bool
представляет собой произведение String и Bool, но обладает собственным именем и конструктором. Преимущество такого определения в том, что можно завести много типов с одним и тем же содержимым, но различной семантикой и функциональностью, которые система типов не позволит смешивать между собой.

*
Функция (,,) – это то же самое, что и анонимная функция \x y z –> (x,y,z). В свою очередь, функция (,) – то же самое, что и \x y –> (x,y).

*
Экзистенциальные типы
Неоднородные контейнерные структуры данных (неоднородные типы) позволяют хранить значения различных типов, никак не связанных друг с другом. Задача создания таких структур данных достаточно легко решается в объектно-ориентированном стиле при помощи механизма наследования и динамической диспетчеризации. Но эта же задача оказывается нетривиальной для функциональной парадигмы.
Здесь и приходят на помощь экзистенциальные типы.
Для создания неоднородного списка, который будет содержать все считанные из файла геометрические фигуры, необходимо определить экзистенциальный тип-обёртку:
# data GeoObject = forall a . Figure a => GeoObject a
Квантор всеобщности, обозначаемый в языке Haskell ключевым словом forall, убирает типовую переменную a из области видимости всего типа GeoObject, но при этом указывает, что тип для конкретизации может быть произвольный, главное, чтобы он являлся экземпляром класса Figure.

===
__Моноид__ определяется как множество с бинарной операцией. Все, что требуется от этой операции — её ассоциативность, и наличие единственного специального элемента, который ведет себя как единица по отношению к этой операции. Чтобы сократить запись, вместо mappend используют синоним (<>).
#class Monoid m where
#   mempty  :: m
#   mappend :: m -> m -> m

#instance Monoid String where
#    mempty = ""
#    mappend = (++)

===
__Функтор__ есть отображение между категориями. Поскольку в Haskell мы работаем только с 1 категорией - категорией типов (Hask), функтор может отображать только из категории типов в категорию типов (один тип в другой тип). Такой функтор называтеся эндофунктор, то есть функтор из категории в себя саму. Что представляет собой эндофунктор в категории типов? В первую очередь, он сопоставляет одним типам другие. Подобные отображения на самом деле нам знакомы, это типы, параметризованные другими типами (напр.Maybe есть отображение типа a в тип Maybe a).
Функтор применяет обычную функцию к значениям в контексте.
В Haskell обличье функтора, отвечающее за отображение морфизмов, реализуется функцией высшего порядка fmap. Например, для Maybe она имеет следующую сигнатуру:
#fmap :: (a -> b) -> (Maybe a -> Maybe b)

#class Functor f where
#    fmap :: (a -> b) -> f a -> f b  
Оно утверждает, что f есть Functor в том случае, если имеется функция fmap с данной сигнатурой. Здесь f — типовая переменная, того же рода что и типовые переменные a и b. Но компилятор способен понять, что f представляет собой конструктор типов, отслеживая её использование: применение к другим типам, здесь f a и f b. 
Проще говоря:
Вы поднимаете функцию a -> b, чтобы она работала с, например, Maybe a -> Maybe b. Вы можете записать fmap как fmap (a -> b) -> (f a -> f b).
Обычный функтор берет чистую функцию и преобразовывает ее так, чтобы она принимала обернутые значения.

Если конструктор типа принимает два параметра, как, например, конструктор Either, мы должны частично применять конструктор типа до тех пор, пока он не будет принимать только один параметр. Поэтому мы не можем написать определение Functor Either where, зато можем написать определение Functor (Either a) where.

__Первый закон функторов__ гласит, что если мы применяем функцию id к значению функтора, то значение функтора, которое мы получим, должно быть таким же, как первоначальное значение функтора. В формализованной записи это выглядит так: 
#fmap id = id.
Иными словами, если мы применим fmap id к значению функтора, это должно быть то же самое, что и просто применение функции id к значению. Например: 
#fmap id (Just 3)
#Just 3

__Второй закон__ гласит, что композиция двух функций и последующее применение результирующей функции к функтору должны давать тот же результат, что и применение первой функции к функтору, а затем применение другой. В формальной записи это выглядит так: fmap (f . g) = fmap f . fmap g. Или если записать по-другому, то для любого значения функтора x должно выполняться следующее: 
#fmap (f . g) x = fmap f (fmap g x)

Любой тип, параметризуемый другим типом — кандидат на роль функтора.

===
Аппликативный функтор
===
В теории категорий аппликативный функтор - это слабый моноидальный функтор (функтор, частично сохраняющий моноидальную структуру с помощью морфизмов для единицы и произведения). см. (https://question-it.com/questions/1709031/chto-takoe-opredelenie-applicative-functor-s-tochki-zrenija-teorii-kategorij)

Применяет функцию в контексте к значениям в контексте. Функция в контексте получается, например, при частичном применении функции двух контекстных аргументов. Например:
#maybeInc = (+) <$> Just 1 
Функция имеет тип 
#maybeInc :: Maybe (Integer -> Integer) 
и ожидает второй аргумент.
Применять такую функцию к аргументу типа __Maybe (Integer)__ можно только с помощью аппликативного функтора.

Аппликативный функтор берет обернутую функцию и преобразовывает ее так, чтобы она принимала обернутые значения. Т.е. аппликативный функтор лифтит функции, не разворачивая их.

#class (Functor f) => Applicative f where
#	pure :: a –> f a
#	(<*>) :: f (a –> b) –> f a –> f b
__<$>__ - инфиксный аналог __pure__.

Лучший способ представить себе функцию pure – это сказать, что она берёт значение и помещает его в контекст (или чистый контекст). 
Сочетание заключения чистой функции в оболочку и ее последующего применения к нескольким аргументам при использовании класса Applicative встречается довольно часто. Поэтому функция (<$>) была создана с этим простым определением:
# (<$>) :: (a -> b) -> f a -> f b
# f <$> x = pure f <*> x

Оператор <*> принимает значение функтора, который содержит в себе функцию, и другой функтор – и извлекает эту функцию из первого функтора, затем отображая с её помощью второй.
Шаблон __f <$> val1 <*> val2 <*> val3 ...__ или __pure f <*> val1 <*> val2 <*>...__- часто используемый шаблон для функций более 1 аргумента 
Пример:
# ghci> (++) <$> ["хa","хeх","хм"] <*> ["?","!","."]
# ["хa?","хa!","хa.","хeх?","хeх!","хeх.","хм?","хм!","хм."]

Другие примеры использования аппликативных функторов:
ghci> Just (+3) <*> Just 9
Just 12	
ghci> pure (+3) <*> Just 9
Just 12

Мы можем использовать оператор <*> со списками вот так:
ghci> [(*0),(+100),( 2)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
Левый список содержит три функции, а правый – три значения, поэтому в результирующем списке будет девять элементов. Каждая функция из левого списка применяется к каждому элементу из правого. Если у нас имеется список функций, принимающих два параметра, то мы можем применить эти функции между двумя списками.

ghci>filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
[55,80,100,110]

Оператор <**> - то же, только с перевернутым списком аргументов
[(*0),(+100),( 2)] <*> [1,2,3] =  [1,2,3] <**> [(*0),(+100),( 2)]

===
Монады
===
Монады являются естественным продолжением аппликативных функторов и предоставляют решение для следующей проблемы: если у нас есть значение с контекстом типа m a, как нам применить к нему функцию, которая принимает обычное значение a и возвращает значение с контекстом? Другими словами, как нам применить функцию типа a –> m b к значению типа m a? По существу, нам нужна вот эта функция:
(>>=) :: (Monad m) => m a –> (a –> m b) –> m b
Если у нас есть причудливое значение и функция, которая принимает обычное значение, но возвращает причудливое, как нам передать это причудливое значение в данную функцию? Это является основной задачей при работе с монадами. Мы пишем m a вместо f a, потому что m означает Monad; но монады являются всего лишь аппликативными функторами, которые поддерживают операцию >>=. Функция >>= называется связыванием.

Функция return имеет тип (Monad m) => a –> m a. Она принимает нечто и оборачивает это в монаду.

Есть и еще один возможный способ определения монады. Вместо функции (>>=) определяется функция fmap, а также дополнительно определяется функция join, которая для каждой монады m должна иметь тип m (m a) -> m a.
Функция join принимает монадическое значение в монадическом значении и отдаёт нам просто монадическое значение; другими словами, она его разглаживает. Вот она с некоторыми значениями типа Maybe:
ghci> join (Just (Just 9))
Just 9
ghci> join (Just Nothing)
Nothing
Наверное, самое интересное в функции join – то, что для любой монады передача монадического значения в функцию с помощью операции >>= представляет собой то же самое, что и просто отображение значения с помощью этой функции, а затем использование функции join для разглаживания результирующего вложенного монадического значения! Другими словами, выражение m >>= f – всегда то же самое, что и join (fmap f m).
 join ( fmap ( a -> m b ) m a ) => join ( m (m b) ) => m b

===
Обобщая:
(<$>) :: Functor     f =>   (a ->   b) -> f a -> f b
(<*>) :: Applicative f => f (a ->   b) -> f a -> f b
(=<<) :: Monad       f =>   (a -> f b) -> f a -> f b
Все используются для того, чтобы передавать функциям значения с контекстом, тогда как функции ожидают обычные значения на входе.
Функторы используют обычную функцию.
Аппликативные функторы — обычную функцию внутри контекста.
Монады используют функции, которые на выходе имеют значение в контексте.

Самое важное отличие монады от функтора — монады можно комбинировать друг с другом, порождая новые монады и при этом абстрагируясь от того, как именно реализована монада — читает ли она с диска, принимает ли она дополнительные параметры для вычисления своего значения, существует ли это значение вообще. Второй важный момент — монады комбинируются не параллельно, а последовательно, оставляя возможность добавлять логику в зависимости от результата первой монады. Аппликативные функторы комбинируют параллельно.

В do-нотации переменные, значения которым были присвоены с помощью <-, позволяют вам работать с монадическим типом mа так, будто это значение типа a. Выражения let используются всякий раз, когда вам нужно создать переменную, не принадлежащую к монадическому типу.

===
Функция filterM из модуля Control.Monad:
 filterM :: (Monad m) => (a –> m Bool) –> [a] –> m [a]
Предикат возвращает монадическое значение, результат которого – типа Bool, но поскольку это монадическое значение, его контекст может быть всем чем угодно.
Функция liftM из модуля Control.Monad:
 liftM :: Monad m => (a1 -> r) -> m a1 -> m r 
Применяет функцию к монадическому значению (типа fmap для монад)
Вместо нее можно использовать инфиксную функцию ap. Как правило, любой вызов в форме liftMn f x1 x2 ... xn можно заменить выражением f `ap` x1 `ap` x2 `ap` ... `ap` xn

*
Монада State - функция с состоянием
Состояние, предшествующее выполнению функции, может рассматриваться как ее дополнительный аргумент. Тогда если в общем виде у нас
есть функция типа a -> b , то функция, которая также получает состояние типа s, должна иметь тип a -> s -> b . Эта функция в конце ее выполнения должна быть также наделена состоянием, которое впоследствии может быть передано другой функции, ожидающей состояние. При условии, что функция возвращает значение типа b , мы можем добавить в пару к нему значение типа s . В окончательном виде функции, манипулирующие состоянием, имеют тип a -> s -> (b,s) .
	
data State s a = State { runState :: s -> (a, s) }
 
instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= f  = State $ \s -> let (a, s') = runState m s in runState (f a) s'
 
get :: State s s
get = State $ \s -> (s, s)
 
put :: s -> State s ()
put s = State $ \_ -> ((), s)
 
postIncrement :: Num a => State a a
postIncrement = do x <- get
         put (x + 1)
         return x

Функции runState передаётся монада и начальное состояние. Функция get берёт это начальное состояние и превращает его в значение (первый элемент в кортеже) монады State. Дальше то, что записывается в виде do { x <- get; f x } следует воспринимать следущим образом: get >>= \x -> f x, т.к. второй аргумент оператора bind — это функция, которая принимает значение монады и возвращает новую монаду State. Далее с помощью put меняется состояние монады (при этом значение отбрасывается), затем с помощью return устанавливаем значение монады. 

*
Монада Writer - объединяет логи
Вы можете использовать tell, чтобы записать что-то в лог. А return передаст значение в Writer. Пример  - функция half:
 half :: Int -> Writer String Int
 half x = do
        tell ("I just halved " ++ (show x) ++ "!")
        return (x `div` 2)

И мы можем использовать runWriter, чтобы извлечь из него значение (обратите внимание на связывание монад) :
 runWriter $ half 8 >>= half
 => (2, "I just halved 8!I just halved 4!")

Монада Writer позволяет нам использовать любой Monoid в качестве лога, а не одни только строки

*
Монада Reader
Функция ask извлекает весь контекст.
Функция asks применяет функцию к контексту и возвращает результат. Эта функция, которая хорошо подходит для запроса конкретного поля структуры,
очень похожа на функцию доступа (если, например, контекст задан в структурированном виде).
Пример:
hello :: Reader String Int
hello = do
    name <- ask
    return $ length name

bye :: Reader String Int
bye = do
    name <- ask
    return $ length . words $ name

convo :: Reader String String
convo = do
    c1 <- hello
    c2 <- bye
    return $ "full length:" ++ show c1 ++ ", words:" ++ show c2

main = print . runReader convo $ "adit boo"

*
Монады IORef и ST
Используются для реализации мутабельности. Причем ST позволяет скрывать всю работу с мутабельностью внутри монады. Примеры:
1.
main :: IO ()
main = do
	box <- newIORef (4 :: Int)
	modifyIORef box (2*)
	readIORef box >>= print

2.
import Control.Monad.ST
import Data.STRef
import Data.Foldable

sumST :: Num a => [a] -> a
sumST xs = runST $ do
    n <- newSTRef 0
    for_ xs $ \x ->
        modifySTRef n (+x)
    readSTRef n

Обратите внимание, что функция sumST - чистая

В do-нотации присваивание  <- используется для создания переменной __без контекста__ для сохранения результата функции __в контексте__:
#name <- getLine
getLine :: IO String, name :: String
присваивание с использованием let используется для создания переменной __без контекста__ для сохранения результата функции __без контекста__
#let statement = helloPerson name
helloPerson  ожидает String, и так как name присвоено через <-,  можно передать его в функцию helloPerson, результат - statement :: String

Функция mapM используется для применения функции map к значениям в контексте монады. Функция mapM_ работает аналогично, но отбрасывает результаты
Для использования mapM с функциями, не принимающими аргумент (например getLine) используется конструкция __(\_ -> ...)__

*
liftIO :: IO a -> m a
Lift a computation from the IO monad. This allows us to run IO computations in any monadic stack, so long as it supports these kinds of operations (i.e. IO is the base monad for the stack).

*
__Свободные монады__ — это просто общий способ превращения функторов в монады. 
#data Free f r = Pure r | Free (f (Free f r))
То есть, для любого функтора f   Free f является монадой. Это было бы не очень полезно, если бы вы не получили пару функций
#liftFree :: Functor f => f a -> Free f a
#foldFree :: Functor f => (f r -> r) -> Free f r -> r
первый из них позволяет вам «войти» в вашу монаду, а второй — как «выйти» из нее.
Другими словами, мы можем думать о свободной монаде как о __списке функторов__.
В более общем смысле, если X — это Y с некоторыми дополнительными элементами P, то «свободный X» — это способ перехода от Y к X без получения чего-либо дополнительного. Конструктор Free применяется, когда за одной операцией следует список других операций, а конструктор Pure служит меткой окончания вычислений.
Через свободные монады реализуется монадическое поведение для типа, который такого поведения не имеет.

*
Comonad – это тоже класс типов, который позволяет функциям взаимодействовать с эффектами комонады, только у этих функций комонада указывается не в возвращаемом типе, а в аргументе. Функции комонады обратны функциям монады: например, join совмещает вложенные контексты, а duplicate — напротив, удваивает контекст; return помещает в контекст, а extract — извлекает из него, и т.д.

*
Монадные трансформеры
Наиболее предпочтительным в Haskell способом объединения эффекта применения нескольких монад в новой монаде является использование монадических преобразователей (monad transformers).
Формально монадический преобразователь — это тип данных со следующей структурой:
# MonadT e 1 ... e n m a
где:
- MonadT — это имя монадического преобразователя. Оно обычно совпадает с именем монады, эффект применения которой добавляет преобразователь. Например, монада StateT добавляет к другой монаде функциональность состояния, ListT — недетерминизм, ReaderT — контекст только для чтения и т.д.
- e 1 ... e n — это дополнительные переменные типа, в которых может нуждаться монадический преобразователь
- В позиции переменной типа m указывается монада преобразуемая, или заключаемая в оболочку (оба понятия используются как взаимозаменяемые).
- Результатом MonadT e 1 .. . e n m должна стать монада как таковая, следовательно, она получает дополнительный параметр a, чтобы придать ей, как и ожидалось, вид * -> * .
Все монадные трансформеры должны имплементировать класс типов MonadTrans,определенный в Control.Monad.Trans.Class:
#class MonadTrans t where
#lift :: Monad m => m a -> t m a
Пример:
#readerWriterExample :: ReaderT Int (Writer String) Int
#readerWriterExample = do x <- ask
#lift . tell $ show
Первая монада будет внешним слоем (и поэтому для использования функции tell, работающей в слое Writer, понадобится функция lift).
Одно из правил гласит, что эффекты интуитивно помещаются в стек монад в порядке, обратном тому, в котором они появляются в луковице преобразователя: монада StateT s [] сначала добавляет состояние ко всему остальному, а затем результаты с состоянием заключаются в оболочку недетерминизма; в то время как монада ListT (State s) сначала добавляет к результату недетерминизм, а затем состояние — ко всему остальному.
Еще пример: 
# StateT s Maybe a = s -> Maybe (a , s)  - неудача влияет как на результат, так и на состояние: либо все вычисления терпят неудачу, либо они проходят удачно.
# MaybeT (State s) a = (State s) (Maybe a) = s -> (Maybe a , s) , то есть неудача влияет только на результат, но не на сохраняемое внутреннее состояние.

*
Ассоциированные типы через семейство типов
Основная идея семейства типов — устанавливать некоторую ассоциацию между двумя различными типами. Чтобы этого добиться, нам нужно ввести некоторый ассоциированный тип, чтобы указать, каково содержимое определённого типа.
{-# LANGUAGE TypeFamilies #-}

class SafeHead a where
type Content a
safeHead :: a -> Maybe (Content a)

instance SafeHead [a] where
type Content [a] = a
safeHead [] = Nothing
safeHead (x:_) = Just x

instance SafeHead S.ByteString where
type Content S.ByteString = Word8
safeHead bs
| S.null bs = Nothing
| otherwise = Just $ S.head bs

Возможность разместить декларации типа ( type ) внутри класса и экземпляра

*
Обобщеннные алгебраические типы данных  - GADT
Каждый из конструкторов типа данных может возвращать для определяемого типа разное множество параметров типа (то есть в определении Expr a t можно возвращать Expr a Bool , Expr Int Int и т. д., но не Offer Char ).
Синтаксис начинается с такого же ключевого слова data, за которым следуют имя и тип переменных определяемого типа. Но вместо знаков равенства нужно указать ключевое слово where и перечислить конструкторы посредством их сигнатур.
Выражение GADT-типа выглядит следующим образом:

{-# LANGUAGE GADTs #-}
data Expr a r where
AmountOf :: a -> Expr a Integer
PriceOf  :: a -> Expr a Float и т.д.

Хотя в данном случае создание тегов для типов осуществляется с использованием встроенных типов из пакета Prelude, ничто не мешает нам использовать и другие типы. Мы можем строить новые типы данных, чьим единственным предназначением будет создание тегов для других типов. Тогда в объявлении нам даже не понадобятся какие-либо конструкторы, поскольку они никогда не будут использоваться. Если включить расширение EmptyDataDecls , можно будет создавать пустые объявления data:

{-# LANGUAGE EmptyDataDecls, GADTs #-}
data AllowEverything
data AllowProducts
data AllowPurchases
data Person = Person :: { firstName :: String, lastName :: String }
data User r where
Admin 		:: Person -> User AllowEverything
StoreManager 	:: Person -> User AllowEverything
StorePerson 	:: Person -> User AllowProducts
Client		:: Person -> User AllowPurchases

Теперь для того, чтобы потребовать значение с тегом правильного типа, может быть определена функция, которую будут вызывать только те, кому доступно все:
changePurchaseFinalPrice :: User AllowEverything -> Purchase -> Float -> Purchase
changePurchaseFinalPrice = ...

====
Структурная рекурсия определяет способ построения и преобразования значений по виду типа (по составу его конструкторов). Функции, которые преобразуют значения мы будем называть свёрткой (fold), а функции которые строят значения – развёрткой (unfold).
Свёртку значения можно представить как процесс, который заменяет в дереве значений все конструкторы на подходящие по типу функции. Мы получаем значение некоторого произвольного типа из данного рекурсивного типа.
С помощью развёртки мы постепенно извлекаем значение рекурсивного типа из значения какого-нибудь другого типа. Типичный пример развёртки это функция iterate.

Если мы определим некую функцию как продолжение для рекурсивной и передадим ее как аргумент в исходную функцию - мы можем сделать рекурсивную функцию с помощью комбинатора fix:
fact : : Int -> Int
fact 0 = 1 
fact n =  n * fact (n -1)

можно преобразовать в 
fact : : Int -> Int 
fact  = ( \t -> \arg -> case arg of 
					0 = 1 
					n =  n * t(n -1) ) fact
то есть
fact  = f fact 
	where f = \t -> \arg -> case arg of 
				0 = 1 
				n =  n * t(n -1) 

тогда функция факториала fact эквивалентна функции 
factfix  :: Int -> Int
factfix  = fix f 
	where f t = \arg -> case arg of 
				0 -> 1 
				n -> n * t(n -1) 

 где fix - комбинатор неподвижной точки 

Функция sequence_ выполняет последовательность монадических действий, хранящихся в заданном списке. Функция mapM_ строит такой список при помощи заданной функции f и исходного списка, после чего передаёт построенный список монадических действий функции sequence_.