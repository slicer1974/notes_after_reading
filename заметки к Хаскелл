• Функции, аргументы и привязки должны начинаться со строчной буквы. При использовании строчных букв в имени оператора оно НЕ ДОЛЖНО начинаться с символа двоеточия (:).
• Типы, конструкторы, классы типов и виды должны начинаться с прописной буквы. При использовании прописных букв в имени оператора оно ДОЛЖНО начинаться с символа двоеточия (:)

Существует три способа, с помощью которых вы можете создать новый тип данных:
• Определение type, такое как type GearCount = Int , просто создаёт синоним существующего типа. Система типов не станет препятствовать вам использовать Int везде, где требуется GearCount . Использование такого типа может сделать ваш код более самодокументируемым.
• Определение newtype, например, newtype Make = Make Text . В этом случае вы не можете случайно использовать Text вместо Make , компилятор не даст вам этого сделать. Обёртка, создаваемая посредством newtype, всегда удаляется во время компиляции и не создаёт накладных расходов.
• Определение data: data Either a b = Left a | Right b . Вы можете также создавать алгебраические типы данных (АТД), такие как data Vehicle = Bycicle GearCount | Car Make Model.
Bicycle и Car — конструкторы данных.
Внутри модуля все конструкторы должны иметь разные имена.
Vehicle — это конструктор типа.
Пространство имён типов не пересекается с пространством конструкторов типа, поэтому компилятор отлично понимает где есть рекурсия, а где нет.

Любой конструктор можно сделать инфиксным, использовав его в обратных одинарных кавычках в инфиксной нотации. И любой инфиксный оператор можно использовать в префиксной нотации, заключив его в скобки.

Двоеточие в качестве первого символа конструктора нужно использовать, когда сам конструктор состоит из специальных символов (например, @@, +++, @!* и т.д.), исключением является конструктор пустого списка [ ], который состоит из спецсимволов, но не имеет двоеточия в качестве первого символа. И да — конструкторы, состоящие из спецсимволов, используются обычно в инфиксной нотации

*
Анонимные функции
Синтаксис тела функции имеет следующий вид:
\аргумент1 аргумент2 ... -> тело
Например:
map (\x -> x + 2) [1,2,3]

*
Каррирование
curry :: ((a, b) -> c) -> a -> b -> c
curry = \f -> \a -> \b -> f (a, b)
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry = \f -> \(a, b) -> f a b

Функция curry принимает функцию двух аргументов для которой частичное применение невозможно. Это имитируется с помощью кортежей. Функция принимает кортеж из двух элементов. Функция curry (от слова каррирование, частичное применение) превращает такую функцию в обычную функцию Haskell. А функция uncurry выполняет обратное преобразование.

*
в Haskell нет встроенных циклических конструкций. Вместо этого используется рекурсия

*
Принудительное вычисление (отмена ленивости)
Сделать это позволяет функция seq из модуля Prelude . В наиболее общей форме принудительное выражение записывается как `seq` b . В результате
Haskell гарантирует вычисление выражения, находящегося перед b. Идиома x `seq` f x встречается настолько часто, что для нее есть
специальный оператор соблюдения строгости (strict application) $!, решающий данную задачу. 
Например:
y $! (z+x)
Кроме того по соглашению функции, заканчивающиеся на ', являются строгими.

*
Тип bottom обозначает незавершенное вычисление. Заменяет собой любой тип. Функции, которые могут возвращать bottom, называются частичными.

*
Поскольку существует так много структур данных, которые хорошо работают со свёртками, был введён класс типов Foldable. Подобно тому как класс Functor предназначен для сущностей, которые можно отображать, класс Foldable предназначен для вещей, которые могут быть свёрнуты

*
Вместо использования обобщенных пар или кортежей, можно ввести отдельное имя для произведения конкретных типов. Например,
data Stmt = Stmt String Bool
представляет собой произведение String и Bool, но обладает собственным именем и конструктором. Преимущество такого определения в том, что можно завести много типов с одним и тем же содержимым, но различной семантикой и функциональностью, которые система типов не позволит смешивать между собой.

*
Функция (,,) – это то же самое, что и анонимная функция \x y z –> (x,y,z). В свою очередь, функция (,) – то же самое, что и \x y –> (x,y).

*
Экзистенциальные типы
Неоднородные контейнерные структуры данных (неоднородные типы) позволяют хранить значения различных типов, никак не связанных друг с другом. Задача создания таких структур данных достаточно легко решается в объектно-ориентированном стиле при помощи механизма наследования и динамической диспетчеризации. Но эта же задача оказывается нетривиальной для функциональной парадигмы.
Здесь и приходят на помощь экзистенциальные типы.
Для создания неоднородного списка, который будет содержать все считанные из файла геометрические фигуры, необходимо определить экзистенциальный тип-обёртку:
	data GeoObject = forall a . Figure a => GeoObject a
Квантор всеобщности, обозначаемый в языке Haskell ключевым словом forall, убирает типовую переменную a из области видимости всего типа GeoObject, но при этом указывает, что тип для конкретизации может быть произвольный, главное, чтобы он являлся экземпляром класса Figure.

*
Моноид определяется как множество с бинарной операцией. Все, что требуется от этой операции — её ассоциативность, и наличие единственного специального элемента, который ведет себя как единица по отношению к этой операции.чтобы сократить запись, вместо mappend используют синоним (<>).
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m

instance Monoid String where
    mempty = ""
    mappend = (++)

*
Функтор есть отображение между категориями. Поскольку в программировании мы работаем тольк с 1 категорией - категорией типов, функтор может отображать только из категории типов в категорию типов (один тип в другой тип). Такой функтор называтеся эндофунктор, то есть функтор из категории в себя саму.Что представляет собой эндофунктор в категории типов? В первую очередь, он сопоставляет одним типам другие. Подобные отображения на самом деле нам знакомы, это типы, параметризованные другими типами (напр.Maybe есть отображение типа a в тип Maybe a).
Функтор применяет обычную функцию к значениям в контексте.
В Haskell обличье функтора, отвечающее за отображение морфизмов, реализуется функцией высшего порядка fmap. Для Maybe она имеет следующую сигнатуру:
fmap :: (a -> b) -> (Maybe a -> Maybe b)

class Functor f where
    fmap :: (a -> b) -> f a -> f b  

Оно утверждает, что f есть Functor в том случае, если имеется функция fmap с данной сигнатурой. Здесь f — типовая переменная, того же рода что и типовые переменные a и b. Но компилятор способен понять, что f представляет собой конструктор типов, отслеживая её использование: применение к другим типам, здесь f a и f b. 

Если конструктор типа принимает два параметра, как, например, конструктор Either, мы должны частично применять конструктор типа до тех пор, пока он не будет принимать только один параметр. Поэтому мы не можем написать определение Functor Either where, зато можем написать определение Functor (Either a) where.

Первый закон функторов гласит, что если мы применяем функцию id к значению функтора, то значение функтора, которое мы получим, должно быть таким же, как первоначальное значение функтора. В формализованной записи это выглядит так: fmap id = id. Иными словами, если мы применим fmap id к значению функтора, это должно быть то же самое, что и просто применение функции id к значению.
Например: fmap id (Just 3)
Just 3

Второй закон гласит, что композиция двух функций и последующее применение результирующей функции к функтору должны давать тот же результат, что и применение первой функции к функтору, а затем применение другой. В формальной записи это выглядит так: fmap (f . g) = fmap f . fmap g. Или если записать по-другому, то для любого значения функтора x должно выполняться следующее: fmap (f . g) x = fmap f (fmap g x)

Любой тип, параметризуемый другим типом — кандидат на роль функтора.

*
Аппликативный функтор

Применяет функцию в контексте к значениям в контексте

class (Functor f) => Applicative f where
 pure :: a –> f a
 (<*>) :: f (a –> b) –> f a –> f b

Лучший способ представить себе функцию pure – это сказать, что она берёт значение и помещает его в контекст (или чистый контекст).
<$> - инфиксный аналог pure.

Оператор <*> принимает значение функтора, который содержит в себе функцию, и другой функтор – и извлекает эту функцию из первого функтора, затем отображая с её помощью второй.

Примеры:
ghci> Just (+3) <*> Just 9
Just 12	
ghci> pure (+3) <*> Just 9
Just 12

Мы можем использовать оператор <*> со списками вот так:
ghci> [(*0),(+100),( 2)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
Левый список содержит три функции, а правый – три значения, поэтому в результирующем списке будет девять элементов. Каждая функция из левого списка применяется к каждому элементу из правого. Если у нас имеется список функций, принимающих два параметра, то мы можем применить эти функции между двумя списками.

ghci> (++) <$> ["хa","хeх","хм"] <*> ["?","!","."]
["хa?","хa!","хa.","хeх?","хeх!","хeх.","хм?","хм!","хм."]

ghci>filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
[55,80,100,110]

Оператор <**> - то же, только с перевернутым списком аргументов
[(*0),(+100),( 2)] <*> [1,2,3] =  [1,2,3] <**> [(*0),(+100),( 2)]

*
Монады являются естественным продолжением аппликативных функторов и предоставляют решение для следующей проблемы: если у нас есть значение с контекстом типа m a, как нам применить к нему функцию, которая принимает обычное значение a и возвращает значение с контекстом? Другими словами, как нам применить функцию типа a –> m b к значению типа m a? По существу, нам нужна вот эта функция:
(>>=) :: (Monad m) => m a –> (a –> m b) –> m b
Если у нас есть причудливое значение и функция, которая принимает обычное значение, но возвращает причудливое, как нам передать это причудливое значение в данную функцию? Это является основной задачей при работе с монадами. Мы пишем m a вместо f a, потому что m означает Monad; но монады являются всего лишь аппликативными функторами, которые поддерживают операцию >>=. Функция >>= называется связыванием.

Функция return имеет тип (Monad m) => a –> m a. Она принимает нечто и оборачивает это в монаду.

Есть и еще один возможный способ определения монады. Вместо функции (>>=) определяется функция fmap, а также дополнительно определяется функция join, которая для каждой монады m должна иметь тип m (m a) -> m a.
Функция join принимает монадическое значение в монадическом значении и отдаёт нам просто монадическое значение; другими словами, она его разглаживает. Вот она с некоторыми значениями типа Maybe:
ghci> join (Just (Just 9))
Just 9
ghci> join (Just Nothing)
Nothing
Наверное, самое интересное в функции join – то, что для любой монады передача монадического значения в функцию с помощью операции >>= представляет собой то же самое, что и просто отображение значения с помощью этой функции, а затем использование функции join для разглаживания результирующего вложенного монадического значения! Другими словами, выражение m >>= f – всегда то же самое, что и join (fmap f m).

Обобщая:
(<$>) :: Functor     f =>   (a ->   b) -> f a -> f b
(<*>) :: Applicative f => f (a ->   b) -> f a -> f b
(=<<) :: Monad       f =>   (a -> f b) -> f a -> f b
Все используются для того, чтобы передавать функциям значения с контекстом, тогда как функции ожидают обычные значения на входе.
Функторы используют обычную функцию.
Аппликативные функторы — обычную функцию внутри контекста.
Монады используют функции, которые на выходе имеют значение в контексте.

Самое важное отличие монады от функтора — монады можно комбинировать друг с другом, порождая новые монады и при этом абстрагируясь от того, как именно реализована монада — читает ли она с диска, принимает ли она дополнительные параметры для вычисления своего значения, существует ли это значение вообще. Второй важный момент — монады комбинируются не параллельно, а последовательно, оставляя возможность добавлять логику в зависимости от результата первой монады. Аппликативные функторы комбинируют параллельно.

*
Функция filterM из модуля Control.Monad:
 filterM :: (Monad m) => (a –> m Bool) –> [a] –> m [a]
Предикат возвращает монадическое значение, результат которого – типа Bool, но поскольку это монадическое значение, его контекст может быть всем чем угодно.
Функция liftM из модуля Control.Monad:
 liftM :: Monad m => (a1 -> r) -> m a1 -> m r 
Применяет функцию к монадическому значению (типа fmap для монад)
Вместо нее можно использовать инфиксную функцию ap. Как правило, любой вызов в форме liftMn f x1 x2 ... xn можно заменить выражением f `ap` x1 `ap` x2 `ap` ... `ap` xn

*
Монада State - функция с состоянием
Состояние, предшествующее выполнению функции, может рассматриваться как ее дополнительный аргумент. Тогда если в общем виде у нас
есть функция типа a -> b , то функция, которая также получает состояние типа s, должна иметь тип a -> s -> b . Эта функция в конце ее выполнения должна быть также наделена состоянием, которое впоследствии может быть передано другой функции, ожидающей состояние. При условии, что функция возвращает значение типа b , мы можем добавить в пару к нему значение типа s . В окончательном виде функции, манипулирующие состоянием, имеют тип a -> s -> (b,s) .

*
Монада Writer - объединяет логи
Вы можете использовать tell, чтобы записать что-то в лог. А return передаст значение в Writer. Пример  - функция half:
 half :: Int -> Writer String Int
 half x = do
        tell ("I just halved " ++ (show x) ++ "!")
        return (x `div` 2)

И мы можем использовать runWriter, чтобы извлечь из него значение (обратите внимание на связывание монад) :
 runWriter $ half 8 >>= half
 => (2, "I just halved 8!I just halved 4!")

Монада Writer позволяет нам использовать любой Monoid в качестве лога, а не одни только строки

*
Монада Reader
Функция ask извлекает весь контекст.
Функция asks применяет функцию к контексту и возвращает результат. Эта функция, которая хорошо подходит для запроса конкретного поля структуры,
очень похожа на функцию доступа (если, например, контекст задан в структурированном виде).
Пример:
hello :: Reader String Int
hello = do
    name <- ask
    return $ length name

bye :: Reader String Int
bye = do
    name <- ask
    return $ length . words $ name

convo :: Reader String String
convo = do
    c1 <- hello
    c2 <- bye
    return $ "full length:" ++ show c1 ++ ", words:" ++ show c2

main = print . runReader convo $ "adit boo"

*
Монады IORef и ST
Используются для реализации мутабельности. Причем ST позволяет скрывать всю работу с мутабельностью внутри монады. Примеры:
1.
main :: IO ()
main = do
	box <- newIORef (4 :: Int)
	modifyIORef box (2*)
	readIORef box >>= print

2.
import Control.Monad.ST
import Data.STRef
import Data.Foldable

sumST :: Num a => [a] -> a
sumST xs = runST $ do
    n <- newSTRef 0
    for_ xs $ \x ->
        modifySTRef n (+x)
    readSTRef n

Обратите внимание, что функция sumST - чистая

*
Свободные монады — это просто общий способ превращения функторов в монады. То есть, если любой функтор f Free f является монадой. Это было бы не очень полезно, если бы вы не получили пару функций
 liftFree :: Functor f => f a -> Free f a
 foldFree :: Functor f => (f r -> r) -> Free f r -> r
первый из них позволяет вам «войти» в вашу монаду, а второй — как «выйти» из нее.
В более общем смысле, если X — это Y с некоторыми дополнительными элементами P, то «свободный X» — это способ перехода от Y к X без получения чего-либо дополнительного. Конструктор Free применяется, когда за одной операцией следует список других операций, а конструктор Pure служит меткой окончания вычислений.

*
Comonad – это тоже класс типов, который позволяет функциям взаимодействовать с эффектами комонады, только у этих функций комонада указывается не в возвращаемом типе, а в аргументе. 

*
Монадные трансформеры
Наиболее предпочтительным в Haskell способом объединения эффекта применения нескольких монад в новой монаде является использование монадических преобразователей (monad transformers).
Формально монадический преобразователь — это тип данных со следующей структурой:
  MonadT e 1 ... e n m a
где:
- MonadT — это имя монадического преобразователя. Оно обычно совпадает с именем монады, эффект применения которой добавляет преобразователь. Например, монада StateT добавляет к другой монаде функциональность состояния, ListT — недетерминизм, ReaderT — контекст только для чтения и т.д.
- e 1 ... e n — это дополнительные переменные типа, в которых может нуждаться монадический преобразователь
- В позиции переменной типа m указывается монада преобразуемая, или заключаемая в оболочку (оба понятия используются как взаимозаменяемые).
- Результатом MonadT e 1 .. . e n m должна стать монада как таковая, следовательно, она получает дополнительный параметр a, чтобы придать ей, как и ожидалось, вид * -> * .
Все монадные трансформеры должны имплементировать класс типов MonadTrans,определенный в Control.Monad.Trans.Class:
class MonadTrans t where
 lift :: Monad m => m a -> t m a
Пример:
 readerWriterExample :: ReaderT Int (Writer String) Int
 readerWriterExample = do x <- ask
 lift . tell $ show
Первая монада будет внешним слоем (и поэтому для использования функции tell, работающей в слое Writer, понадобится функция lift).
Одно из правил гласит, что эффекты интуитивно помещаются в стек монад в порядке, обратном тому, в котором они появляются в луковице преобразователя: монада StateT s [] сначала добавляет состояние ко всему остальному, а затем результаты с состоянием заключаются в оболочку недетерминизма; в то время как монада ListT (State s) сначала добавляет к результату недетерминизм, а затем состояние — ко всему остальному.
Еще пример: 
 StateT s Maybe a = s -> Maybe (a , s)  - неудача влияет как на результат, так и на состояние: либо все вычисления терпят неудачу, либо они проходят удачно.
 MaybeT (State s) a = (State s) (Maybe a) = s -> (Maybe a , s) , то есть неудача влияет только на результат, но не на сохраняемое внутреннее состояние.

*
Ассоциированные типы через семейство типов
Основная идея семейства типов — устанавливать некоторую ассоциацию между двумя различными типами. Чтобы этого добиться, нам нужно ввести некоторый ассоциированный тип, чтобы указать, каково содержимое определённого типа.
{-# LANGUAGE TypeFamilies #-}

class SafeHead a where
type Content a
safeHead :: a -> Maybe (Content a)

instance SafeHead [a] where
type Content [a] = a
safeHead [] = Nothing
safeHead (x:_) = Just x

instance SafeHead S.ByteString where
type Content S.ByteString = Word8
safeHead bs
| S.null bs = Nothing
| otherwise = Just $ S.head bs

Возможность разместить декларации типа ( type ) внутри класса и экземпляра

*
Обобщеннные алгебраические типы данных  - GADT
Каждый из конструкторов типа данных может возвращать для определяемого типа разное множество параметров типа (то есть в определении Expr a t можно возвращать Expr a Bool , Expr Int Int и т. д., но не Offer Char ).
Синтаксис начинается с такого же ключевого слова data, за которым следуют имя и тип переменных определяемого типа. Но вместо знаков равенства нужно указать ключевое слово where и перечислить конструкторы посредством их сигнатур.
Выражение GADT-типа выглядит следующим образом:

{-# LANGUAGE GADTs #-}
data Expr a r where
AmountOf :: a -> Expr a Integer
PriceOf  :: a -> Expr a Float и т.д.

Хотя в данном случае создание тегов для типов осуществляется с использованием встроенных типов из пакета Prelude, ничто не мешает нам использовать и другие типы. Мы можем строить новые типы данных, чьим единственным предназначением будет создание тегов для других типов. Тогда в объявлении нам даже не понадобятся какие-либо конструкторы, поскольку они никогда не будут использоваться. Если включить расширение EmptyDataDecls , можно будет создавать пустые объявления data:

{-# LANGUAGE EmptyDataDecls, GADTs #-}
data AllowEverything
data AllowProducts
data AllowPurchases
data Person = Person :: { firstName :: String, lastName :: String }
data User r where
Admin 		:: Person -> User AllowEverything
StoreManager 	:: Person -> User AllowEverything
StorePerson 	:: Person -> User AllowProducts
Client		:: Person -> User AllowPurchases

Теперь для того, чтобы потребовать значение с тегом правильного типа, может быть определена функция, которую будут вызывать только те, кому доступно все:
changePurchaseFinalPrice :: User AllowEverything -> Purchase -> Float -> Purchase
changePurchaseFinalPrice = ...
