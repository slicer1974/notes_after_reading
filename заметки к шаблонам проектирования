Принцип проектирования 1: 
Выделите аспекты приложения, которые могут изменяться, и отделите их от тех, которые всегда остаются постоянными.
2:
Программируйте на уровне интерфейсов, а не на уровне реализации. В коде, использующем классы, должны встречаться по большей мере ссылки на абстрактные классы и интерфейсы. Реализация осуществляется только при создании экземпляров конкретных классах. 

Принцип инверсии зависимости:
* Ссылки на конкретные классы не должны храниться в переменных
* В архитектуре не должно быть классов, производных от конкретных классов
* Методы не должны переопределять методы, реализованные в каких-либо из его базовых классов

Порождающие паттерны:
	Абстрактная фабрика - абстрактный предок конкретной фабрики. Клиент связан с абстрактной фабрикой, вызывает методы создания объекта из абстрактной фабрики, полиморфически вызывая методы конкретной реализации фабрики, которая создает продукты для клиента. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.
	Фабричный метод - Паттерн решает задачу определения некоторого интерфейса по созданию класса, конкретную реализацию которого определяют дочерние классы, реализующие данный интерфейс. В отличие от абстрактной фабрики, фабричный метод оперирует созданием одного единственного объекта, а не семейства. Пример у меня - zcl_alu_document_types=>instance_by_type
	Строитель - замена телескопического конструктора.Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. Паттерн подходит для ситуаций, когда процесс создания продукта является сложным и состоит из нескольких этапов, при этом одним клиентам нужны одни параметры создаваемого продукта, другим другие. Пример у меня - создание XML.
	Прототип - создание новых объектов через клонирование существующего базового и доп.инициализацию. В ABAP есть встроенный механизм для копирования объектов реализован через системный вызов (см. класс cl_os_state)
	Одиночка - гарантирует, что у класса всегда будет существовать только один экземпляр, и предоставляет глобальную точку доступа к нему.
Приватный конструктор,приватная статическая переменная, содержащая экземпляр и статический метод, либо создающий экземпляр либо возвращающий переменную.

Поведенческие паттерны - позволяют управлять поведением объектов:
	Стратегия - позволяет динамически вызывать переопределенные методы из потомков через вызов метода базового класса. Пример у меня - вызов дочерних методов check_before_modify через передачу интерфейса	
	Посетитель - добавляет операции к некоторой иерархии классов, где в зависимости от класса операции могут отличаться.Позволяет вынести часть операций в методы вызываемого внешнего класса. В методе вызывающего класса вызывается метод переданного экземпляра внешнего класса (посетителя). На вход методу посетителя передается экземпляр вызывающего класса. Поскольку можно передавать разных посетителей, объединенных общим интерфейсом, можно вынести вариативную часть класса во внешние методы и передавать их экземпляры.(+) Позволяет расширять и изменять операции и их количество, не затрагивая исходный класс. (-) Размывает бизнес-логику
	Шаблонный метод определяет основу алгоритма (каркас, например используемые шаги алгоритма и последовательность их вызова) и позволяет подклассам переопределять некоторые шаги алгоритма, не изменяя его структуры в целом. 
	Наблюдатель - позволяет определить зависимость «один-ко-многим» так, что при изменении одного объекта, все зависимые от этого изменения объекты были оповещены об этом. В ABAP паттерн реализуется через подписку на события объекта
	Итератор - предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления. Итератор предоставляет абстрактный интерфейс для доступа к содержимому составных объектов, не раскрывая клиентам их внутреннюю структуру.
	Медиатор(посредник) - определяет объект, инкапсулирующий способ взаимодействия множества объектов друг с другом, тем самым, избавляя их от необходимости явно ссылаться друг на друга, уменьшая при этом сложность системы - связь с другими объектами через промежуточный

Структурные паттерны рассматривают вопросы о компоновке системы на основе классов и объектов (наследование или композиция). К структурным паттернам относятся:
	Компоновщик - описывает интерфейс, позволяющий работать с группой объектов или отдельным объектом одинаково.
	Приспособленец — это экземпляр объекта, который выдаёт себя за группу самостоятельных экземпляров.
Используется, когда:
	В приложении используется большое число очень похожих друг на друга экземпляров заданного класса;
	Часть состояния объекта является контекстной и может быть легко вынесена во внешние структуры;
	После вынесения части состояния все объекты становятся одинаковыми и это даёт возможность заменить их одним;
В результате использования шаблона создаётся гораздо меньше экземпляров, что влечёт за собой экономию ресурсов.
При проектировании приспособленца необходимо разделить его свойства на внешние и внутренние. Внутренние свойства всегда неизменны, тогда как внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца.
	Фасад - предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который облегчает использование подсистемы.Как правило, фасад используется для создания оболочек над какими-либо библиотеками, для того чтобы упростить их использования в рамках специфических задач приложения, либо чтобы избежать лишних зависимостей, которые со временем могут измениться.
	Адаптер - класс-обертка. Есть некоторые разрозненные классы, которые поддерживают требуемые данные и поведения, однако они не предоставляют необходимого интерфейса для взаимодействия с ними. Для этого Вам необходимо создать класс обёртку с нужным интерфейсом, который внутри себя будет инкапсулировать те самые разрозненные классы, и переадресовывать вызовы из нужного Вам интерфейса к ним.
	Декоратор - паттерн предназначается для динамического подключения дополнительного поведения (состояния) к объекту. Благодаря этому шаблону, можно избежать создания кучи ненужных подклассов с целью расширения функциональности.Класс декоратора - дочерний по отношению к базовому. Инициализация: lref_component = new декоратор1( component = new decorator2( component = new базовый())).Внутри декоратора сохраняется ссылка на экземпляр базового класса. В классе декоратора методы базового класса переопределяются, внутри вызывается метод базового класса через хранимую ссылку.
	Мост - позволяет отделить абстракцию от реализации так, что и то, и другое можно было бы изменять независимо, путём помещения абстракции и реализации в отдельные иерархии классов. Если число наследников велико, систему становится сложно поддерживать. Берем базовый класс, выделяем из него некую абстракцию, подверженную изменениям, и помещаем в отдельную иерархию, связанную с базовым классом через композицию. Позволяет расширять иерархии без перемножения. Пример у меня: notes, originals.

