	Сделайте код работающим, а потом решайте, как он будет структурирован.

	При выборе видимости у вас есть две цены. Одна из них — цена будущей гибкости. Очень узкий интерфейс облегчает будущие изменения. Вторая цена — это затраты при вызове объекта. Слишком тесный интерфейс заставляет всех клиентов делать больше работы, чем необходимо при использовании вашего объекта. Соблюдение баланса в этом вопросе — отправная точка к хорошим решениям относительно видимости. Общая рекомендация - максимальное ограничение видимости.

	Программирование путем копирования и вставки текста нарушает один из главных принципов разработки программ: 
Каждая существенная область функциональности в программе должна быть реализована всего в одном месте программного кода. Если различные фрагменты кода реализуют аналогичную функциональность, то, как правило, имеет смысл слить их в один фрагмент, абстрагируя (abstracting out) различающиеся части.



	__Концевой вызов__ получается, когда своим последним действием функция возвращает результат вызова функции. Другими словами для концевой рекурсии последним должен быть вызов функции. В следующем примере continuize — это фабрика, получающая тип функции any и возвращающая функцию hero. Функция hero вы- зывает any и передает возвращаемое значение функции continuation: 
#function continuize(any) { 
#	return function hero(continuation, …args) { 
#		return continuation(any(…args));		// <-- концевой вызов 
#	}; 
#}
	При оптимизации концевых вызовов рекурсивные вызовы способны стать такими же быстрыми, как и циклы. С функциональной точки зрения это важно, потому что циклы по своей природе не относятся к чистому коду. Чистота приходит с рекурсией. Благодаря данной оптимизации аргумент снижения производительности при рекурсии сведен на нет.
Концевая рекурсивная функция может иметь следующий вид: 
#(function loop() { 
#	выполнение каких-либо действий 
#	if (done) { 
#		return; 
#	} 
#	выполнение дополнительных действий 
#	return loop();	 // <-- концевой вызов 
#}()); 
	В целом рекурсивные функции будут выглядеть более элегантно, чем циклы, передавая обновленное состояние в параметрах и возвращая значения вместо реализации при- сваивания.


__Продолжения и поток управления__
Продолжения представляют собой математическое обоснование всего порядка выполнения программы, от goto и циклов до рекурсии, исключений, генераторов, сопрограмм и механизма возврата. Как следствие, они позволяют реализовать все эти элементы в языке посредством единой конструкции. 
При выполнении вычислений в стиле продолжений (continuation-passing style, CPS) результат функции не возвращается, а передается в другую функцию, передаваемую как параметр (продолжение).
Продолжения материализуют "следующий шаг" - превращают его в нечто, с чем вы можете работать. В прямом стиле функция беспомощна относительно того, что случится после ее вызова, а в случае продолжений, она имеет полный контроль. Так называемая "инверсия управления". Давайте рассмотрим более детально управление потоком обоих стилей.

__Прямой стиль__. Вы вызываете функцию и она должна вернуть результат, она не может избежать вложенностей, которые бывают при вызове функций. Следующий код имеет два таких вызова: f вызывает g который вызывает h.
#function f() {
#   console.log(g());
#}
#function g() {
#   return h();
#}
#function h() {
#    return 123;
#}

__Стиль продолжений__. Функция определяет, что нужно делать дальше. Она может продолжить как "приказано" или сделать что-нибудь совсем другое. Следующий код демонстрирует версию предыдущего примера в стиле продолжений.
#function f() {
#    g(function (result) {
#        console.log(result);
#    });
#}
#function g(success) {
#    h(success);
#}
#function h(success) {
#    success(123);
#}
Теперь поток управление совсем отличается. f вызывает g, он вызывает h, который потом вызывает продолжение g', которое далее вызывает f'.

Стандартная библиотека Haskell содержит монаду Cont, которая позволят обернуть CPS в монаду:
#newtype Cont r a = Cont { runCont :: (a -> r) -> r }
#instance Monad (Cont r) where
#    return a = Cont ($ a)
#    m >>= k  = k a
#            where a = runCont m id

Например, функция, вычисляющая длину гипотенузы прямоугольного треугольника по длинам катетов, будет выглядеть следующим образом:
#import Control.Monad.Cont
#add :: Float -> Float -> Float
#add x y = x + y

#add_cps :: Float -> Float -> ((Float -> r) -> r)
#add_cps x y = \k -> k (add x y)

#sqrt_cps :: Float -> ((Float -> r) -> r)
#sqrt_cps x = \k -> k (sqrt x)

#pow2_m :: Float -> Cont a Float
#pow2_m a = return (a ** 2)

#-- функция cont поднимает обычные CPS функции в монаду
#pyth_m :: Float -> Float -> Cont a Float
#pyth_m a b = do
#  a2 <- pow2_m a
#  b2 <- pow2_m b
#  anb <- cont $ add_cps a2 b2 
#  r <- cont $ sqrt_cps anb
#  return r

#main :: IO()
#main = do 
#		runCont ( pyth_m 3 4 ) print

