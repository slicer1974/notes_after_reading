В тексте приложения не должно быть вызовов функций представления ИЗ кода бизнес-логики или источника данных.

Три варианта организации бизнес-логики:
	Верхний уровень:
		Сценарий транзакции - процедура, которая получает на вход информацию от слоя представления, обрабатывает ее, проводя необходимые проверки и 			вычисления, сохраняет ее в базе данных и активирует операции других систем. 
			+ Простая процедурная модель, четкие границы транзакций, легкая 	интеграция с БД SQL
			- С возрастанием сложности увеличивается кол-во дублирований, код становится плохо структурированным
		Модель предетной области - ОО вариант. Выделяются отдельные сущности для реализации специфических действий.
			+ Прекрасно реализует бизнес-логику любой сложности.
			- Сложна в разработке, сложная интеграция с БД SQL
		Модуль таблицы - промежуточный вариант. Объект представляет собой множество записей таблицы. Типовой вариант для .NET
			+ Хорошо реализуется в системах, предусматривающих соответствующую
			функциональность по работе с записями таблицы БД
			- Не позволяет использовать многие технологии ОО (наследование, стратегии и.т.д )
	 
	Для вариантов "модель предметной области" и "модуль таблицы" обычным подходом является расщепление слоя предметной области на два самостоятельных слоя: "поверх" модели предметной области или модуля таблицы располагается СЛОЙ СЛУЖБ. Логика слоя представления взаимодействует с бизнес-логикой исключительно при посредничестве слоя служб, который действует как API приложения. 
	Основное решение, принимаемое при проектировании слоя служб - какую часть функций уместно передать в его ведение. Самый минимальный вариант - только перенаправление вызовов к нижележащему слою (службы отвечают только за проверку безопасности и управление транзакциями). Другая крайность - в рамках слоя служб разместить большую часть логики в виде СЦЕНАРИЕВ ТРАНЗАКЦИИ. Автор склоняется к минимальному слою служб либо исключению его вообще.

	Для работы с SQL таблицами со стороны бизнес-логики применяются следующие решения:
		Шлюз строки данных - для работы с базой построчно - хорошо сочетется со
		сценарием транзакции
		Шлюз таблицы данных - для работы с группами записей базы - для модуля таблицы
		Для простой модели предметной области - Активная запись (шлюз записи + немного
		бизнес-логики)
		Для сложной содели предметной области - Преобразователь данных (обслуживает
		все операции загрузки и сохранения информации, инициируемые бизнес-логикой и
		позволяет варьировать как модель предметной области  так и схему данных) 
	

При оптимистическом блокировании сеансу разрешается зафиксировать изменение записи в базе данных, если со времени, прошедшего после загрузки этой записи текущим сеансом, она не была изменена никаким другим сеансом. Оптимистическая автономная блокировка может быть применена в любое время, однако срок ее действия ограничивается системной транзакцией, в процессе которой она была установлена. Таким образом,чтобы выполнение бизнес-транзакции не привело к утрате изменений или несогласованности данных, следует применять оптимистическую автономную блокировку к каждой записи, изменяемой во время системной транзакции.
Наиболее распространенный прием отслеживания изменений — сохранение вместе скаждой записью номера ее версии. После загрузки такой записи номер ее версии будет сохраняться вместе с остальными элементами состояния сеанса. Наложение оптимистической автономной блокировки состоит в сравнении номера версии, хранящегося в состоянии сеанса, с текущим номером версии этой же записи в базе данных. Если проверка пройдет успешно, текущий пользователь сможет зафиксировать в базе данных все изменения, включая и увеличенный номер версии. Последнее позволит избежать несогласованности данных, поскольку любой другой сеанс с более старой версией записи уже не сможет получить блокировку и зафиксировать свои изменения.

Если вероятность конфликта довольно высока или откат проделанных изменений неприемлем, имеет смысл прибегнуть к пессимистической автономной блокировке.В пессимистической схеме блокирования бизнес-транзакция накладывает блокировку на данные прежде, чем начинает с ними работать, поэтому пользователь может быть уверен, что завершит транзакцию без негативных последствий со стороны параллельных процессов.
Пессимистическая автономная блокировка применяется тогда, когда вероятность возникновения конфликта между параллельными сеансами достаточно высока. Пользователь никогда не должен переделывать свою работу. К пессимистической схеме блокирования следует обращаться и в том случае, когда стоимость ликвидации последствий конфликта слишком велика независимо от природы последнего. Разумеется, блокирование каждой сущности в системе почти наверняка спровоцирует огромную конкуренцию доступа к данным, поэтому пессимистическая автономная блокировка должна рассматриваться как дополнение к оптимистической автономной блокировке и применяться только тогда, когда без нее действительно не обойтись.

Применение блокировки записи вместо блокировки чтения может привести к получению устаревших данных, а неправильное использование номера версии —
к нежелательной перезаписи изменений, внесенных кем-то другим. Общее правило гласит: если элемент может быть заблокирован где-нибудь, он должен быть заблокирован везде. Игнорирование отдельной бизнес-транзакцией стратегии блокирования, применяемой в приложении, способно привести к появлению несогласованных данных. Несвоевременное снятие блокировки, разумеется, не приведет к порче данных, однако сведет на нет производительность приложения.

Для реализации неявной блокировки необходимо вынести код, который никак нельзя пропустить при описании схемы блокирования, в инфраструктуру приложения.Прежде всего для обеспечения неявной блокировки необходимо составить список процедур, которые являются обязательными в рамках конкретной стратегии блокирования.При использовании оптимистической автономной блокировки (Optimistic Offline Lock, 434) этот список будет содержать такие операции, как сохранение номера версии для каждой строки базы данных, включение проверки номера версии в критерии SQL-операторов
UPDATE и DELETE и увеличение номера версии при изменении соответствующего объекта. В свою очередь, при использовании пессимистической автономной блокировки (Pessimistic Offline Lock, 445) список необходимых операций будет включать в себя применение блокировки перед загрузкой каждого необходимого объекта (как правило, это касается монопольной блокировки чтения и части блокировки чтения/записи, применяющейся для считывания объекта) и высвобождение всех блокировок по окончании сеанса или бизнес-транзакции. Неявную блокировку следует применять во всех приложениях (за исключением, пожалуй, самых простых, не имеющих инфраструктуры). Задумайтесь: риск забыть какую-нибудь блокировку слишком велик, чтобы им можно было пренебречь.
