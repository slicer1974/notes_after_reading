	Разбейте сложную программу на уровни. Виды уровней: интерфейс пользователя, операционный, предметной области, инфраструктурный. Внутри каждого уровня разработайте связную структуру, полагающуюся только на нижние уровни и зависящую только от них. Чтобы обеспечить связь с верхними уровнями, используйте стандартные архитектурные шаблоны. Сосредоточьте весь код, относящийся к предметной области, в одном уровне, и изолируйте его от кода интерфейса пользователя, прикладных операций и инфраструктуры. 

	Если объект определяется уникальным индивидуальным существованием, а не набором атрибутов, это свойство следует считать главным при определении объекта в модели.Такой объект будет ОБЪЕКТОМ-СУЩНОСТЬЮ. Задайте операцию, которая бы обязательно давала неповторимый результат для каждого такого объекта, - возможно для этого с объектом придется ассоциировать некий символ с гарантированной уникальностью. Такое средство идентификации может быть внешним либо внутренним по отношению к системе. Однако такое средство должно соответствовать правилам различения объектов в модели. Именно уникальный идентификатор и характеристики изменчи­вости отличают СУЩНОСТИ от ОБЪЕКТОВ-ЗНАЧЕНИЙ (VALUE OBJECTS) . Соответственно __одинаковыми ОБЪЕКТАМИ-СУЩНОСТЯМИ считаются объекты с одинаковыми уникальными идентификаторами__.

	Объекты, определяющие равенство по значению свойств, называются ОБЪЕКТАМИ-ЗНАЧЕНИЯМИ. В модели должно даваться ТОЧНОЕ определение, что такое ОДИНАКОВЫЕ ОБЪЕКТЫ. Обычно одинаковыми считаются при совпадении значений всех полей.
	__Если элемент модели полностью определяется своими атрибутами, то его следует считать ОБЪЕКТОМ-ЗНАЧЕНИЕМ__. Это объекты, которые используются для описаний предметов и явлений. Они не имеют собственной уникальной идентичности, значимой для модели. Достаточно знать, ЧТО они из себя представляют, а не ЧЕМ ИМЕННО они являются.
	При моделировании по возможности следует ис­пользовать ОБЪЕКТЫ -ЗНАЧЕНИЯ, а не СУЩНОСТИ !!!
	Решая, является ли понятие ЗНАЧЕНИЕМ, следует выяснить, обладает ли оно большинством из следующих характеристик. 
		• Оно измеряет, оценивает или описывает объект предметной области. 
		• Его можно считать неизменяемым. 
		• Оно моделирует нечто концептуально целостное, объединяя связанные атрибуты в одно целое. 
		• При изменении способа измерения или описания его можно полностью заменить. 
		• Его можно сравнивать с другими объектами с помощью отношения равенства ЗНАЧЕНИЙ. 
		• Оно предоставляет связанным с ним объектам ФУНКЦИЮ БЕЗ ПОБОЧНЫХ ЭФФЕКТОВ [Эванс] .
	Истинный ОБЪЕКТ - ЗНАЧЕНИЕ в модели - это не элемент предметной области. На самом деле это понятие, которое измеряет, определяет количество или как-то иначе описывает элемент предметной области. 
	Объект, являющийся ЗНАЧЕНИЕМ, после создания остается неизменным.
	Иногда объект нецелесообразно делать неизменяемым. Это очень хорошо и свидетельствует о том, что объект следует моделировать как СУЩНОСТЬ . 
	
	Объекты-значения имеют тенденцию множиться. В этом случае можно применить шаблон Приспособленец.

	Некоторые понятия модели нестественны в роли объектов. Если принудительно реализовать нужные функции модели в ОБЪЕКТЕ-СУЩНОСТИ или ОБЪЕКТЕ-ЗНАЧЕНИИ, это либо исказит определение объекта из модели, либо добавит в модель лишних, искусственно сконструированных объектов. Если существенно важный процесс или преобразование в модели не относятся к естественным обязанностям ОБЪЕКТА-СУЩНОСТИ или ОБЪЕКТА-ЗНАЧЕНИЯ, добавьте в модель эту операцию с отдельным интерфейсом и назовите ее СЛУЖБОЙ. Определите интерфейс на языке модели и сделайте имя операции элементом ЕДИНОГО ЯЗЫКА. У СЛУЖБЫ не должно быть собственного состояния. Интерфейс СЛУЖБЫ определен через другие элементы модели предметной области.
	Нужно четко определять, к какому уровню относятся службы - предметной области, инфраструктурному или операционному.

	При проектировании с большим количеством ссылок на объекты возникают сложности при оперировании сущностями. В этом случае поможет проектирование с помощью АГРЕГАТОВ, ФАБРИК и ХРАНИЛИЩ.
	__Агрегат__ - совокупность взаимосвязанных объектов, которые мы воспринимаем как единое целое с точки зрения изменения данных. У каждого Агрегата есть корневой объект и есть граница. Корневой объект - это один конкретный объект-Сущность, содержащийся в Агрегате. В границы Агрегата включаются связанные с ним объекты-Значения и объекты-Сущности.
 	Граница агрегата определяется для каждого включенного в Агрегат объекта-Сущности на основании факта, является ли включенный в агрегат некорневой объект самостоятельной сущностью предметной области (например, существуют запросы, которые опираются на некорневой объект как на основной). В этом случае некорневой объект необходимо выделить как корневой объект отдельного Агрегата.
 	__Корневой объект__ - единственный член Агрегата, на который могут ссылаться внешние объекты, в то время как объекты, заключенные внутри границы, могут ссылаться друг на друга. Только корневые объекты Агрегатов можно непосредственно получать по запросам из базы данных. Все остальные объекты разрешается извлекать только по цепочке связей. При любом изменении состояния нужно требовать удовлетворения всех инвариантов для объектов в Агрегате и для всего Агрегата в целом. 
	__Фабрика__ - объект, для создания сложных Агрегатов.
	__Хранилище__ - объект, реализующий поиск Агрегатов по атрибутам. Реализуйте методы, которые будут выбирать объекты по заданным критериям и возвращать полностью сгенерированные и инициализированные объекты или коллекции объектов с атрибутами, подходящими под критерии, таким образом инкапсулируя реальные технологии хранения данных и выполнения запросов. Ключевыми объектами Хранилищ являются корневые объекты Агрегатов.

	Шаблон __Спецификация__ нужен для включения в предметную область правил прикладной модели. Спецификация - это предикат, который определяет,удовлетворяет ли объект некоторым критериям. Применение спецификаций: 
1. Проверить пригодность объекта для удовлетворения какой-то потребности или достижения какой-то цели
2. Выбрать объект по какому-то критерию из коллекции ему подобных
3. Заказать создание нового объекта для определенных потребностей

	Давайте такие имена классам и операциям, чтобы они описывали их назначение и получаемый результат, но не способ выполнения ими своих функций. Если раскрывается внутрений механизм работы - теряется смысл инкапсуляции.

	Контролируйте побочные эффекты функций, вынося сложные вычисления в Объекты-Значения, если для таких операций имеются соответствующие концептуальные понятия.

	Если побочные эффекты операций определены в их реализации только неявно, то в архитектурах с интенсивной передачей управления возникает сложное переплетение причин и следствий. Единственным способом понять программу становится трассировка ее выполнения по всем возможным ветвям. При этом теряется смысл инкапсуляции, а необходимсть в трассировке выполнения делает бессмысленным также и абстрагирование.

	Разбивайте элементы архитектуры (операции,интерфейсы, классы и АГРЕГАТЫ) на связные единицы, учитывая свое интуитивное понимание смысловых границ предметной области. Наблюдайте за направлениями изменений и осями стабильности в ходе последовательного рефакторинга, ищите КОНЦЕПТУАЛЬНЫЕ КОНТУРЫ, по которым происходит расслоение между ними. Прежде всего согласуйте модель с теми логически последовательными и стройными аспектами предметной области, которые делают данную область жизнеспособной, практически ценной.


	Предметная область состоит из __пространства задач__ и __пространства решений__.

	Пространство задач - это части ПРЕДМЕТНОЙ ОБЛАСТИ, которые необ­ходимо выделить, чтобы создать новое СМЫСЛОВОЕ ЯДРО. Исследование пространства задач подразумевает изучение ПОДОБЛАСТЕЙ, которые уже существуют и которые должны существовать. Таким образом, ваше про­странство задач - это комбинация СМЫСЛОВОГО ЯДРА и ПОДОБЛАСТЕЙ, которые это ядро должно использовать. 
	Пространство решений состоит из одного или нескольких ОГРАНИЧЕННЫХ КОНТЕКСТОВ, набора конкретных моделей программного обеспечения. Это объясняется тем, что разработанный ОГРАНИЧЕННЫЙ КОНТЕКСТ - это конкретное решение, т.е. представление реализации. ОГРАНИЧЕННЫЙ КОНТЕКСТ используется для реализации решения в виде программного обеспечения.
	ОГРАНИЧЕННЫЙ КОНТЕКСТ - это явная граница, внутри которой существует мо­дель предметной области. Внутри этой границы все термины и фразы ЕДИНОГО ЯЗЫКА имеют специфическое значение, а модель точно отражает ЯЗЫК. Например: в ПРЕДМЕТНОЙ ОБЛАСТИ контекста сотрудничества эксперты не описывают людей, которые используют средства сотрудничества, как пользователей с полномочиями. Скорее они говорят об этих сотрудниках с точки зрения ролей, которые они играют в КОНТЕКСТЕ - авторы, владельцы, участни­ки и модераторы. Если вы видите одни и те же объекты во многих контекстах, это, вероятно, означает, что сделана определенная ошибка мо­делирования, за исключением ситуаций, когда два ОГРАНИЧЕННЫХ КОНТЕКСТА используют ОБЩЕЕ ЯДРО (SНARED КERNEL).

	В ходе анализа нужно извлечь из предметной области ее фундаментальные понятия и представить их понятным и выразительным образом. А в ходе проектирования архитектуры следует задать набор компонентов в выбранной среде программирования, эффективно и правильно решающих задачи. Модель, таким образом, должна отражать идеи предметной области и, одновременно, собюдать принципы проектирования ПО. Чтобы плотно привязать программную реализацию к модели, обычно требуются средства разработки и языки программирования, поддерживающие парадигму моделирования - например, объектно-ориентированное программирование.

 	В процессе разработки полезных моделей необходимо понять три истины:
1. Создание сложных, хорошо проработанных моделей предметных областей возможно, и они стоят затраченного на них труда.
2. Практически не существует другого способа построить такую модель, кроме итерационного процесса рефакторинга с тесным взаимодействием между специалистами предметной области и программистами, желающими узнать о ней больше.
3. Реализация и успешное использование таких моделей могут потребовать высокой квалификации в области проектирования и моделирования.

	Слушайте язык на котором говорят специалисты предметной области. Есть ли у них термины, которые кратко выражают нечто сложное? Поправляют или они Вас? Исчезает ли у них с лиц выражение озадаченности, когда вы употребляете какую-то конкретную фразу? Все это - намеки на существование понятия, которое может оказаться полезным для модели. Когда пользователи программы или специалисты в предметной области пользуются лексиконом, которого нет в модели - это тревожный знак. А еще более тревожный - когда термины, отсутствующие в модели, употребляют как разработчики, так и специалисты. 

	Полная унификация модели предметной области для большой системы либо невозможна, либо неоправданно затратна.

Шаблон __Предметная область__ хорошо подходит для сложных предметных областей. Понятия предметной области инкапсулируются в объекты, содержащие и данные и описание поведения.
Шаблон __Сценарий транзакции__ организует всю предметную логику для реализации бизнес-процессов в процедурные модули.
Шаблон __Модуль таблицы__ представляет модель данныхв форме объекта. Этот шаблон хорошо подходит для моделей, сконструированныхна основе данных и наиболее точно отражающих схемы данных.
Шаблон __Активная запись__ похож на шаблон Модуль таблицы в том, что ставит  на первое место данные, но объекты представляют собой строки в таблицах, а не сами таблицы.ТАкой шаблон хорошо подходит для для моделей с простой логикой, широко использующих CRUD-операции.
Шаблон __Анемичная предметная область__ напоминает шаблон Предметная область, но в этом шаблоне модель полностью лишена поведения. Она моделирует исключительно состояние объекта, а вся логика  размещается в обслуживающих классах.

__Богатая модель__ - данные и методы обработки (не сеттеры, а полноценные методы с соблюдением консистентности модели) объединены в один класс.
__Бедная (анемичная) модель__ - данные отделены от методов.

	Контекст модели - это некий набор условий, которые должны выполняться, чтобы можно утверждать, что термины модели имеют четкий смысл.
Явно определите контекст, в котором применима модель . Явным образом устано­вите границы в соответствии с организационной структурой группы, особенностями операций в разных частях приложения , организацией баз кода и данных . Строго сле­дите за самосогласованностью модели в установленных границах, не отвлекайтесь на внешние по отношению к ним проблемы.
	Определите все модели, используемые в проекте, и задайте для каждой свой ОГРАНИЧЕННЫЙ КОНТЕКСТ. Учитывайте и неявные модели подсистем, не являющихся объектно-ориентированными. Дайте каждому ОГРАНИЧЕННОМУ KOНTEKCTY имя и включите эти имена в ЕДИНЫЙ ЯЗЫК проекта. Опишите точки соприкосновения между моделями, явно задавая трансляцию для любого способа коммуникации и выделяя любые совместно используемые ресурсы. Постройте карту уже существующей территории. Преобразованиями займетесь потом. Внутри каждого ОГРАНИЧЕННОГО КОНТЕКСТА у вас будет свой самодостаточный диа­лект ЕДИНОГО ЯЗЫКА. Имена ОГРАНИЧЕННЫХ КОНТЕКСТОВ сами тоже войдут в ЕДИНЫЙ ЯЗЫК, чтобы можно было недвусмысленно выражаться относительно модели любой из частей архитектуры, ясно задавая контекст разговора.

	Способы организации взаимосвязи между ограниченными контекстами:

	1. ОБЩЕЕ ЯДРО 
ОБЩЕЕ ЯДРО ( SHARED KERNEL ) часто представляет собой СМЫСЛОВОЕ ЯДРО предмет­ной области ( CORE DOMAIN ) , набор ЕСТЕСТВЕННЫХ ПОДОБЛАСТЕЙ ( GENERIC SUB­DOMAINS ) или то и другое одновременно (см. главу 15). Но в принципе оно может пред­ ставлять собой любую часть модели, которая требуется каждой из двух рабочих групп. Здесь ставится цель уменьшить дублирование работы (но не полностью устранить его, как это было бы в случае одного ОГРАНИЧЕННОГО КОНТЕКСТА) и сделать интеграцию между двумя подсистемами сравнительно простой.

	2. ГРУППА "3АКА3ЧИК-ПОСТАВЩИК" 
Хорошо работают в тех случаях, когда обе ГРУППЫ находятся под единым руководством (т.е., в конце концов, преследуют одни и те же це­ли), или же тогда, когда они относятся к разным организациям, но сами эти организации фактически находятся в таких взаимоотношениях. 
Определите четкие отношения "заказчик-поставщик" между двумя группами. На сеан­сах планирования нижняя группа должна играть роль заказчика по отношению к верхней. Обсуждайте и распределяйте задачи согласно требованиям нижней гpyппы, чтобы каждый в группе имел представление об обязательствах и временном графике работы.
Отношения заказчика и поставщика подразумевают, что потребности заказчика од­ нозначно стоят на первом месте. Но поскольку нижняя группа разработчиков не яв­ ляется единственным заказчиком, требования всех заказчиков приходится согласо­вывать в процессе переговоров. Тем не менее, именно за ними остается приоритет. Вместо таких отношений часто можно встретить отношения типа "бедный родствен­ ник", когда нижняя группа должна выпрашивать у верхней то, что ей нужно. Должен существовать набор автоматизированных тестов, который позволяет верх­ ней группе вносить изменения в код, не боясь что-нибудь испортить в работе ниж­ ней, а также дает возможность нижней группе сосредоточиться на своих задачах, а не постоянно контролировать деятельность верхней.
	
	3. КОНФОРМИСТ. 
Напоминает ОБЩЕЕ ЯДРО (SHARED KERNEL) тем, что у них есть: перекрывающаяся область, в которой модель одна и та же; области, в которых ваша модель аддитивно расширена; области, где вторая модель никак на вас не влияет. Разни­ца между шаблонами состоит в процессе принятия решений и ходе разработки. Если ОБЩЕЕ ЯДРО это сотрудничество между двумя тесно скоординированными группами, - то КОНФОРМИСТ представляет интеграцию с группой, которая фактически не заинтере­сована в сотрудничестве.	
	
	4. ПРЕДОХРАНИТЕЛЬНЫЙ СЛОЙ. 
Коrда строится новая система, которая должна иметь обширный интерфейс с дру­гой системой, трудность соотнесения одной модели с друrой может в конце концов на­чисто перечеркнуть всякий смысл новой модели, так как ее придется подстраивать под модель второй системы прямо на ходу. Модели старых, уже не поддерживаемых, сис­тем обычно посредственны, но даже какое-нибудь высококачественное исключение может не удовлетворять потребности текущеrо проекта. Тем не менее интеrpация с та­кими системами может иметь ценность, а иноrда она выдвиrается как катеrорическое требование.
Создайте "изолирующий слой" , который бы предоставлял клиентам нужные функ­ции в понятиях их собственной модели предметной области. Такой уровень будет об­ щаться с друrими системами через их существующие интерфейсы, что потребует лишь незначительной или вовсе никакой модификации этих друrих систем. Внутри же уров­ ня будет идти необходимая трансляция в обе стороны между двумя моделями.
	
	5. ОТДЕЛЬНОЕ СУЩЕСТВОВАНИЕ. 
Во многих обстоятельствах существенной отдачи от интеграции получить не удается. Если две функциональные части системы не нуждаются в операциях друг друга или взаимодействии между объектами, с которыми соприкасаются они обе, или совместном использовании данных, то интеграция даже через трансляционный уровень может ока­ заться необязательноЙ. Функциональные возможности не обязаны интегрироваться в одно целое только потому, ЧТО они совместно используются в каком-то случае. Объявите ОГРАНИЧЕННЫЙ КОНТЕКСТ ( BOUNDED CONTEXT) никак не связанным с другими контекстами. Это позволит разработчикам найти простые узкоспециализи­ рованные решения в данном ограниченном пространстве.

ДИСТИЛЛЯЦИЯ.

	Части модели, которые можно четко выделить как основные для выполнения главной задачи приложения, образуют ее СМЫСЛОВОЕ ЯДРО (CORE DOMAIN). Именно в СМЫСЛО­ ВОМ ЯДРЕ ваша система производит свой основной "добавочный продукт". "Упарьте " модель до минимума. Найдите ее СМЫСЛОВОЕ ЯДРО и сделайте так, что­ бы его можно б ыло легко отличить от массы вспомогательных частей модели и кода. Четко, рельефно выделите самые ценные и специализированные понятия. ЯДРО долж­ но быть небольшим по размеру. Подберите и направьте на разработку СМЫСЛОВОГО ЯДРА лучшие кадры. При рабо­ те над ЯДРОМ не жалейте усилий, чтобы построить углубленную модель и гибкую ар­ хитектуру, адекватно отражающую видение будущей системы. Вкладывайте ресурсы в другие части системы по тому критерию, насколько они важны ДЛЯ поддержки дис­ тиллированного СМЫСЛОВОГО ЯДРА.

	Приемы ДИСТИЛЛЯЦИИ:

	ВВЕДЕНИЕ В ПРЕДМЕТНУЮ ОБЛАСТЬ ( DOMAIN VISION STATEMENT)
Кратко опишите (примерно на страницу) СМЫСЛОВОЕ ЯДРО (CORE DOMAIN) предмет­ ной области и ее полезность - своего рода "деловое предложение". Игнорируйте те ас­ пекты, которые не отличают данную модель предметной области от других. Покажите, как модель служит разным интересам и создает баланс между ними. Напишите этот до­ кумент как можно раньше и вносите изменения по мере развития знаний о предмете.

	СХЕМАТИЧЕСКОЕ ЯДРО (HIGHLIGHTED CORE)
Напишите очень краткий документ (от трех до семи страниц крупным шрифтом), в котором описывается СМЫСЛОВОЕ ЯДРО (CORE ПОМАIN ) и основные взаимодействия между элементами этого ЯДРА. Отметьте все элементы СМЫСЛОВОГО ЯДРА (CORE DOMAIN) в основном информаци­ онном хранилище модели, не пытаясь особо разъяснять их роли. Сделайте так, чтобы разработчики легко видели, что входит в ЯДРО, а что в него не входит.

	НЕСПЕЦИАЛИЗИРОВАННЫЕ ПОДОБЛАСТИ (GENERIC SUBDOMAINS)
Модели, содержащие знания косвенно связанные с предметной областью - например функции работы с часовыми поясами, денежными единицами итд, нужно отделять от ядра. Внесение в такие модели специализированных элементов  - плохая идея, уменьшается расширяемость. Определите, какие из связных подобластей модели не являются основным мотивом к написанию вашего приложения. Рефакторингом выделите модели этих подобластей, имеющие общий характер, и поместите их в отдельные МОДУЛИ. Не оставляйте в них ни следа специфики вашего приложения. Как только такие области выделены, установите для них более низкий приоритет их дальнейшей разработки, чем у СМЫСЛОВОГО ЯДРА. Рассмотрите возможность при­ обрести готовое решение или взять общеизвестную модель для таких НЕСПЕЦИАЛИЗИ­ РОВАННЫХ ПОДОБЛАСТЕЙ ( GENERIC SUBDOMAINS ) .

Хотя ВВЕДЕНИЕ В ПРЕДМЕТНУЮ ОБЛАСТЬ ( DOMAIN VISION STATEMENT) и СХЕМАТИЧЕСКОЕ ЯДРО ( HIGHLIGHTED CORE) информируют и направляют группу, они фактиче­ски не приволят к модификации модели или кода. А вот выделение НЕСПЕЦИАЛИЗИРОВАННЫЕ ПОДОБЛАСТИ (GENERIC SUBDOMAINS) физически  устраняет некоторые отвлекающие элементы. 

	СВЯЗНЫЕ МЕХАНИЗМЫ (COHESIVE MECHANISMS).
Иногда вычисления настолько усложняются, что начинают "затуманивать" архи­тектуру. Концептуальное "что" становится трудно увидеть за обилием механических "как". Большое количество методов с алгоритмами для решения задачи заслоняет со­бой те методы, которые эту задачу ставят.
Выделите концептуально СВЯЗНЫЙ МЕХАНИЗМ ( COHESIVE MECHANISM ) в отдельную небольшую программную среду или библиотеку. Особое внимание окажите формализа­циям или хорошо документированным категориям алгоритмов. Функциональные воз­можности среды покажите с помощью ИНФОРМАТИВНОГО ИНТЕРФЕЙСА (INTENTION­ REVEALING INTERFACE ) . После этого другие элементы предметной области можно будет сосредоточить на выражении основной задачи ("что делать"), а тонкости ее решения ("как делать") передать новой среде.
МЕХАНИЗМЫ почти всегда необходимо удалять из СМЫСЛОВОГО ЯДРА модели (CORE DOMAIN). Единственное исключение - когда МЕХАНИЗМ сам по себе является неотъем­ лемой и ключевой частыо программы, создающей ее конкурентную ценность. Так иногда бывает с узкоспециализированными алгоритмами.

	ВЫДЕЛЕННОЕ ЯДРО (SEGREGATED CORE)
Момент для создания ВЫДЕЛЕННОГО ЯДРА наступает тогда, когда у вас есть большой ОГРАНИЧЕННЫЙ КОНТЕКСТ (BOUNDED CONТEXT), критически важный для системы, но при этом существенная часть модели запутана большим количеством вспомогательных функций.
Выполните ре факторинг модели так, чтобы отделить понятия СМЫСЛОВОГО ЯДРА (CORE DOMAIN) от вспомогательных элементов (включая неудачно определенные) и усилить связность ЯДРА, одновременно снижая его зависимость от остального кода. Факторизуйте все неспециализированные или вспомогательные элементы в другие объекты и поместите их в другие пакеты, даже если в ходе такого рефакторинга моде­ ли будут отделены сильно зависимые элементы.	
Выдсление ЯДРА иногда делает отношения с тесно взаимосвязанными классами, не входящими в ЯДРО, менее очевидными или даже более сложными. Но эта цена невелика по сравнению с такими преимуществами, как прояснение СМЫСЛОВОГО ЯДРА (CORE DOMAIN) и облегчение работы с ним.

	АБСТРАКТНОЕ ЯДРО (ABSTRACT CORE)
Определите наиболее фундаментальные понятия в модели и выделите их рефакто­рингом в отдельные классы, абстрактные классы или интерфейсы. Спроектируйте эту абстрактную модель так, чтобы она выражала большую часть взаимодействий между существенными компонентами. Поместите эту абстрактную модель в собственный МОДУЛЬ, оставив более специализированные классы конкретных программных реали­ заций в их собственных МОДУЛЯХ, определяемых подобластью. Моделирование АБСТРАКТНОГО ЯДРА требует глубокого понимания ключевых понятий предмета и ролей, которые они играют в основных взаимодействиях внутри системы. Другими словами, это пример углубляющего рефакторинга, при котором обычно проис­ ходит серьезная перестройка архитектуры.


КРУПНОМАСШТАБНАЯ АРХИТЕКТУРА

В отличие от КАРТЫ КОНТЕКСТОВ ( CONTEXT МАР ) , крупномасштабная структура­ вещь необязательная. Ее следует вводить, когда это выгодно по балансу затрат и резуль­ тата и когда имеется действительно подходящая структура. В ней нет нужды в системах, которые достаточно просты для понимания после разбиения их на модули. Крупно­масштабная структура должна вводиться в тех случаях, когда можно найти такую структуру, которая бы сделала систему намного понятнее, не накладывая неестест­венных ограничений на развитие модели. Плохо подходящая структура хуже , чем во­ обще никакой, поэтому не надо гнаться за всеобщностью охвата, а найти минимальное решение для возникших проблем. 

Трилемма ddd - невозможно одновременно достичь инкапсуляции, изоляции и хорошего быстродействия доменной модели. 
При выборе инкапсуляции и быстродействия осуществляется внедрение внепроцессных зависимостей в доменную модель, при выборе изоляции и быстродействия происходит разделение процесса принятия решения между доменной моделью и контроллерами, при выборе изоляции и инкапсуляции происходит смещение работы с внепроцессными зависимостями к границам бизнес-операции. 

Выполняя стратегическое планирование в проекте, начните с четкой оценки текущей ситуации:
1. Начертите КАРТУ КОНТЕКСТОВ. Можно ли сделать это естественным образом или есть препятствие в виде неоднозначности?
2. Обратите внимание на использование языка в проекте. Существует ли в нем ЕДИНЫЙ ЯЗЫК? Достаточно ли он богат, чтобы помочь в процессе разработки?
3. Определите самое важное. Обозначено ли в проекте СМЫСЛОВОЕ ЯДРО? Написано ли ВВЕДЕНИЕ В ПРЕДМЕТНУЮ ОБЛАСТЬ? А Вы можете его написать?
4. Помогает или мешает технология реализации проекта в ПРОЕКТИРОВАНИИ ПО МОДЕЛИ?
5. Обладают ли разработчики достаточными техническими навыками?
6. Хорошо ли разработчики знают саму предметную область? Вызывает ли она у них интерес?


Шесть принципов принятия решений при стратегическом проектировании
1. Решения должны доводиться до всех членов группы
	Какова бы ни была система, следует меньше беспокоиться об уровне полномочий, исхо­дящем от руководства, чем о реальной взаимосвязи между разработчиками и стратегией.
2. В nроцессе nринятия решений следует учитывать обратную связь
	В отличие от разработки технической инфраструктуры и архитектуры, стратегиче­ ское проектирование не подразумевает написания больших объемов кода, хотя и влияет на весь процесс разработки. А вот активное участие всех групп разработчиков оно как раз подразумевает. Опытный архитектор обладает умением слушать идеи, исходящие от различных людей, и способствовать выработке общего решения.
3. План должен допускать эволюцию, развитие
4. Разработчики архитектуры не должны nереманивать к себе лучшие кадры
	Важно иметь сильных проектировщиков во всех группах разработчиков. А в каждой группе, которая занимается стратегическим проектированием, необходимо иметь доста­ точно знаний по предметной области. 
5. В стратегическом nроектировании нужны минимализм и скромность
	Необходимо дисциплинировать себя и произвести на свет организую­щие принципы и ключевые модели, очищенные от всего, что не помогает улучшить чет­ кость и ясность архитектуры. 
6. Объекты - для специализации, разработчики - для обобщения
	Сущность хорошего объектно-ориентированного проектирования состоит в том, что­ бы дать каждому объекту четкие и узкоспециализированные обязанности, снизив взаи­ мозависимость с другими объектами до абсолютного минимума.

Не пишите архитектурные среды для "чайников " Если делить разработчиков на группы, подразумевая при этом, что некоторые из них неспособны к архитектурному проектированию, то впереди, скорее всего, вас ждет не­ удача, поскольку этим недооценивается сложность технической разработки приложения. Если вы считаете, что у этих людей не хватает ума проектировать, нечего поручать им разработку программ. А если ума у них хватает, тогда нянчиться с ними - это только ставить преграды между ними и требующимися им для работы инструментами.