класс без спецификатора доступа = видимость на уровне пакета
static при переменной = однократное присвоение значения
static final = константа

Значений по умолчанию в параметрах нет. Решается переопределением метода с вызовом переопределенного со значением (важно для конструкторов)
Переопределяющий метод должен возвращать либо тот же тип, что и переопределяемый, либо его подтип. Спецификатор доступа д.б. тот же или шире.
Хорошая практика - ставить аннотацию @Override.
Метод, сигнатура которого не использует обобщенные типы, перекрывает любые обобщенные версии этого метода.
Объявление метода т как abstract должно находиться непосредственно в классе,объявленном как abstract, если только он не находится в перечислении.
Абстрактный класс может перекрыть абстрактный метод, предоставляя объявление другого абстрактного метода. Метод экземпляра, не являющийся абстрактным, может быть перекрыт абстрактным методом.

нет перегрузки операторов.

Конструкторы, статические инициализаторы и инициализаторы экземпляров не явля­ются членами и, следовательно, не наследуются.

Блоки инициализации заменяют конструктор:
{      // Это блок инициализации
                 name = ...;
              }
В статических блоках инициализации (class initializers) код выполняется при первой загрузке класса:
static { }
В нестатических блоках инициализации (instance initializers) объекты инициализацируются вне зависимости от того, какой конструктор был вызван:
class Bar {
	{ }
}

Анонимные классы
Если имя, следующее за ключевым словом new, это имя класса, то анонимный класс является подклассом этого класса. Если имя, следующее за ключевым словом new, представляет собой интерфейс, то анонимный класс реализует этот интерфейс и расширяет класс Object. Данный синтаксис не позволяет указать секции extends, implements или имя класса. Вследствие этого анонимный класс может реализовать только один интерфейс.
Синтаксис вызова анонимного класса:
A a = new A() {
        . . . описание полей и методов порожденного класса . . .
        };
что аналогично:
class B extends A {
   . . . описание полей и методов порожденного класса . . .
}
// Использование класса B
A a = new B();

Компилятор осуществляет стирание параметров обобщенных методов.

instanceof - проверка на принадлежность к классу. Включает наследников. При передаче параметром null - выдает false.
equals - проверка объектов на равенство, метод определен в классе Objects. При переопределении нужн обеспечить следующее условие: если equals возвращает true, переопределенный метод hashcode тоже должен возвращать true. 

try c ресурсами - позволяет обрабатывать исключения, возникшие в finally. Пример- try ( InputStream is = new FileInputStream("new.txt" ) {
 readFromInputStream(is); }. Ресурс is гарантированно освобождается. Ресурс - класс реализующий интерфейс Autoclosable.

организация логгирования - import java.util.logging.*; ...Logger.getLogger(); setLevel - определяет уровень логгирования; addHandler - определяет способ логгирования (ConsoleHandler, FileHandler, SocketHandler);

новые классы для работы с файлами - java.nio.file
классы ByteArrayInputStream и ...Output... позволяют считывать и записывать поток в массив байтов.
Класс PrintWriter - форматированный вывод
самое удобное чтение потока java.util.Scanner
java.lang.ProcessBuilder - запуск внешних файлов
java.nio - неблокирующий ввод-вывод (в отличии от java.io)
сериализация объектов класса - требуется implement Serializable. JVM сама определяет способы сериализации. Ключевым словом transient помечают данные, сериализация которых не требуется. Для сериализации нужно использовать ObjectOutputStream. Для десериализации - ObjectInputStream.

Параметризация (дженерики)
<? super T> - любой супертип Т, включая Т
<? extends T> - любой подтип Т, включая Т

Например, у List есть много методов, некоторые из них производят, а другие потребляют обобщенные значения. 
Когда вы указываете  __extends T__, вы можете использовать только методы  __производители__ обощенных значений:
#List<? extends B> listOfB;
#B b = listOfB.get(0); // нормально
#listOfB.add(new B()); // ошибка компиляции
Указав __super T__, вы можете использовать только методы __потребители__ обощенных значений:
#List<? super B> listOfB;
#listOfB.add(new D()); // нормально
#B b = listOfB.get(0); // не скомпилируется

Коллекции: interface Collection extends Iterable
interface List - простая коллекция с доступом по индексу -> реализации ArrayList(список поверх массива) и LinkedList(двухсвязный список)
interface Queue - очередь добавление с конца (FIFO) -> интерфейс Deque(очередь с добавлением с двух концов) -> реализации ArrayDeque и LinkedList(sic!)
interface Set - множество уникальных значений -> реализации HashSet(множество на основе хэш-таблицы, использует метод hashCode), LinkedHashSet(упорядоченный), 
interface SortedSet(упорядоченный) -> реализации TreeSet
Можно создавать коллекции на основе созданных других коллекций 

interface Map (не наследует Colection, обход с помощью методов, возвращающих Set или Collection) - ассоциативный список -> реализации HashMap, LinkedHashMap и TreeMap.

Класс java.util.Collections содержит полезные утилиты для работы с коллекциями
коллекция в массив - toArray, массив в коллекцию - asList(например)

Рефлексии: RTTI получение информации о классе, его полях, методах(включая приватные), переопределение их свойств:
try {
       Field field = someClass.getClass().getDeclaredField("name");
       field.setAccessible(true);
       name = (String) field.get(myClass);
   } catch (NoSuchFieldException | IllegalAccessException e) {  }
Примечание: getFields() и getDeclaredFields() не возвращают поля класса-родителя!
Работа с методами аналогична, заменяем field на method.
создание экземпляра класса с приватным конструктором:
   MyClass myClass = null;
   try {
       Class clazz = Class.forName(MyClass.class.getName());
       myClass = (MyClass) clazz.newInstance();
   } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {  }

Функциональные интерфейсы - интерфейсы, описывающие ровно один метод. Функциональные интерфейсы общего назначения - java.util.function

Stream - java.util.stream - функциональные методы для работы с последовательностями (map, filter,limit, sum итд). Stream можно получить (например) из любой коллекции с помощью метода stream. Способов много.
Результирующие методы позволяют вернуть результат например в переменную или коллекцию.
